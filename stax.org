#+TITLE:     kdhouser/kdh.stax
#+AUTHOR:    Keith D Houser
#+EMAIL:     kdhouser24@gmail.com
#+DESCRIPTION: Project Notes for kdhouser24/kdh.stax
#+KEYWORDS:  syntax, org, document
#+LANGUAGE:  en
#+OPTIONS:   H:5 num:nil toc:4 p:t e:nil
#+STARTUP: entitiespretty
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src{background:black;color:white;} </style>

[[*Java Properties][Java Properties]]

[[*Java Class Path][Java Class Path]]

* TODOs

** DOING var-map (dynamic)
** TODO File tree
** TODO path-compare
** DOING verify all predicate return false, not nil
** TODO cleanup ¿TODO?
** TODO cleanup dev tree
*** TODO dev/clj/kdh/stax to this doc
*** TODO dev/clj to dev/clj/kdh/stax
** DOING cleanup #[​_p] (=>) (comment) in src tree
** TODO cleanup ¿TODO?
** CANCELED record location of error in original ops
   CLOSED: [2022-07-14 Thu 03:12]
** DONE throw errors
   CLOSED: [2022-07-13 Wed 11:05]
** DONE expand (if> !a !b else> !b !c)
   CLOSED: [2022-05-07 Sat 18:34]
** DONE snarfing let (lexical)
   CLOSED: [2022-05-07 Sat 18:34]
** DONE collect all errors
   CLOSED: [2022-05-29 Sun 17:41]
** DONE not an allowed operation
   CLOSED: [2022-05-29 Sun 17:41]
** DONE invoke no such function
   CLOSED: [2022-05-29 Sun 17:41]
** DONE invoke arity not pos-int
   CLOSED: [2022-05-29 Sun 17:41]
** DONE ref before def
   CLOSED: [2022-05-29 Sun 17:41]
** DONE insufficient stack for operation
   CLOSED: [2022-05-29 Sun 17:41]


* Introduction

  This document covers ~kdh/stax~ version "0.1.0", which is an implementation of the requirements in [[file:rpl-take-home-project1-clj.pdf]].

  I wrote this as an org-mode document in emacs and exported it to HTML using [[https://github.com/fniessen/org-html-themes][org-html-themes]] (theme ReadTheOrg).  If you use org-mode, I highly recommend ReadTheOrg and another package [[https://github.com/fniessen/emacs-leuven-theme][emacs-leuven-theme]] by the same author.

  org-mode allows in-document evaluation using source blocks like
  #+begin_example
  #+begin_src clojure :ns user :results value pp :exports both :eval no-export
  (clojure-version)
  #+end_src
  #+end_example
  which, when executed and exported, look like this:
  #+begin_src clojure :ns user :results value pp :exports both :eval no-export
  (clojure-version)
  #+end_src

  #+RESULTS:
  #+begin_example
  "1.11.1"
  #+end_example

  For brevity, when many results are needed I show them in the source block like so:
  #+begin_src clojure :ns user :results value pp :exports code :eval no-export
  (defstackfn f
    [!a !b !c] ; example uses input: 1 2 4. Stack starts empty.
    !a !b (invoke> + 2)!v1+ !c !c <pop> 2 (invoke> * 2)!v2+ (invoke> = 2)
    (if>
	!v1 !v2 (invoke> - 2)
	else> "false!!" (invoke> println 1)<pop> !v1 !v2 (invoke> * 2)))

  (=> #'user/f )

  (f 1 2 4)

  ;;+> false!!

  (=> [24] )
  #+end_src

  Here, the output is shown as comments following ~;;+>~ and return values are within ~(=> )~ form which is an alias of the ~comment~ macro I use to contain the structured and highlighted values returned by an evaluation.  You can see more of this in my dev tree which is where I play with code as I develop.

  Often, when I use the abbreviated format I do so within a ~clj~ block that is not meant to be evaluated within org-mode. I have configured ~clj~ for org-mode just enough to display clojure code formatting, but not enough to run with ~C-c C-c~ (~org-babel-execute-src-block~). Instead I ~C-c '~ in order to ~org-edit-src-code~ it in another window in clojure-mode with CIDER.  This is especially true in ~benchmark~ code, where timeouts are a problem.

** Workflow
  While I'm on the subject, this is how I work with a clojure project.  I start with a dev and src tree, that are identical in directory structure.
  #+begin_example
src
└── clj(s)
    └── kdh  
        └── stax
	
dev
└── clj(s)
    └── kdh
        └── stax
#+end_example

Every stax specific ~file.clj~ is in ~src/clj/kdh/stax/file.clj~ and has a dev cousin in ~dev/clj/kdh/stax/file-dev.clj~
(not file​​_​dev.clj, so I can catch accidental requires of dev files through name mangling failure -- Could not locate kdh/stax/file​_​dev_​_​init.class,clj)

*** Starting an nrepl
    
I start the project by opening an nrepl with lein or boot or clj tools in the project dir at a terminal first, and -- if it completes startup without errors -- quit and restart it in gnu screen (this allows re-attach following accidental disconnect from the terminal).  Then in emacs, I ~cider-connect-clj~ or ~cider-connect-cljs~ or ~cider-connect-clj-and-cljs~ as needed.

My dev profile in lein leaves me in ns user, which is defined in ~/dev/clj/user.clj~, where a (dev) function exists to enter ns dev defined in ~/dev/clj/dev.clj~. This allows me to keep experimental things in the ns dev and still get an nrepl up and running to debug.

~/dev/clj/dev.clj~ requires all of the basic: ~clojure.string~ :as ~str~, ~clojure.file.io~ :as ~io~, etc.  All ~-dev.clj~ files are in ns dev, so they benefit from the standard requires in ~dev.clj~. ~-dev.clj~ files mostly require src tree files (i.e. inside the project).

Any dev file can require any src tree file, but src tree files never require dev tree files!  When I develop something good in the dev files, I copy it over into a src tree file and require it back into the -dev.clj file cousin (ns-unmap'ing it if needed).

If I refactor (like when I split nodes.clj into node.clj and nodify.clj to fix a cyclic dependency), I restart the repl.

I favor mount over component because mount has a more granular restart.  I used neither in this project as it was sufficient to have an example file with operations of various complexity and errors.

Enough about me, onto the project.

* Assignment
   #+ATTR_HTML: :target _blank
    (original: [[file:rpl-take-home-project1-clj.pdf]])
*** Reformatted Assignment
    The goal of this project is to implement a Clojure interpreter for a stack-based DSL. An example of the API is on the next page. We are looking for an example of the quality of work you would do at RPL.
**** Page 1
***** Explanation of functionality:
      + Variables are symbols prefixed with "!", e.g. !v
      + A stack function is defined with "defstackfn".
	+ The first argument is the input declaration which also provides variable names to the arguments.
	+ The stack always starts empty
	+ The implementation of a stackfn is a sequence of stack operations.
	  + Using a constant as a stack operation pushes that value onto the stack
	  + Using a variable as a stack operation pushes the value for that variable onto the stack
	  + A variable is assigned the top value of the stack by appending "​+" to the variable name,  e.g. !v​+
	  + A function is invoked with "invoke>". "invoke>" takes as input the operation and the arity to use.
	  + <pop> is a special operation which removes the top value of the stack
	  + if> tests if the top value of the stack is truthy to determine which branch to follow. The branches are separated with "else>"
***** Notes about your implementation:
    + defstackfn should be a macro that produces a function invokable like any other  function.
    + Should provide an informative error if there's an invalid stack operation or a variable is referenced that doesn't exist.
    + The example below contains all functionality you need to implement.
    + It should be possible to shadow vars (naming a new local the name of an existing  variable).
    + Code example with stack values in comments:
**** Page 2
#+caption: Code example with stack values in comments:
 #+begin_src clojure :ns user -n :eval no-export
(defstackfn f
  [!a !b !c] ; example uses input: 1 2 4. Stack starts empty.
  !a ; 1
  !b ; 1 2
  (invoke> + 2) ; 3
  !v1+ ; 3
  !c ; 3 4
  !c ; 3 4 4
  <pop> ; 3 4
  2 ; 3 4 2
  (invoke> * 2) ; 3 8
  !v2+ ; 3 8
  (invoke> = 2) ; false
  (if> ; stack empty
    !v1
    !v2
    (invoke> - 2)
   else>
    "false!!" ; "false!!"
    (invoke> println 1) ; nil
    <pop> ; stack empty
    !v1 ; 3
    !v2 ; 3 8
    (invoke> * 2) ; 24
    )
  )

;; (f 1 2 4) prints "false!!" and returns 24
 #+end_src
* Requirements
** Explicit Requirements
   Explicit requirements are taken directly from the assignment. They are split into individual testable requirements, and designated *req-e-#:* where *e* means explicit, and *#* is a number.

*** DONE <<req-e-01>> *req-e-01*: Variables are symbols prefixed with "!", e.g. !v
    ~kdh.stax.nodify/nodify-op~ will create a node of type ~:kdh.stax.node/push-var~ iff the op passes the predicate ~kdh.stax.node/!symbol?~
    #+begin_src clj :exports code :eval no-export
    (defn !symbol?
      "True if op matches symbol of the form !v where v is anything but ! or +"
      [op]
      (and (symbol? op)
	   (boolean (re-find #"^![^!\+]+$" (name op)))))
    #+end_src
    declarations argument to defstackfn is also checked to pass ~kdh.stax.node/!symbol?~ in its :pre condition.
    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-01 [a b c] a b c)
    ;;!>  Assert failed: (test/is (every? !symbol? declarations))






    #+end_src
*** DONE <<req-e-02>> *req-e-02*: A stack function is defined with "defstackfn"

    Define a trivial stack function (with no declarations and only push numbers).

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-02 [] 1 2 3)
    (=> #'user/f-req-e-02 )
    #+end_src

    Yields a function, which when called returns the stack.

    #+begin_src clj :exports code :eval no-export
    (f-req-e-02)
    (=> [1 2 3] )
    #+end_src

*** DONE <<req-e-03>> *req-e-03*: The first argument is the input declaration which also provides variable names to the arguments

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-03 [!a !b !c] !b !a !c)
    (=> #'user/f-req-e-03 )

    (f-req-e-03 :a :b :c)
    (=> [:b :a :c] )
    #+end_src

*** DONE <<req-e-04>> *req-e-04*: The stack always starts empty

    Let's pop an empty stack to see what happens...

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-04 [] <pop>)
    ;;+>
    ;; 1st Path Errors [>-start-term->]:
    ;; 	`<pop>' at op[0] node[0]:
    ;; 		 stack size=0, operation <pop> needs >=1
    (=> :kdh.stax.errs/defstackfn-produced-errors )
    #+end_src

    I don't like to throw errors during dev, it's disruptive.  Instead, I return meaningful keys (here ~:kdh.stax.errs/defstackfn-produced-errors~).

    However, I recognize that others like Exceptions, so I allow them with a dynamic binding...

    #+begin_src clj :exports code :eval no-export
    (binding [*stax-throw-on-error* true]
      (try (defstackfn f-req-e-04 [] <pop>)
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=>
     ["defstackfn produced errors"
      {:error-data [["1st Path Errors [>-start-term->]: "

		     [{:op-type :kdh.stax.node/op=pop,
		       :needs 1,
		       :delta -1,
		       :op <pop>,
		       :node-index [0],
		       :op-index [0],
		       :errors [{:err-zone :kdh.stax.errs/zone=path,
				 :err-type :kdh.stax.errs/error=static-insufficient-stack,
				 :err-text "stack size=0, operation <pop> needs >=1"}]}]]],
       :error-text "\n1st Path Errors [>-start-term->]: \n\t`<pop>' at op[0] node[0]:\n\t\t stack size=0, operation <pop> needs >=1\n"}]
     )
    #+end_src

    Exceptions or not, I've proved the stack is initially empty!

*** DONE <<req-e-05>> *req-e-05*: The implementation of a stackfn is a sequence of stack operations
    #+begin_src clj
    (defstackfn f-req-e-05 [!a] !a 2 <pop> 3 (invoke> = 2) (if> "!a == 3>" else> "!a <> 3") (invoke> println 1))
    (=> #'user/f-req-e-05 )

    (f-req-e-05 1)
    ;;+ !a <> 3
    (=> [nil] )

    (f-req-e-05 3)
    ;;+ !a == 3
    (=> [nil] )
    #+end_src
*** DONE <<req-e-06>> *req-e-06*: Using a constant as a stack operation pushes that value onto the stack

    In my implementation, I interpret /constant/ as a form that evaluates to itself.

    [[https://clojure.org/reference/evaluation][The Clojure reference page on evaluation]] says:
    
    #+begin_quote
    Strings, numbers, characters, true, false, nil and keywords evaluate to themselves.
    #+end_quote

    That quote is part of the documentation string for my function ~ksh.stax.node/self-evaluating?~:
    
    #+begin_src clj :exports code :eval no-export
    (doc self-evaluating?)
    ;;+>
    ;; -------------------------
    ;; kdh.stax.node/self-evaluating?
    ;; ([op])
    ;;     True if op is a self evaluating form.
    ;;   https://clojure.org/reference/evaluation says 'Strings, numbers, characters, true, false, nil and keywords evaluate to themselves.'
    #+end_src

    Let's push one of each onto the stack

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-06 [] "string" 42 \z true false nil :bubba)
    (=> #'user/f-req-e-06 )

    (f-req-e-06)
    (=> ["string" 42 \z true false nil :bubba] )
    #+end_src

*** DONE <<req-e-07>> *req-e-07*: A variable is assigned the top value of the stack by appending "​+" to the variable name,  e.g. !v​+

    #+begin_src clojure :ns user :results value pp :exports both :eval no-export
    (defstackfn f-req-e-07 [] "string" 42 !v1+ \z true false nil :bubba !v1)
    (=> #'user/f-req-e-07 )

    (f-req-e-07)
    (=> ["string" 42 \z true false nil :bubba 42] )
    #+end_src

    !v1+ assigned the top of the stack (42) to the variable !v1 as evidenced by the top of the returned stack after the final !v1 push.

*** DONE <<req-e-08>> *req-e-08*: A function is invoked with "invoke>".

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-08 [] "string" 42 !v1+ \z true false nil :bubba !v1 (invoke> println 1))
    (=> #'user/f-req-e-08 )

    (f-req-e-08)
    ;;+> 42
    (=> ["string" 42 \z true false nil :bubba nil] )
    #+end_src

*** DONE <<req-e-09>> *req-e-09*: "invoke>" takes as input the operation

    The first argument to ~invoke>~ must be a function (in this example ~+~)

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-09 [!a !b] !a !b (invoke> + 2))
    (=> #'user/f-req-e-09 )

    (f-req-e-09 2 3)
    (=> [5] )

    (f-req-e-09 :foo "bar")
    ;;+>
    ;; RUNTIME ERRORS:
    ;; 	`(invoke> + 2)' at op[2] node[2]:
    ;; 		 `(apply #'clojure.core/+ ("bar" :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))
    (=> :kdh.stax.errs/stackfn-produced-runtime-error )
    #+end_src

    Or, if you prefer Exceptions...

    #+begin_src clj :exports code :eval no-export
    (binding [*stax-throw-on-error* true]
      (try (f-req-e-09 :foo "bar")
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=>
     ["Runtime Errors"
      {:error-text "\nRUNTIME ERRORS:\n\t`(invoke> + 2)' at op[2] node[2]:\n\t\t `(apply #'clojure.core/+ (\"bar\" :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))\n",
       :error-data [["RUNTIME ERRORS:"
		     [{:errors [{:err-zone :kdh.stax.errs/zone=exec,
				 :err-type :kdh.stax.errs/error=runtime-invoke-failed,
				 :err-text "`(apply #'clojure.core/+ (\"bar\" :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))"}],
		       :needs 2,
		       :fun +,
		       :turns ["start"],
		       :invoke-args ("bar" :foo),
		       :trace [{:needs 0,
				:dot-opts {:shape :point},
				:node-index [],
				:delta 0,
				:stack [],
				:op-index [],
				:branch :start,
				:var-map {!a :foo,
					  !b "bar"},
				:op-type :kdh.stax.node/op=start}
			       {:needs 0,
				:op !a,
				:node-index [0],
				:delta 1,
				:stack [:foo],
				:op-index [0],
				:var-map {!a :foo,
					  !b "bar"},
				:op-type :kdh.stax.node/op=push-var,
				:var-ref !a}
			       {:needs 0,
				:op !b,
				:node-index [1],
				:delta 1,
				:stack [:foo "bar"],
				:op-index [1],
				:var-map {!a :foo,
					  !b "bar"},
				:op-type :kdh.stax.node/op=push-var,
				:var-ref !b}
			       {:errors [{:err-zone :kdh.stax.errs/zone=exec,
					  :err-type :kdh.stax.errs/error=runtime-invoke-failed,
					  :err-text "`(apply #'clojure.core/+ (\"bar\" :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))"}],
				:needs 2,
				:fun +,
				:invoke-args ("bar" :foo),
				:op (invoke> + 2),
				:invoke-fn #'clojure.core/+,
				:node-index [2],
				:delta -1,
				:arity 2,
				:op-index [2],
				:op-type :kdh.stax.node/op=invoke}],
		       :op (invoke> + 2),
		       :invoke-fn #'clojure.core/+,
		       :var-init-map {!a :foo,
				      !b "bar"},
		       :node-index [2],
		       :delta -1,
		       :arity 2,
		       :op-index [2],
		       :op-type :kdh.stax.node/op=invoke}]]]}]
     )
    #+end_src

*** DONE <<req-e-10>> *req-e-10*: "invoke>" takes as input the arity to use

    #+begin_src clj :exports code :eval no-export
	(defstackfn f-req-e-10 [!a !b] !a !b (invoke> + 2))
	(=> #'user/f-req-e-10 )

	(f-req-e-10 2 3)
	(=> [5] )

	(defstackfn f-req-e-10* [!a !b] !a !b (invoke> + 0))
	;;+>
	;; Global Operation Tree Errors: 
	;; 	`(invoke> + 0)' at op[2] node[2]:
	;; 		 0 is not a valid arity (must be pos-int)!
	(=> :kdh.stax.errs/defstackfn-produced-errors )
    #+end_src

    Or, if you prefer Exceptions...

    #+begin_src clj :exports code :eval no-export
    (binding [*stax-throw-on-error* true]
      (try (defstackfn f-req-e-10* [!a !b] !a !b (invoke> + 0))
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=> ["defstackfn produced errors"
	 {:error-data [["Global Operation Tree Errors: "
			[{:op-type :kdh.stax.node/op=invoke,
			  :op (invoke> + 0),
			  :fun +,
			  :arity 0,
			  :errors [{:err-zone :kdh.stax.errs/zone=tree,
				    :err-type :kdh.stax.errs/error=parse-invoke-arity-not-pos-int,
				    :err-text "0 is not a valid arity (must be pos-int)!"}],
			  :node-index [2],
			  :op-index [2]}]]],
	  :error-text "\nGlobal Operation Tree Errors: \n\t`(invoke> + 0)' at op[2] node[2]:\n\t\t 0 is not a valid arity (must be pos-int)!\n"}] )
    #+end_src

*** DONE <<req-e-11>> *req-e-11*: <pop> is a special operation which removes the top value of the stack

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-11 [] 1 2 <pop> 3 )
    (=> #'user/f-req-e-11 )

    (f-req-e-11)
    (=> [1 3] )
    #+end_src

    2 got <pop>'d

*** DONE <<req-e-12>> *req-e-12*: if> tests if the top value of the stack is truthy to determine which branch to follow.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-12 [!a] !a (invoke> even? 1) (if> "even" else> "odd"))
    (=> #'user/f-req-e-12 )

    (f-req-e-12 3)
    (=> ["odd"] )

    (f-req-e-12 4)
    (=> ["even"] )
    #+end_src

*** DONE <<req-e-13>> *req-e-13*: The branches of if are separated with "else>"

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-13 [!a] !a (invoke> even? 1) (if> "even" else> "odd"))
    (=> #'user/f-req-e-13 )

    (f-req-e-13 3)
    (=> ["odd"] )

    (f-req-e-13 4)
    (=> ["even"] )
    #+end_src

    Note, my implementation works with a missing ~else>~.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-13* [!a] !a (invoke> even? 1) (if> "even"))
    (=> #'user/f-req-e-13* )

    (f-req-e-13* 3)
    (=> [] )

    (f-req-e-13* 4)
    (=> ["even"] )
    #+end_src

    It works with an empty else>.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-13** [!a] !a (invoke> even? 1) (if> "even" else>))
    (=> #'user/f-req-e-13** )

    (f-req-e-13** 3)
    (=> [] )

    (f-req-e-13** 4)
    (=> ["even"] )
    #+end_src

    It works with an empty then (the ops between the ~if>~ and ~else>~).

    #+begin_src clojure :ns user :results value pp :exports both :eval no-export
    (defstackfn f-req-e-13*** [!a] !a (invoke> even? 1) (if> else> "odd"))
    (=> #'user/f-req-e-13*** )

    (f-req-e-13*** 3)
    (=> ["odd"] )

    (f-req-e-13*** 4)
    (=> [] )
    #+end_src

    It even works with an empty then and missing else>.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-13**** [!a] !a (invoke> even? 1) (if>))
    (=> #'user/f-req-e-13**** )

    (f-req-e-13**** 3)
    (=> [] )

    (f-req-e-13**** 4)
    (=> [] )
    #+end_src
*** DONE <<req-e-14>> *req-e-14*: defstackfn should be a macro....

    #+begin_src clj :exports code :eval no-export
    (meta #'defstackfn)
    (=>
     {:arglists ([stackfn-sym declarations & operations]),
      :doc "Defines a stack function that takes declaration as its args,
    and performs to operations given",
      :line 81,
      :column 1,
      :file "/home/keith/clj/rpl/stax/src/clj/kdh/stax/core.clj",
      :name defstackfn,
      :ns #namespace[kdh.stax.core],
      :macro true}
    )
    #+end_src

*** DONE <<req-e-15>> *req-e-15*: defstackfn should produce a function invokable like any other function.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-15 [!a !b !c] !c !b !a)
    (=> #'user/f-req-e-15 )

    (f-req-e-15 1 2 3)

    (=> [3 2 1] )

    (->> [1 2 3 :a :b :c]
	 (partition 3)
	 (map (partial apply f-req-e-15)))

    (=> ([3 2 1] [:c :b :a]) )
    #+end_src

*** DONE <<req-e-16>> *req-e-16*: defstackfn should provide an informative error if there's an invalid stack operation

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-16 [] true (if> "even" else> else> "odd"))
    (=> :kdh.stax.errs/defstackfn-produced-errors )
    ;;+>
    ;; Global Operation Tree Errors:
    ;; 	`else>' at op[1 3] node[1 :else 0]:
    ;; 		 else> is not an allowed op
    #+end_src

    Or, if you prefer Exceptions...

    #+begin_src clj :exports code :eval no-export
    (binding [*stax-throw-on-error* true]
      (try (defstackfn f-req-e-16 [] true (if> "even" else> else> "odd"))
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=>
     ["defstackfn produced errors"
      {:error-data [["Global Operation Tree Errors: "
		     [{:op else>,
		       :op-type :kdh.stax.nodify/op=illegal,
		       :errors [{:err-zone :kdh.stax.errs/zone=tree,
				 :err-type :kdh.stax.errs/error=parse-illegal-operation,
				 :err-text "else> is not an allowed op"}],
		       :node-index [1 :else 0],
		       :op-index [1 3]}]]],
       :error-text "\nGlobal Operation Tree Errors: \n\t`else>' at op[1 3] node[1 :else 0]:\n\t\t else> is not an allowed op\n"}]
     )
    #+end_src

*** DONE <<req-e-17>> *req-e-17*: defstackfn should provide an informative error if there's a variable is referenced that doesn't exist.

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-17 [] true !a)
    (=> :kdh.stax.errs/defstackfn-produced-errors )
    ;;+>
    ;; 1st Path Errors [>-start-term->]:
    ;; 	`!a' at op[1] node[1]:
    ;; 		 !a is a reference before definition
    #+end_src

    Or, if you prefer Exceptions...

    #+begin_src clj :exports code :eval no-export
    (binding [*stax-throw-on-error* true]
      (try (defstackfn f-req-e-17 [] true !a)
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=>
     ["defstackfn produced errors"
      {:error-data [["1st Path Errors [>-start-term->]: "
		     [{:errors [{:err-zone :kdh.stax.errs/zone=path,
				 :err-type :kdh.stax.errs/error=static-var-not-defined,
				 :err-text "!a is a reference before definition"}],
		       :needs 0,
		       :op !a,
		       :cardi 2,
		       :node-index [1],
		       :delta 1,
		       :op-index [1],
		       :op-type :kdh.stax.node/op=push-var,
		       :var-ref !a}]]],
       :error-text "\n1st Path Errors [>-start-term->]: \n\t`!a' at op[1] node[1]:\n\t\t !a is a reference before definition\n"}]
     )
    #+end_src
*** DONE <<req-e-18>> *req-e-18*: It should be possible to shadow vars (naming a new local the name of an existing variable).

    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-e-18 [!a !b] !a true !b !a+ 3 !b+ "help" !a !b)
    (=> #'user/f-req-e-18 )

    (f-req-e-18 :red :blue)
    (=> [:red true :blue 3 "help" :blue 3] )
    #+end_src

*** DONE <<req-e-19>> *req-e-19*: The example below contains all functionality you need to implement.
    This is not a testable requirement, but I will rely on it for justification of implicit requirements
** Implicit requirements (*req-i-#*)
   Implicit requirements are those not expressed in the explicit requirements, but implied by them or by simple logical extension.
*** DONE <<req-i-01>> *req-i-01*: ~defstackfn~ can take an empty declarations argument
    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-i-01 [] 1 2 (invoke> + 2))
    (=> #'user/f-req-i-01 )

    (f-req-i-01)
    (=> [3] )
    #+end_src
*** DONE <<req-i-02>> *req-i-02*: ~if>~ consumes the top of the stack
    + According to the explicit requirements,
      #+begin_quote
      if> tests if the top value of the stack is truthy to determine which branch to follow. The branches are separated with "else>"
      #+end_quote
    + However, the example shows the stack as empty on line 14:
    #+begin_src clj -n13 :exports code :eval no-export
    (invoke> = 2) ; false
    (if> ; stack empty
    #+end_src

    if ~if>~ simply tested the top of the stack without popping, the push of the constant value ~"false!!"~ (line 19 above) would result in a stack of ~[false "false!!"]~ not ~["false!!"]~ as indicated:
    #+begin_src clj -n18 :exports code :eval no-export
    else>
     "false!!" ; "false!!"
    #+end_src
    
    Therefore, I deduce an implicit requirement that ~if>~ first tests the top value and then pops it from the stack
*** DONE <<req-i-03>> *req-i-03*: ~!v​+~ (define variable and assign it top of stack) does not consume the top of the stack
    Otherwise the following section of the example would not be correct
    + push of value in stack variable ~!c~ would result in a stack of ~[4]~ if ~!v1+~ consumed to top, but the example shows:
    #+begin_src clj -n5 :exports code :eval no-export
    (invoke> + 2) ; 3
    !v1+ ; 3
    !c ; 3 4
    #+end_src
    ~!v2+~ would leave the stack at ~[3]~ if assignment consumed the top.  This would cause ~(invoke> = 2)~ to fail, as the stack would have would  only one value, but the example shows:
    #+begin_src clj -n11 :exports code :eval no-export
    (invoke> * 2) ; 3 8
    !v2+ ; 3 8
    (invoke> = 2) ; false
    #+end_src
-----
*** DONE <<req-i-04>> *req-i-04*: ~(invoke> fun n)~ applies n items off the top of the stack in stack order (i.e. reverse of underlying vector's order)
    This is not explicitly stated in the assignment.  And it is not evident in the example, where all invoked functions are either associative functions (~+~, ~*~, and ~=~) with arity=2, or are only given n=1 (e.g. ~println~).  But I find this an implicit requirement of stack logic.  If an invoked function of one argument takes its argument from the top of the stack, then a function of two should take its first from the top, pop the stack, then take its next from the new top.  Internally, this is accomplished with the ~apply~ of the reverse (through ~rseq~) of the ~subvec~ of the last ~n~ items in the stack.
    #+begin_src clj :exports code :eval no-export
    (defstackfn f-req-i-04 [] 1 2 3 4 (invoke> println 4))
    (=> #'user/f-req-i-04 )

    (f-req-i-04)
    ;;+> 4 3 2 1
    #+end_src
*** DONE <<req-i-05>> *req-i-05*: ~(invoke> fun n)~ for the sake of consistency, the return value of invoke should be /constant/ (i.e. self-evaluating)
    #+begin_src clj
    (defstackfn f-req-i-05 [!a !b !c] !a !b !c (invoke> vector 3))

    (=> #'user/f-req-i-05 )


    (f-req-i-05 1 2 3)
    ;;+>
    ;; RUNTIME ERRORS:
    ;; 	`(invoke> vector 3)' at op[3] node[3]:
    ;; 		 `(apply #'clojure.core/vector (3 2 1))' => `[3 2 1]' with *stax-require-simple-stack-values* = true
    (=> :kdh.stax.errs/stackfn-produced-runtime-error )

    (binding [*stax-throw-on-error* true]
      (try (f-req-i-05 1 2 3)
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))
    (=>
     ["Runtime Errors"
      {:error-text "\nRUNTIME ERRORS:\n\t`(invoke> vector 3)' at op[3] node[3]:\n\t\t `(apply #'clojure.core/vector (3 2 1))' => `[3 2 1]' with *stax-require-simple-stack-values* = true\n",
       :error-data [["RUNTIME ERRORS:" [{:errors [{:err-zone :kdh.stax.errs/zone=exec,
						   :err-type :kdh.stax.errs/error=runtime-invoke-returned-complex-val,
						   :err-text "`(apply #'clojure.core/vector (3 2 1))' => `[3 2 1]' with *stax-require-simple-stack-values* = true"}],
					 :invoke-val [3 2 1],
					 :needs 3,
					 :fun vector,
					 :turns ["start"],
					 :invoke-args (3 2 1),
					 :trace [{:needs 0,
						  :dot-opts {:shape :point},
						  :node-index [],
						  :delta 0,
						  :stack [],
						  :op-index [],
						  :branch :start,
						  :var-map {!a 1,
							    !b 2,
							    !c 3},
						  :op-type :kdh.stax.node/op=start}
						 {:needs 0,
						  :op !a,
						  :node-index [0],
						  :delta 1,
						  :stack [1],
						  :op-index [0],
						  :var-map {!a 1,
							    !b 2,
							    !c 3},
						  :op-type :kdh.stax.node/op=push-var,
						  :var-ref !a}
						 {:needs 0,
						  :op !b,
						  :node-index [1],
						  :delta 1,
						  :stack [1 2],
						  :op-index [1],
						  :var-map {!a 1,
							    !b 2,
							    !c 3},
						  :op-type :kdh.stax.node/op=push-var,
						  :var-ref !b}
						 {:needs 0,
						  :op !c,
						  :node-index [2],
						  :delta 1,
						  :stack [1 2 3],
						  :op-index [2],
						  :var-map {!a 1,
							    !b 2,
							    !c 3},
						  :op-type :kdh.stax.node/op=push-var,
						  :var-ref !c}
						 {:errors [{:err-zone :kdh.stax.errs/zone=exec,
							    :err-type :kdh.stax.errs/error=runtime-invoke-returned-complex-val,
							    :err-text "`(apply #'clojure.core/vector (3 2 1))' => `[3 2 1]' with *stax-require-simple-stack-values* = true"}],
						  :invoke-val [3 2 1],
						  :needs 3,
						  :fun vector,
						  :invoke-args (3 2 1),
						  :invoke-apply (apply #'clojure.core/vector (3 2 1)),
						  :op (invoke> vector 3),
						  :invoke-fn #'clojure.core/vector,
						  :node-index [3],
						  :delta -2,
						  :arity 3,
						  :op-index [3],
						  :op-type :kdh.stax.node/op=invoke}],
					 :invoke-apply (apply #'clojure.core/vector (3 2 1)),
					 :op (invoke> vector 3),
					 :invoke-fn #'clojure.core/vector,
					 :var-init-map {!a 1,
							!b 2,
							!c 3},
					 :node-index [3],
					 :delta -2,
					 :arity 3,
					 :op-index [3],
					 :op-type :kdh.stax.node/op=invoke}]]]}]
     )

    #+end_src
*** DONE <<req-i-06>> *req-i-06*: ~(invoke> fun n)~ for the sake of consistency, values passed to the defstackfn defined function should be /constant/ (i.e. self-evaluating)
    #+begin_src clj
    (defstackfn f-req-i-05 [!a !b !c] !a !b !c (invoke> println 3))

    (=> #'user/f-req-i-05 )


    (f-req-i-05 1 [:a :b :c] 3)

    ;;+> Complex args are forbidden: arg#1:[:a :b :c]

    (=> :kdh.stax.errs/stackfn-complex-args-forbidden )

    (binding [*stax-throw-on-error* true]
      (try (f-req-i-05 1 [:a :b :b] 3)
	   (catch Exception e [(ex-message e)
			       (ex-data e)])))

    (=>
     ["Complex args are forbidden: arg#1:[:a :b :b]"
      {:complex-args ([1 [:a :b :b]])}]
    )
    #+end_src    
*** DONE <<req-i-07>> *req-i-07*: ~kdh.stax.core/defstackfn~ creates a named function that returns the remaining stack as a vector
    Internally, I represent the stack as a vector whose rightmost value is its top.  This choice is idiomatic because ~clojure.core/pop~ of a vector returns a vector like it's argument, but without the last item.  I note that none of the stack state comments in the given example show any enclosing structure.  And they all treat the right-most as the top.  Of course, there is nothing preventing the choice of a list or queue, as pop works on those. It is just my reasoned and experience choice to use a vector.
    Further, I return the stack and not its top because that would destroy important information (the rest of the stack).  As a general principle, I do not believe in descarding valid data -- the final state of the stack is useful in debugging.  And if the user wishes to only have the top, they can always peek it.  If I only return the top, however, the user cannot access (or even be aware of) the remaining discarded stack.
* Using ~defstackfn~
** ~<name>~: the named function defined by ~defstackfn~
  As required (see [[Requirements]]), ~(defstackfn <name> <declarations> <operations>...)~
  defines a function of name ~<name>~ that takes a vector of !v like ~<declarations>~ and any number of ~<operations>~.

  #+begin_src clojure :ns user :eval no-export
  (defstackfn f
    [!a !b !c]
    !a
    !b
    (invoke> + 2)
    !v1+
    !c
    !c
    <pop>
    2
    (invoke> * 2)
    !v2+
    (invoke> = 2)
    (if>
      !v1
      !v2
      (invoke> - 2)
     else>
      "false!!"
      (invoke> println 1)
      <pop>
      !v1
      !v2
      (invoke> * 2)
      )
    )

  (=> #'user/f )
  #+end_src

  Calling the newly created function with the 3 args in the example gives the expected output and return value.

  #+caption: RPL Example as a function call to the ~defstackfn~ defined ~f~
  #+begin_src clojure :ns user :eval no-export
  (f 1 2 4)

  ;;+> false!!

  (=> [24] )
  #+end_src

This is implemented in the ~defstackfn~ macro expansion as a call to ~kdh.stax.core/stackfn~ whose first argument is the node-data that <name> closes over, and whose remaining arguments are the values you give ~defstackfn~ defined function.

~stackfn~ can be called using ~kdh.stax.nodify/build-node-data~ to achieve the same results as the named function:

#+caption: RPL Example as a function call to ~kdh.stax.core/stackfn~
#+begin_src clojure
(stackfn (build-node-data '[!a !b !c]
                           ex/ops-rpl-example)
          1 2 4)

;;+> false!!

(=> [24] )
#+end_src

** ~<name>-dbg~: the debug function defined by ~defstackfn~
  In addition, ~kdh.stax.core/defstackfn~ also defines a function named ~<name>-dbg~ (in the example, ~f-dbg~), which when called with no arguments, returns the node-data as a map. This is the same node data that ~f~ closes over, hence the name ~f-dbg~.

  Like the named function ~<name>~ (in the example, ~f~), ~<name>-dbg~ can take arguments of the the same number as the ~declarations~ given to ~defstackfn~.  Called with arguments, ~<name>-dbg~ returns the node-data with an extra key ~:results~. ~<name>-dbg~ can take arguments in any number that is a multiple of ~declarations~, returning for results (allowing the user to simulate multiple calls to ~name~ function with different values).

  Here is the structure of ~:results~

  + ~:results~ :: a vector of result maps
    - a result map is the last op node executed in one of the runs, with the following additional keys:
      + ~:errors~ :: if present a vector of runtime errors for the last node in the result.
      + ~:output~ :: a string of the output ("false!!" in the RPL example)
      + ~:trace~ :: a vector of nodes passed through from start of the execution to this node
      + ~:stack~ :: the final value of the stack (~[24]~ in the RPL example)
	+ ~:stack~ is not present if ~:errors~ is present, as ~stack~ is the value after executing the result node
	  + to find the last good state of ~stack~ if the result has ~:errors~, peek the pop of ~:trace~
      + ~:turns~ :: like the path turns, a vector of strings describing the branches passed through until the result node
      + ~:var-init-map~ :: the map of the declarations given to the execution that ends in the result node
      + ~:var-map~ :: the map of the current variable bindings
	+ ~:var-map~ is not present if ~:errors~ is present
	  + peek the pop of ~:trace~ for the last good value of ~:var-map~



  #+caption: RPL Example as a function call to the ~defstackfn~ defined ~f-dbg~
  #+begin_src clojure
  (->> (f-dbg 1 2 4)
       :results
       (mapv #(select-keys % [:var-init-map :var-map :turns :output :stack])))

  (=> [{:var-init-map {!a 1, !b 2, !c 4},
	:var-map {!a 1, !b 2, !c 4, !v1 3, !v2 8},
	:turns ["start" "else"],
	:output "false!!\n",
	:stack [24]}] )


  ;; AND WITH MULTIPLE RUNS

  (->> (f-dbg 1 2 4
	      3 3 3)
       :results
       (mapv #(select-keys % [:var-init-map :var-map :turns :output :stack])))

  (=> [{:var-init-map {!a 1, !b 2, !c 4},
	:var-map {!a 1, !b 2, !c 4, !v1 3, !v2 8},
	:turns ["start" "else"],
	:output "false!!\n", :stack [24]}
       {:var-init-map {!a 3, !b 3, !c 3},
	:var-map {!a 3, !b 3, !c 3, !v1 6, !v2 6},
	:turns ["start" "then"],
	:output "", :stack [0]}] )
  #+end_src

  Like with the relationship between the ~defstackfn~ defined function ~f~ and its call to ~stackfn~ with the node-data closure, ~<name>-dbg~ also calls its own helper function, ~stackfn-dbg~.  And we can use that to debug without touching ~defstackfn~.

#+caption: RPL Example as a function call to ~kdh.stax.core/stackfn-dbg~
#+begin_src clojure
(->> (stackfn-dbg
      (build-node-data '[!a !b !c] ex/ops-rpl-example)
      1 2 4
      3 3 3)
     :results
     (mapv #(select-keys % [:var-init-map :var-map :turns :output :stack])))

(=> [{:var-init-map {!a 1, !b 2, !c 4},
      :var-map {!a 1, !b 2, !c 4, !v1 3, !v2 8},
      :turns ["start" "else"],
      :output "false!!\n",
      :stack [24]}
     {:var-init-map {!a 3, !b 3, !c 3},
      :var-map {!a 3, !b 3, !c 3, !v1 6, !v2 6},
      :turns ["start" "then"],
      :output "", :stack [0]}] )
#+end_src

------
Now that we've played with the results of ~defstackfn~ and its helper functions, lets explore the node-data

* Nodes

   nodes are maps, describing an operation and its properties

   #+caption: Operations, Nodes, and Their Predicates
  | Operation           | Op Predicate     | Node ~:op-type~ | Node Predicate | Description                                                                                                              |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | !v                  | !symbol?         | ::op=push-var   | push-var-node? | op to push the value of a stack variable onto the stack                                                                  |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | const               | self-evaluating? | ::op=push-sef   | push-sef-node? | op to push the value of a self evaluating form onto the stack (number, string, character, keyword, boolean, nil)         |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | <pop>               | <pop>?           | ::op=pop        | pop-node?      | op to pop the top of the stack                                                                                           |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | !v+                 | !symbol+?        | ::op=def-var    | def-var-node?  | op to define a (possibly new) stack variable and assign it the top of the stack without changing the stack               |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | (invoke> f n)       | invoke>?         | ::op=invoke     | invoke-node?   | op to invoke a function (f) on a number (n) of stack values. Those n values are removed from the stack and the return value of f pushed onto the stack |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | (if>... else>...) | if>?             | ::op=if         | if-node?       | op to branch conditionally into :then or :else based on the thruthiness of the top of the stack.  The top of the stack is pop'd. :then and :else are vectors of nodes |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|
  | any other form      |                  | ::op=illegal    | illegal-node?  | not a legal op                                                                                                           |
  |---------------------+------------------+-----------------+----------------+--------------------------------------------------------------------------------------------------------------------------|

Each legal op node requires 0 or more stack values (its ~:needs~), and changes the size of the stack by some integer number (its ~:delta~)

   #+caption: Node and Their Effect on the Stack
  | Node ~:op-type~ | :needs | :delta |
  |-----------------+--------+--------|
  | ::op=push-var   |      0 |     +1 |
  | ::op=push-sef   |      0 |     +1 |
  | ::op=pop        |      1 |     -1 |
  | ::op=def-var    |      1 |      0 |
  | ::op=invoke     |      n | -(n-1) |
  | ::op=if         |      1 |     -1 |
  | ::op=illegal    |     NA |     NA |
  |-----------------+--------+--------|

   Each op node has some of the keys.

   #+caption: Node Keys
  | KEY           | VALUE           | OPTIONALITY        | DESCRIPTION                                                         |
  |---------------+-----------------+--------------------+---------------------------------------------------------------------|
  | ~:op~         | expr            | All nodes          | the operation as a quoted value                                     |
  | ~:op-type~    | key             | All nodes          | See operation table                                                 |
  | ~:needs~      | int >= 0        | All legal          | how many stack values the operation requires                        |
  | ~:delta~      | int             | All legal          | the change to the stack size after execution of the node            |
  | ~:op-index~   | vector          | All nodes          | vector of pos-int to the operation in the original sequence         |
  | ~:node-index~ | vector          | All nodes          | vector of pos-int to the operation in the resulting node-tree       |
  | ~:fun~        | fn?             | invoke>            | function value of invoke> operation                                 |
  | ~:arity~      | pos-int?        | invoke>            | number of stack items the invoke> :fun will consume (same as needs) |
  | ~:then~       | vector of nodes | if>                | a node subtree to follow if the top of the stack is truthy          |
  | ~:else~       | vector of nodes | if>                | a node subtree to follow if the top of the stack is falsey          |
  | ~:var-ref~    | !v              | def-var push-var   | !v form symbol for stack variable                                   |
  | ~:var-def~    | !v+             | def-var            | !v+ form for stack variable (::op=def-var only)                     |
  | ~:branch~     | keyword         | start if-pop termn | Represents path start, turn , and end                               |
  | ~:errors~     | vector of maps  | Any                | (See [[*Errors][Errors]])                                                        |




Internally, nodes are created by ~kdh.stax.nodify/nodify-ops~, which returns a node-tree.
Operationally, build-node-data takes the declarations and operations arguments of defstackfn and returns a map of node data.

* Node Data
  The node data generated by ~kdh.stax.nodify/build-node-data~ is a map that contains the following keys:
  + ~:declarations~ ::
    The declarations vector passed to ~defstackfn~
  + ~:operations~ ::
    The operations sequence passed to ~defstackfn~
  + ~:node-tree~ ::
    + A vector of [[*Nodes][nodes]] with ~if>~ nodes containing ~:then~ and ~:else~ subtrees
  + ~:nodes~ ::
    + The node-tree flattened into a vector of nodes.
    + Because this is derived from the node-tree, it contains all of the parse errors (illegal ops, and malformed invoke>).
    + It is used to inject tree errors into the [[Visualization][visualization]]
  + ~:paths~ ::
    + All of the traversable paths through the node-tree as a vector of vectors of nodes
       (the outer vector is the paths, and an inner vector is a single path).
    + Each path begins with a start node and ends with a terminal node.
    + ~if>~ nodes in the tree become ~if-pop~ nodes in the path with a branch key ~:branch~ recording the branch taken (~:then~ or ~:else~)
    + Paths are in then-over-else order, meaning the first path is all ~:then~ branches, the last is all ~:else~ branches. See [[*Sorting Paths][Sorting Paths]]
  + ~:turns~ ::
    + A vector of vectors of strings, turns is one-for-one matched to paths, such that each turn vector has the same index in turns as its path has in paths.
      + as an example, there are two turn vectors in the node-data for the rpl example ops, which has a single ~if>~
	+ ["start" "then" "term"]
	+ ["start" "else" "term"]
      + Used to name the visualization for each path and uniquely identify paths
  + :errors-for-print ::
    + a vector of errors found through parsing (of ~:node-tree~) and static analysis (of ~:paths~)

  -----

* Errors
  At its simplest, an error is a map of keys:
  + ~:err-zone~ :: Where/When the error occurred (e.g. ~:kdh.stax.errs/zone=tree~)
  + ~:err-type~ :: A richly descriptive keyword (e.g. ~:kdh.stax.errs/error=parse-illegal-operation~)
  + ~:err-text~ :: A string describing the error (e.g. ~"<clear> is not an allowed op"~)

  Errors are added to a node with ~:kdh.stax.errs/error+~ which adds an ~:errors~ key if necessary

  #+begin_src clojure :ns user :results output :exports both :eval no-export
  (require '[kdh.stax.node :refer [start-node]]
	   '[kdh.stax.errs :refer [error+] :as err])

  (-> {}
      (error+ {:err-zone ::err/zone=mom
	       :err-type ::err/error=stop-hitting-your-brother
	       :err-text "Hands are for holding, not hitting."})
      (error+ {:err-zone ::err/zone=dad
	       :err-type ::err/error=listen-to-your-mother
	       :err-text "I swear to god, I will pull this car over!"}))

  (=> {:errors [{:err-zone :kdh.stax.errs/zone=mom,
		 :err-type :kdh.stax.errs/error=stop-hitting-your-brother,
		 :err-text "Hands are for holding, not hitting."}
		{:err-zone :kdh.stax.errs/zone=dad,
		 :err-type :kdh.stax.errs/error=listen-to-your-mother,
		 :err-text "I swear to god, I will pull this car over!"}]} )
  #+end_src

** Error Zones

   There are three zones of stax errors, each representing a phase of error analysis
*** Parse Errors
   Some operations are always erroneous.
    + ~!v3+~ is a legal operation
    + ~v3~ is not ever a legal operation, regardless of where it occurs in the tree.
   Such errors have the following facts:
    + They have ~:err-zone~ key with value ~:kdh.stax.errs/zone=tree~
    + They have ~:err-type~ key with value ~:kdh.stax.errs/error=parse-<something>~
    + They are created during the conversion of an operation into an op node in by ~kdh.stax.nodify/nodify-op~ and ~kdh.stax.nodify/nodify-ops~
    + They are present in nodes within the ~:node-tree~, ~:nodes~, and ~:paths~ keys of the node-data

*** Static Path Analysis Errors
    Other errors are only true within a given context of traversal -- within a path:
    + the same op ~!v3~ could be valid or invalid depending on whether ~!v3+~ is present earlier in the path.
    Such errors have the following facts:
    + They have ~:err-zone~ key with value ~:kdh.stax.errs/zone=path~
    + They have ~:err-type~ key with value ~:kdh.stax.errs/error=static-<something>~
    + They are created during the static analysis (iff ~*stax-perform-static-analysis*~ is bound to ~true~, the default) by ~kdh.stax.nodify/check-refs-in-path~ and ~kdh.stax.nodify/count-card-in-path~
    + They are present in nodes within the ~:paths~ key of the node-data

*** Runtime Errors
    Finally, some errors can only occur within the context of evaluation (which is a traversal of the node-tree with values given to ~stackfn~ or ~stackfn-dbg, or the ~defstackfn~ defined functions that call them)
    + ~(invoke>~ + 2) will fail at runtime if either or both of the top two values on the stack are not numbers
    Such errors have the following facts:
    + They have ~:err-zone~ key with value ~:kdh.stax.errs/zone=exec~
    + They have ~:err-type~ key with value ~:kdh.stax.errs/error=runtime-<something>~
    + They are created during the execution of nodes via ~kdh.stax.nodify/exec-nodes~, which stops execution at the first node with errors.
    + They are present in nodes within the ~:results~ key of the node-data

** Error Types
   Error type are richly descriptive, namespaced keywords.
   Richly descriptive means that their names contain multiple parts that allow them easily distinguished out of context.
   On their own, ~:error=runtime-illegal-operation~ and ~:error=parse-illegal-operation~ tell you more than ~:error=illegal-operation~.

   And ~:error=runtime-<something>~ is easily targeted by tooling (e.g. grep emacs/occur) and css matching.
   For example, here is a list of all of the errors found by grep'ing 'error=':

   #+begin_src shell :results output list :exports both :eval no-export
   find ~/clj/rpl/stax/src/clj/kdh/stax/ -type f -name '*.clj' -print0 | xargs -0 grep error= | tr '\011\042/:()' ' ' | tr -s ' ' | tr ' ' '\012' | grep error= | sort | uniq
   #+end_src

   #+RESULTS:
   #+begin_example
   - error=parse-illegal-operation
   - error=parse-invoke-arity-not-pos-int
   - error=parse-invoke-fun-not-function
   - error=parse-invoke-wrong-number-args
   - error=runtime-arity-not-pos-int
   - error=runtime-debug-needs-not-pos-int
   - error=runtime-debug-op-not-sef
   - error=runtime-debug-stack-is-empty
   - error=runtime-debug-stack-is-not-a-vector
   - error=runtime-debug-var-map-is-not-a-map
   - error=runtime-illegal-operation
   - error=runtime-insufficient-stack
   - error=runtime-invoke-failed
   - error=runtime-invoke-fun-not-function
   - error=runtime-invoke-returned-complex-val
   - error=runtime-invoke-wrong-number-args
   - error=runtime-var-not-defined
   - error=static-insufficient-stack
   - error=static-var-not-defined
   #+end_example

   In addition to its use in :err-type, I also use the pattern ~:<type>=<ordered-properties>~ for op-type values:
    + ~:op=if~ (the ~if>~ operation's node)
    + ~:op=if-pop~ (the isolation of the ~if>~ node's pop-like conditional)



*** ~:err-type~ vs ~err-zone~
    Many erroneous conditions that are caught in either parsing or static analysis, also have runtime variants.  This is to allow for full runtime checking even in the presents of parse or static analyis error by binding the ~*stax-errors-prevent-exec*~ to ~false~ or ~nil~.

    #+name: err-zone-table
    #+caption: Table of Node ~:err-type~ ~:err-zone~ interaction
    |         | zone=tree                | zone=path          | zone=exec                   |
    |         | error=parse-…            | error=static-…     | error=runtime-…             |
    | op type |                          |                    |                             |
    |---------+--------------------------+--------------------+-----------------------------|
    | !v      |                          | var-not-defined    | var-not-defined             |
    | !v+     |                          | insufficient-stack | insufficient-stack          |
    | <pop>   |                          | insufficient-stack | insufficient-stack          |
    | if>     |                          | insufficient-stack | insufficient-stack          |
    | invoke> | invoke-wrong-number-args |                    | invoke-wrong-number-args    |
    | invoke> | invoke-fun-not-function  |                    | invoke-fun-not-function     |
    | invoke> | arity-not-pos-int        |                    | arity-not-pos-int           |
    | invoke> |                          | insufficient-stack | insufficient-stack          |
    | invoke> |                          |                    | invoke-failed               |
    | invoke> |                          |                    | invoke-returned-complex-val |
    | NA      | illegal-operation        |                    | illegal-operation           |

*** Debugging Errors
    Some errors should never occur -- their occurence indicates a serious flaw in the logic of the program.
    + ~kdh.stax.errs/error=runtime-debug-needs-not-pos-int~
    + ~kdh.stax.errs/error=runtime-debug-op-not-sef~
    + ~kdh.stax.errs/error=runtime-debug-stack-is-empty~
    + ~kdh.stax.errs/error=runtime-debug-stack-is-not-a-vector~
    + ~kdh.stax.errs/error=runtime-debug-var-map-is-not-a-map~

*** NodeFailure
    The multimethod ~kdh.stax.node/stack-op-exec~ takes a node and dispatches on ~:op-type~.
    To simplify error handling, it uses [[https://github.com/adambard/failjure][failjure]], a monadic library for errors.
    In kdh.stax.errs, I define a ~NodeFailure~ record that implements the ~failjure.core/HasFailed~ protocol.
    #+begin_src clojure
    (defrecord NodeFailure [node err-msg]
      f/HasFailed
      (failed? [self] true)
      (message [self] (:err-msg self)))
    #+end_src

    ~NodeFailure->~ creates a new NodeFailure with the node and an err-msg.
    
    The fail-node-if functions test and maybe fail conditions individually:
    + ~kdh.stax.errs/fail-node-if-var-ref-not-defined~
    + ~kdh.stax.errs/fail-node-if-op-not-sef~
    + ~kdh.stax.errs/fail-node-if-stack-not-vector~
    + ~kdh.stax.errs/fail-node-if-stack-empty~
    + ~kdh.stax.errs/fail-node-if-var-map-not-map~
    + ~kdh.stax.errs/fail-node-if-needs-gt-stack~
    + ~kdh.stax.errs/fail-node-if-invoke-fn-error~
    + ~kdh.stax.errs/fail-node-if-invoke-wrong-number-args~
    + ~kdh.stax.errs/fail-node-if-invoke-arity-error~
    + ~kdh.stax.errs/fail-node-if-invoke-apply-error~
    + ~kdh.stax.errs/fail-node-if-invoke-val-error~
    The fail-node-do functions test and maybe fail on the multiple fail-node-if conditions:
    + ~kdh.stax.errs/fail-node-do-pop~
    + ~kdh.stax.errs/fail-node-do-push-sef~
    + ~kdh.stax.errs/fail-node-do-push-var~
    + ~kdh.stax.errs/fail-node-do-def-var~
    + ~kdh.stax.errs/fail-node-do-invoke~
    The ~kdh.stax.nodify/stack-op-exec~ methods call the fail-node-do functions and (on failure) return the ~NodeFailure~'s node without keys ~:stack~ ~:var-map~ and ~:cardi~ so that nodes with errors do not propagate exec state.

* Dynamic Variables

+ ~*stax-node-star-mode*~ ::
  + default is false
  + If true, defstackfn generate the node-data closure from ~kdh.stax.nodify/build-node-data*~
  + experimental use only - build-node-data outperforms build-node-data*
+ ~*stax-require-simple-stack-values*~ ::
  + default is true
  + if true, checks arguments to defstackfn fn, and invoke return are simple -- i.e. self evaluating forms
+ ~*stax-throw-on-error*~ ::
  + default is false
  + if true, throw on error; if false, return error as a keyword
+ ~*stax-defstackfn-fails-on-errors*~ ::
  + default is true
  + if false, continue to the execution phase even though there are parse errors and/or static analysis errors
  + used for testing runtime equivalents of parse/static errors (see [[err-zone-table]])
+ ~*stax-perform-path-analysis*~ ::
  + default is true
  + if true, defstackfn performs static path analysis
+ ~*stax-default-dot-options*~ ::
  + default
  + graph, node, and edge properties for dot generation

#+name: def dynamic list
#+begin_src shell :results output list :exports both :eval no-export
 find ~/clj/rpl/stax/src/clj/kdh/ -type f -name '*.clj' -print0 | xargs -0 grep "\^:dynamic" | sed 's%[^\*]\*[^\*]+\*cut -f2-3 -d\*
#+end_src

#+RESULTS: def dynamic list
#+begin_example
- stax-require-simple-stack-values*
- stax-throw-on-error*
- stax-perform-path-analysis*
- stax-errors-prevent-exec*
- node-star-mode* false)
- default-dot-options*
- unescape-at-dot* true)
#+end_example

/home/keith/clj/rpl/stax/dev/clj/dev.clj:         (binding [*stack-variables-are-dynamic-scoped* true]
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic *stax-require-simple-stack-values*
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic *stax-throw-on-error*
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic *stax-perform-path-analysis*
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic *stax-errors-prevent-exec*
/home/keith/clj/rpl/stax/src/clj/kdh/stax/nodes.clj:(def ^:dynamic *node-star-mode* false)
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:(def ^:dynamic *default-dot-options*
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:  "A dynamic var of default global dot options"
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:(def ^:dynamic *unescape-at-dot* true)

* Visualization
The node-data map returned by ~kdh.stax.nodify/build-node-data~ is large, and dificult to debug.
#+ATTR_HTML: :target _blank
[[https://github.com/djblue/portal][Portal]] helped in diving into the data somewhat, but ever since I started working on this project, I wanted to display a graph of the op nodes in the ~:node-tree~ key of the node-data and I also wanted to visually represent overlays of ~:paths~ and ~:results~ data onto the node-tree. I've found that nothing beats a good visualization of data for the end user and the developer.
** Using Tangle to Generate dot
#+ATTR_HTML: :target _blank
I looked into a few graphing libraries, but most seemed overly complex for the problem at hand: draw a simple tree of nodes and decorate them using the node-data.  I previously used graphviz to draw diagrams manually in dot format using emacs org-mode and babel dot code blocks. So I went back to look for clojure libraries that handle graphviz dot, and found a few, but settled on [[https://github.com/Macroz/tangle][tangle]].

 ~tangle.core/graph->dot~ takes 3 args:
 1. nodes :: a collection of ids or maps with :id key
 2. edges :: a collection of vector of from-node id and and to-node ids with optional map of edge options
 3. an optional map for dot graph, node, and edge defaults, plus some conversion functions.

 As noted before, this website is written in org-mode, so I can show the tangle testing I did here:

 #+begin_src clojure :ns user :results output :exports both :eval no-export
 (-> (tangle.core/graph->dot ["a" "b" "c"]              ; nodes
			     [["a" "b"] ["a" "c"]]      ; edges
			     {:graph {:rankdir :LR}})   ; options
     print)
#+end_src

#+RESULTS:
#+begin_example
graph {

graph[dpi=100, rankdir=LR]
"a"
"b"
"c"

"a" -- "b"
"a" -- "c"
}
#+end_example

OK, looks like dot syntax.  Now lets convert it to SVG:

#+begin_src clojure :ns user :results output file :file tangle1.svg :exports both :eval no-export
(-> (tangle.core/graph->dot ["a" "b" "c"]              ; nodes
                            [["a" "b"] ["a" "c"]]      ; edges
                            {:graph {:rankdir :LR}})   ; options
    tangle.core/dot->svg
    print)
#+end_src

#+RESULTS:
[[file:tangle1.svg]]

Now a slightly more sophisticated tree like I want if> to become:

#+begin_src clojure :ns user :results output file :file tangle2.svg :exports both :eval no-export
(-> (tangle.core/graph->dot [{:id "a" :label "if&gt;" :shape :diamond}    ; nodes
                             {:id "b" :label "!b"}
                             {:id "c" :label "!c"}]
                            [["a" "b" {:label "then"}]                    ; edges
                             ["a" "c" {:label "else"}]]
                            {:graph {:rankdir :LR}                        ; options
                             :node {:shape :box}
                             :node->id (fn [n] (if (keyword? n) (name n) (:id n)))   ; conversion functions
                             :node->descriptor (fn [n] (when-not (keyword? n) n))})
    tangle.core/dot->svg
    print)
#+end_src

#+RESULTS:
[[file:tangle2.svg]]

** Turning Stax Node Data into dot and SVG
~kdh.stax.svg/paths-to-dot~ takes node-data ~:paths~ and
+ generates deduplicated, labeled, and indexed nodes and edges
+ sort the edges so graphviz generates then above else
+ and calls tangle.core/graph->dot to generate the dot

#+begin_src clojure :ns user :results output file :file tangle3.svg :exports both :eval no-export
(-> (build-node-data '[!a !b !c] '((if> !a else> !b)))
    :paths
    paths-to-dot
    (str/replace "\\" "")   ; necessary to unescape the brackets and colon in id which is a :node-index
    tangle.core/dot->svg
    print)
#+end_src

#+RESULTS:
[[file:tangle3.svg]]

In code, I use ~tangle.core/dot->svg~ and ~clojure.data.xml/parse-str~ to get the svg as edn for later maniplulation.

~kdh.stax.svg/add-svg-data~ converts node-data ~:paths~ into dot node ids (strings of ~:node-index~, which is unique) and edges (vector pairs of dot node ids) sometimes with labels (start, then, and else) from node ~:branch~ values.  SVG is an xml vocabulary, which ~clojure.data.xml/parse-string~ turns into edn that can be manipulated with specter.  I like this multi-step process:  edn->dot then dot->svg then svg->edn because the intermediate dot and svg allow me to quickly play with dot and svg in org-mode.

** Debugging Stax Execution in SVG

The node-data created by ~kdh.stax.nodify/build-node-data~ can be passed into ~kdh.stax.core/stackfn-dbg~ to add the execution values. ~kdh.stax.svg/node-data-to-html-file~ calls the decorator functions in ~kdh.stax.svg~ to complete the visualization and outputs an html file.

#+begin_src clojure :ns user :exports code :eval no-export
(str
 (node-data-to-html-file (io/file "org" "svg" "rpl-example-tree-path-exec.html")
                         (-> (build-node-data '[!a !b !c] ex/ops-rpl-example)
                             (stackfn-dbg 1 2 4
                                           3 3 3))))
#+end_src

#+RESULTS:
#+begin_example
file:/mnt/e/Sync/clojure/rpl/stax/org/svg/rpl-example-tree-path-exec.html
#+end_example

*** A Walkthrough of Good Data Visualization
Click on the link below to open the visualization that exercises the paths in the assignment example in another tab
#+ATTR_HTML: :target _blank
[[file:svg/rpl-example-tree-path-exec.html][rpl-example-tree-path-exec.html]]

Looking at the html visualization, you should see three sections differentiated by color:
  + Gray/Black :: Shows the parsed ~:node-tree~ of the node-data
    + If you hover over nodes, you should see a popup with "node=[<node-index>]"
      + this bracketed value is the ~:node-index~ for the node
	+ an alternating vector of numbers (index in the straight section) and keywords (~:then~ or ~:else~) for branches.
    + Note that all the nodes are Gray (no parse errors) and the edges are black (always the case in the parse tree).
  + Blue :: Shows the ~:paths~ overlay of the ~:node-tree~
    + This is the static analysis section
    + Note the turns vector [start→then→term] after the name "graph0-path1"
    + If you hover over nodes, you should see a popup with "node=[<node-index>]" and a new value "size=<n>"
      + this the cardinality of the stack as determined by the ~:delta~ value of the nodes prior on the path
    + Note that the path (the edges and the perimeter of the polygons) is colored blue from start node to terminal node
      + That indicates no cardinality or ref before def errors
    + Note that the nodes in the path are filled with blue
      + That indicates there are no nodes with errors in either path
  + Green :: Shows the ~:results~ overlay of the ~:node-tree~
    + This is the execution section
    + If you hover over nodes, you should see the popup no longer has "size=n"
    + Instead, you see "var-map={<!var> <val>}" which is the state of the variables after the node executes
    + Also in the popup is the "stack=[<values>]" which is the state of the stack after the node executes
    + Note that the path (the edges and the perimeter of the polygons) is colored green from start node to terminal node
      + That indicates no runtime errors in that path
    + Note that the nodes in the path are filled with blue
      + That indicates there are no nodes with runtime errors
    + Each result also has a section below it with
      + Variables Table (Init and Last state)
      + the final Stack value(s)
      + and the Output text box (if present)

*** A Walkthrough of Bad Data Visualization
Boy, that RPL example visualization sure was pretty....But it lacked the a vibrancy that can only come from....ERRORS!!!

#+begin_src clojure :ns user :exports code :eval no-export
(str
 (node-data-to-html-file
  (io/file "org" "svg" "kdh-bad-example-tree-path-noexec.html")
  (-> (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)
      (stackfn-dbg 1 2 4
                    3 3 3))))
#+end_src

#+RESULTS:
#+begin_example
file:/mnt/e/Sync/clojure/rpl/stax/org/svg/kdh-bad-example-tree-path-noexec.html
#+end_example

Click on the link below to open the visualization that exercises some bad nodes and paths in another tab
#+ATTR_HTML: :target _blank
[[file:svg/kdh-bad-example-tree-path-noexec.html][kdh-bad-example-tree-path-noexec.html]]

Looking at the html visualization, you should now see two sections differentiated by color:
  + Gray/Black :: Shows the parsed ~:node-tree~ of the node-data
    + But now some of the nodes are OrangeRed. Hover over them to see what's wrong...
      #+begin_example
      node=[8 :then 0]

      TREE ERRORS:
      a is not an allowed op
      #+end_example
      #+begin_example
      node=[8 :else 0]

      TREE ERRORS:
      b is not an allowed op
      #+end_example
      + the css for this is
	#+begin_src css
	svg>g.graph>g.node>polygon[data-stax-err-type~="error=parse-illegal-operation"] {
	    fill: orangered;
	}
	#+end_src
    + Another node is Orange. Hovering over it reveals...two errors in one node - ouch!
      #+begin_example
      node=[5 :then 0]

      TREE ERRORS:
      printl is not a known function!
      0 is not a valid arity (must be pos-int)!
      #+end_example
      + the css for this is
	#+begin_src css
	svg>g.graph>g.node>polygon[data-stax-err-type^="error=parse-invoke"] {
	    fill: orange;
	}
	#+end_src
  + Blue :: Shows the ~:paths~ overlay of the ~:node-tree~
    + Note the parse errors are still showing -- parse errors are always shown in both zone=tree and zone=path
    + Note also that paths (edges and polygon lines) turn DeepPink at an error and beyond.
    + But we see more errors in the paths...but sometime not, depending on the path
      + Path1 [start→then→then→term] has two instances of
	#+begin_example
	PATH ERRORS:
	!v2 is a reference before definition
        #+end_example
	+ Because ~!v2+~ is not present in the path prior to either node, the css catches the ~data-stax-err-type~ with "error=static-var-not-defined"
	  #+begin_src css
	  svg>g.graph>g.node>polygon[data-stax-err-type~="error=static-var-not-defined"] {
	      fill: orchid;
	  }
          #+end_src
      + Path2 [start→then→else→term] has two instances of "!v2 is a reference before definition", but later on is a diferrent node.
	#+begin_example
	PATH ERRORS:
	!v2 is a reference before definition
        #+end_example
      + "error=static-var-not-defined" will show for every ref-before-def in a given path
      + Path3+4 both have the same bad node filled by CSS which was in Path1+2, but not filled there
	#+begin_example
	node=[7]

	PATH ERRORS:
	stack size=1, operation (invoke> = 2) needs >=2
	#+end_example
	#+begin_src css
	svg>g.graph>g.node>polygon[data-stax-err-type~="error=static-insufficient-stack"] {
	    fill: magenta;
	}
        #+end_src
	+ That is because cardinality can not be calculated through bad paths -- Errors invalidate the count
-----
*** A Run Through Bad Data Visualization
That last example had no Results trees, even though we supplied values. That's because the default behavior of ~stackfn~ and ~stackfn-dbg~ is to not execute with parse or static errors present in the tree (technically, in the flattened tree of the node-data ~:nodes~ and the ~:paths~).

We can allow result by binding a dynamic variable:
#+begin_src clojure :ns user :exports code :eval no-export
(binding [*stax-errors-prevent-exec* false]
  (str
   (node-data-to-html-file
    (io/file "org" "svg" "kdh-bad-example-tree-path-exec.html")
    (-> (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)
        (stackfn-dbg 1 2 3
                      3 2 1
                      1 3 2
                      2 3 1
                      4 2 1
                      1 4 2
                      2 1 4
                      1 2 4)))))
#+end_src

#+RESULTS:
#+begin_example
file:/mnt/e/Sync/clojure/rpl/stax/org/svg/kdh-bad-example-tree-path-exec.html
#+end_example

Click on the link below to open the visualization that exercises some bad nodes and paths in another tab
#+ATTR_HTML: :target _blank
[[file:svg/kdh-bad-example-tree-path-exec.html][kdh-bad-example-tree-path-exec.html]]


If you hover over nodes, you should see a popup with "node=[<node-index>]" and a new value "size=<n>"
      + this the cardinality of the stack as determined by the ~:delta~ value of the nodes prior on the path
    + Note that the path (the edges and the perimeter of the polygons) is colored blue from start node to terminal node
      + That indicates no cardinality or ref before def errors
    + Note that the nodes in the path are filled with blue
      + That indicates there are no nodes with errors in either path

* Optimization Case Studies

  Throughout the development of ~kdh/stax~, I optimized several sections of code.  While an exhaustive review is not feasible, I would like to show a few optimizations I made to give a sense of the work I did.

** Sorting Paths

   I want ~build-node-data~ and ~build-node-data*~ to produce the same node-data (specifically ~:node-tree~, and ~:paths~, as the others are derived from these).
   Since paths is a vector of vectors, order matters. Because of their underlying implementations, ~build-node-data~ and ~build-node-data*~ produce paths in different order.
   I wrote ~mapify-paths~ to make paths into a deep associative structure in order to compare them with ~clojure.core/diff~.
   
   But I want my tree visualization to flow left to right and with ~then~ ranked above ~else~.
   I want the enumerated paths in the visualization to display the top most path (all ~then~) to bottom most (all ~else~).
   To accomplish this, I sort the paths reverse alphabetically by their turns (simplified here to sorting their turns).

   #+begin_src clj :exports code :eval no-export
  (let [turns ["else" "then"]
        else-over-then (vec (for [t1 turns t2 turns t3 turns] ["start" t1 t2 t3 "term"]))
        then-over-else (vec (sort-by str (comp - compare) else-over-then))]
       {:else-over-then  else-over-then
        :then-over-else  then-over-else})
  (=>
   {:else-over-then [["start" "else" "else" "else" "term"]
                     ["start" "else" "else" "then" "term"]
                     ["start" "else" "then" "else" "term"]
                     ["start" "else" "then" "then" "term"]
                     ["start" "then" "else" "else" "term"]
                     ["start" "then" "else" "then" "term"]
                     ["start" "then" "then" "else" "term"]
                     ["start" "then" "then" "then" "term"]],
    :then-over-else [["start" "then" "then" "then" "term"]
                     ["start" "then" "then" "else" "term"]
                     ["start" "then" "else" "then" "term"]
                     ["start" "then" "else" "else" "term"]
                     ["start" "else" "then" "then" "term"]
                     ["start" "else" "then" "else" "term"]
                     ["start" "else" "else" "then" "term"]
                     ["start" "else" "else" "else" "term"]]}
   )
   #+end_src

   This works perfectly only because the paths have the same length.  If they don't (often the case), sort favors length over content.
  
   #+begin_src clj :exports code :eval no-export
  (let [ops ex/ops-kdh-bad-example
        paths (mapv path-to-turns (-> ops nodify-ops* :paths))
        else-over-then (vec (sort-by identity paths))
        then-over-else (vec (sort-by identity (comp - compare) else-over-then))]
       {:else-over-then  else-over-then
        :then-over-else  then-over-else})

  (=>
   {:else-over-then [["start" "then" "else" "term"]
                     ["start" "then" "then" "term"]
                     ["start" "else" "else" "else" "term"]
                     ["start" "else" "else" "then" "term"]
                     ["start" "else" "then" "else" "term"]
                     ["start" "else" "then" "then" "term"]],
    :then-over-else [["start" "else" "then" "then" "term"]
                     ["start" "else" "then" "else" "term"]
                     ["start" "else" "else" "then" "term"]
                     ["start" "else" "else" "else" "term"]
                     ["start" "then" "then" "term"]
                     ["start" "then" "else" "term"]]}
   )
   #+end_src

   Years ago, I needed to sort vectors like this - i.e. sort sequences (regardless of length) by comparing each sequential item.
   After realizing that the different length of the data was confounding my sort, I hit upon a genius idea (always a bad sign, right?)

   What if I could make the length of all of the sequences equal?

   So I wrote a function ~seq-to-deep~ that turns a sequence into a two length vector containing item one in the first slot,
   and another two length vector whose first was item two in the second slot...
   
   #+begin_src clj :exports code :eval no-export
   (defn seq-to-deep [v]
     (->> v reverse
	  (map vector)
	  (reduce (fn [l r] (into r [l])) [])))

   (=> #'user/seq-to-deep )

   (seq-to-deep ["start" "else" "then" "else" "else" "else" "else" "term"])

   (=> ["start" ["else" ["then" ["else" ["else" ["else" ["else" ["term" []]]]]]]]] )
   #+end_src

   This basically reduces a list or vector of any length into a vector of two-tuples,
   where the first is a value and the second is, recursively, another two tuple
   (similar to a linked list as a one legged cons tree in lisps of old - with [] standing in for nil to end the cons cell chain)

   #+begin_src clj :exports code :eval no-export
   (let [ops ex/ops-kdh-bad-example
	 paths (mapv path-to-turns (-> ops nodify-ops* :paths))
	 else-over-then (vec (sort-by seq-to-deep paths))
	 then-over-else (vec (sort-by seq-to-deep (comp - compare) else-over-then))]
     {:else-over-then  else-over-then
      :then-over-else  then-over-else})

   (=>
    {:else-over-then [["start" "else" "else" "else" "term"]
		      ["start" "else" "else" "then" "term"]
		      ["start" "else" "then" "else" "term"]
		      ["start" "else" "then" "then" "term"]
		      ["start" "then" "else" "term"]
		      ["start" "then" "then" "term"]],
     :then-over-else [["start" "then" "then" "term"]
		      ["start" "then" "else" "term"]
		      ["start" "else" "then" "then" "term"]
		      ["start" "else" "then" "else" "term"]
		      ["start" "else" "else" "then" "term"]
		      ["start" "else" "else" "else" "term"]]}
    )
   #+end_src

   It's ugly, and not very space efficient -- look at all those vectors!
   But, it worked in a pinch!!  And remained one of my favorite ad-hoc odd-hacks!!!
   Top of my utils for many years.

   I pulled it out to use for stax, but having learned more in the intervening decade,
   I decided that what I really want is a compare fn for ~sort-by~'s compare arg,
   not another function to comp onto ~sort-by~'s keyfn arg.

   The function sequential-compare1 compares each succesive term in two paths
   returning the comparison at the first difference

   #+begin_src clj -n :exports code :eval no-export
   (defn sequential-compare1 [path-1 path-2]
     (if (= path-1 path-2) 0
	 (loop [[nth-1 & more-1] path-1
		[nth-2 & more-2] path-2]
	   (let [comparison (compare nth-1 nth-2)]
	     (if-not (zero? comparison)
	       comparison
	       (if (nil? more-1)
		 -1
		 (if (nil? more-2)
		   +1
		   (recur more-1 more-2))))))))

   (=> #'user/sequential-compare1 )
   #+end_src

   #+RESULTS:
   | class clojure.lang.Compiler$CompilerException |
   | class clojure.lang.Compiler$CompilerException |

   We can take advantage of the following facts to simplify sequential-compare1:
   1. binding form [item & more-items] when bound to the last item
      (i.e. no more-items) makes more-item nil like next, not '() like rest
   2. nil < item, if item is not nil, so the shorter path that is identical
      to the longer, up until its end, sorts <
   3. in the loop, there will never be two paths that are equal in size
      and equal in each item, because they would be equal in the first if and return 0

  
   #+begin_src clj :exports code :eval no-export
   (defn sequential-compare2 [path-1 path-2]
     (if (= path-1 path-2) 0
	 (loop [[nth-1 & more-1] path-1
		[nth-2 & more-2] path-2]
	   (let [comparison (compare nth-1 nth-2)]
	     (if (zero? comparison)
	       (recur more-1 more-2)
	       comparison)))))

   (=> #'user/sequential-compare2 )
   #+end_src

   Now we can compare the three alternatives (seq-to-deep, sequential-compare1, sequential-compare2)
   for equality and execution speed in best (already sorted) and worst cases (reverse of sort)

   #+begin_src clj :exports code :eval no-export
   (let [ops ex/ops-kdh-bad-example
	 paths (-> ops nodify-ops* :paths)
	 turns (mapv path-to-turns paths)
	 else-over-then-with-seq-to-deep (sort-by seq-to-deep turns)
	 then-over-else-with-seq-to-deep (sort-by seq-to-deep (comp - compare) turns)
	 else-over-then-with-sequential-compare1 (vec (sort-by identity sequential-compare1 turns))
	 then-over-else-with-sequential-compare1 (vec (sort-by identity (comp - sequential-compare1) turns))
	 else-over-then-with-sequential-compare2 (vec (sort-by identity sequential-compare2 turns))
	 then-over-else-with-sequential-compare2 (vec (sort-by identity (comp - sequential-compare2) turns))
	 they-are-equal (and (= else-over-then-with-seq-to-deep
				else-over-then-with-sequential-compare1
				else-over-then-with-sequential-compare2)
			     (= then-over-else-with-seq-to-deep
				then-over-else-with-sequential-compare1
				then-over-else-with-sequential-compare2))]
     (when they-are-equal
       (let [then-over-else then-over-else-with-seq-to-deep
	     else-over-then else-over-then-with-seq-to-deep]
	 (qb (sort-by seq-to-deep (comp - compare) then-over-else))
	 (qb (sort-by seq-to-deep (comp - compare) else-over-then))
	 (qb (sort-by seq-to-deep compare then-over-else))
	 (qb (sort-by seq-to-deep compare else-over-then))
	 (qb (sort-by identity (comp - sequential-compare1) then-over-else))
	 (qb (sort-by identity (comp - sequential-compare1) else-over-then))
	 (qb (sort-by identity sequential-compare1 then-over-else))
	 (qb (sort-by identity sequential-compare1 else-over-then))
	 (qb (sort-by identity (comp - sequential-compare2) then-over-else))
	 (qb (sort-by identity (comp - sequential-compare2) else-over-then))
	 (qb (sort-by identity sequential-compare2 then-over-else))
	 (qb (sort-by identity sequential-compare2 else-over-then))
	 they-are-equal)))

   (=> true )
   #+end_src

   #+caption: ~seq-to-deep~ vs ~sequential-compare1~ vs ~sequential-compare2~
   | Evaluation                                                     | Execution time mean |
   |----------------------------------------------------------------+---------------------|
   | (sort-by seq-to-deep (comp - compare) then-over-else)          | 29.105317 µs        |
   | (sort-by seq-to-deep (comp - compare) else-over-then)          | 28.966610 µs        |
   | (sort-by seq-to-deep compare then-over-else)                   | 31.041590 µs        |
   | (sort-by seq-to-deep compare else-over-then)                   | 29.071545 µs        |
   |----------------------------------------------------------------+---------------------|
   |                                                                | 29.546266 μs        |
   |----------------------------------------------------------------+---------------------|
   | (sort-by identity (comp - sequential-compare1) then-over-else) | 2.491231 µs         |
   | (sort-by identity (comp - sequential-compare1) else-over-then) | 2.517452 µs         |
   | (sort-by identity sequential-compare1 then-over-else)          | 2.337029 µs         |
   | (sort-by identity sequential-compare1 else-over-then)          | 2.383909 µs         |
   |----------------------------------------------------------------+---------------------|
   |                                                                | 2.4324053 μs        |
   |----------------------------------------------------------------+---------------------|
   | (sort-by identity (comp - sequential-compare2) then-over-else) | 2.517697 µs         |
   | (sort-by identity (comp - sequential-compare2) else-over-then) | 2.479772 µs         |
   | (sort-by identity sequential-compare2 then-over-else)          | 2.343008 µs         |
   | (sort-by identity sequential-compare2 else-over-then)          | 2.313736 µs         |
   |----------------------------------------------------------------+---------------------|
   |                                                                | 2.4135533 μs        |
   |----------------------------------------------------------------+---------------------|
   #+TBLFM: @6$2=vmean(@2..@5)::@11$2=vmean(@7..@10)::@16$2=vmean(@12..@15)

   As hoped, both sequential-compare1 and sequential-compare2 outperform seq-to-deep (by an order of magnitude)
   sequential-compare2 outperforms sequential-compare1 by about 0.8%
  
   Let's see how the two sequential-compare functions do with a bigger tree
  
   #+begin_src clj :exports code :eval no-export
   (let [ops ex/ops-kdh-worse-example
	 paths (-> ops nodify-ops* :paths)
	 number-of-paths (count paths)
	 longest-path (apply max (map count paths))]
     {:number-of-paths number-of-paths
      :longest-path longest-path})

   (=> {:number-of-paths 86, :longest-path 68} )


   (let [ops ex/ops-kdh-worse-example
	 paths (-> ops nodify-ops* :paths)
	 turns (mapv path-to-turns paths)
	 else-over-then-with-sequential-compare1 (sort-by identity sequential-compare1 turns)
	 then-over-else-with-sequential-compare1 (sort-by identity (comp - sequential-compare1) turns)
	 else-over-then-with-sequential-compare2 (sort-by identity sequential-compare2 turns)
	 then-over-else-with-sequential-compare2 (sort-by identity (comp - sequential-compare2) turns)
	 they-are-equal (and (= else-over-then-with-sequential-compare1
				else-over-then-with-sequential-compare2)
			     (= then-over-else-with-sequential-compare1
				then-over-else-with-sequential-compare2))]
     (when they-are-equal
       (let [then-over-else then-over-else-with-sequential-compare1
	     else-over-then else-over-then-with-sequential-compare1]
	 (qb (sort-by identity (comp - sequential-compare1) then-over-else))
	 (qb (sort-by identity (comp - sequential-compare1) else-over-then))
	 (qb (sort-by identity sequential-compare1 then-over-else))
	 (qb (sort-by identity sequential-compare1 else-over-then))
	 (qb (sort-by identity (comp - sequential-compare2) then-over-else))
	 (qb (sort-by identity (comp - sequential-compare2) else-over-then))
	 (qb (sort-by identity sequential-compare2 then-over-else))
	 (qb (sort-by identity sequential-compare2 else-over-then))
	 they-are-equal)))

   (=> true )
   #+end_src

   #+caption: ~sequential-compare1~ vs ~sequential-compare2~ final round
   | Evaluation                                                     | Execution time mean |
   |----------------------------------------------------------------+---------------------|
   | (sort-by identity (comp - sequential-compare1) then-over-else) | 52.638949 µs        |
   | (sort-by identity (comp - sequential-compare1) else-over-then) | 50.717881 µs        |
   | (sort-by identity sequential-compare1 then-over-else)          | 49.913771 µs        |
   | (sort-by identity sequential-compare1 else-over-then)          | 49.833063 µs        |
   |----------------------------------------------------------------+---------------------|
   |                                                                | 50.775916 μs        |
   |----------------------------------------------------------------+---------------------|
   | (sort-by identity (comp - sequential-compare2) then-over-else) | 50.668951 µs        |
   | (sort-by identity (comp - sequential-compare2) else-over-then) | 49.301679 µs        |
   | (sort-by identity sequential-compare2 then-over-else)          | 48.979257 µs        |
   | (sort-by identity sequential-compare2 else-over-then)          | 49.346938 µs        |
   |----------------------------------------------------------------+---------------------|
   |                                                                | 49.574206 μs        |
   |----------------------------------------------------------------+---------------------|
   #+TBLFM: @6$2=vmean(@2..@5)::@11$2=vmean(@7..@10)

   ~sequential-compare2~ does even better against ~sequential-compare1~ by about 2.2%

   So ~kdh.stax.util/sequential-compare~ is now ~sequential-compare2~, and ~seq-to-deep~ can be retired!
  
** ~nodify-ops~ vs ~nodify-ops*~

   ¿EXPLAIN?
      
  #+begin_src clj :exports code :eval no-export
  ;; nodify-ops* returns a map with :node-tree and :paths
  ;; nodify-ops only returns a node-tree - so we need to call node-tree-to-node-paths with *stax-perform-path-analysis* false to make these equivalent

  (binding [*stax-perform-path-analysis* false]
    (let [ops ex/ops-kdh-bad-example
	  decls '[!a !b !c]
	  nodified (let [node-tree (nodify-ops ops)
			 paths (node-tree-to-node-paths decls node-tree)]
		     {:node-tree node-tree
		      :paths paths})
	  ;; nodify-ops* returns a map with extra keys [:raw-paths has :sticky sub-paths]
	  nodified* (select-keys (nodify-ops* ops) [:node-tree :paths])
	  they-are-equal (=  nodified nodified*)]
      (if they-are-equal
	(do
	  (qb (node-tree-to-node-paths decls (nodify-ops ops)))
	  (qb (:paths (nodify-ops* ops)))
	  they-are-equal)
	(take 2 (clojure.data/diff (update nodified :paths mapify-paths)
				   (update nodified* :paths mapify-paths))))))

  ;;+>
  ;; ================================================================================
  ;; (node-tree-to-node-paths decls (nodify-ops ops))
  ;; --------------------------------------------------------------------------------
  ;; Evaluation count : 4590 in 6 samples of 765 calls.
  ;;              Execution time mean : 137.892144 µs
  ;;     Execution time std-deviation : 5.518452 µs
  ;;    Execution time lower quantile : 132.664061 µs ( 2.5%)
  ;;    Execution time upper quantile : 144.552999 µs (97.5%)
  ;;                    Overhead used : 7.966002 ns
  ;; ________________________________________________________________________________
  ;;
  ;;
  ;; ================================================================================
  ;; (:paths (nodify-ops* ops))
  ;; --------------------------------------------------------------------------------
  ;; Evaluation count : 2826 in 6 samples of 471 calls.
  ;;              Execution time mean : 213.668540 µs
  ;;     Execution time std-deviation : 4.777139 µs
  ;;    Execution time lower quantile : 208.771866 µs ( 2.5%)
  ;;    Execution time upper quantile : 220.715470 µs (97.5%)
  ;;                    Overhead used : 7.966002 ns
  ;; ________________________________________________________________________________
  #+end_src

   
** KeyFnMap for Decorating SVG Nodes with Op Node Errors
   For the visualization of ~:node-tree~, ~:paths~, and ~:results~, I use SVG in HTML.  While I toyed with directly manipulating the look of SVG (changing the ~:fill~ color of a ~g.node~'s ~:polygon~, or the ~:stroke~ color of a ~g.edge~'s ~:path~ with specter), as soon as I became aware of SVG user data attributes, I focused on marking the SVG with custon attributes that I could then target from CSS.
   SVG allows custom attributes named :data-<your-name-here>. These are legal SVG, and are useful for adding data to your SVG elements. However, the user data attributes are just that, attributes.  Attributes are simple -- i.e cannot contain child values, like elements can.  To convert vectors of error maps into data attributes, I would need to write conversion functions.

   I add two custom attributes for node error the visualization
   + ~:data-stax-err-type~ ::
     + To be used by css to style an svg node based on the ~:err-type~ values in its corresponding op node's ~:errors~
     + This is a string of space delimited names of keywords assigned as the values of the ~:err-type~ key in the error maps within the vector ~:errors~.
   #+begin_example
     [{:err-type <keyword-1>}
      {:err-type <keyword-2>}
      ...
      {:err-type <keyword-n}]  ==> "<name-1> <name-2> ... <name-n>"
   #+end_example

   + ~:data-stax-err-text~ ::
     + To be used by css to style an svg node based on the ~:err-text~ values in its corresponding op node's ~:errors~
     + Its form is a string of newline delimited values derived from ~:err-text~ values
     + It is displayed in the label text that pops up when hovering over the node in the visualization
   #+begin_example
     [{:err-text <string-1>}
      {:err-text <string-2>}
      ...
      {:err-text <string-n}]   ==> "<string-1>\n<string-2>\n...\n<string-n>"
   #+end_example

   To simplified this, I came up with KeyFnMap, a map of match keys to conversion functions.
   
*** First Version

    In v1 of the keyfnmap
    + keys match those in the error maps (:err-type and :err-text)
    + values are functions to convert :errors into the corresponding values for the :data-stax-err-type and :data-stax-err-text values

    Given a sequence of op nodes, ~make-node-id-to-data-stax-err-map-v1~ calls ~index-property-of-nodes~ to create a map of node-index string (which is the id of the svg nodes we will decorate) to errors from the node specified by the node-index. This is passed to ~map-vals-via-keyfnmap-v1~ along with the keyfnmap to return a map of maps from node-index string to a map of svg data keyed converted values.

    Below, we sit it works, but ~map-vals-via-keyfnmap-v1~ has the key fixing call to ~key-to-data-stax-key~ locked within it.
   
   #+begin_src clojure :ns user :results output :exports both :eval no-export
   (def err-to-data-stax-err-kfm-v1
     {:err-type (fn [som]
		  (apply str
			 (sequence (comp (map :err-type)
					 (map name)
					 (interpose " "))
				   som)))
      :err-text (fn [som]
		  (apply str
			 (sequence (comp (map :err-text)
					 (interpose "\n"))
				   som)))})


   (defn map-vals-via-keyfnmap-v1
     [keyfnmap target-map]
     (map-vals (fn [errors]
		 (into {} (map (fn [[k val-fn]]
				 [(key-to-data-stax-key k) (val-fn errors)]))
		       keyfnmap))
	       target-map))


   (defn make-node-id-to-data-stax-err-map-v1
     ([nodes]
      (->> nodes
	   (index-property-of-nodes (comp str :node-index) :errors)
	   (map-vals-via-keyfnmap-v1 err-to-data-stax-err-kfm-v1)))
     ([nodes err-key err-val-set]
      (->> nodes
	   (index-property-of-nodes (comp str :node-index) :errors)
	   (map-vals (partial filter #(-> % err-key err-val-set)))
	   (remove-vals empty?)
	   (map-vals-via-keyfnmap-v1 err-to-data-stax-err-kfm-v1))))


   (->> (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)
	:nodes
	make-node-id-to-data-stax-err-map-v1)

   (=>
    {"[5 :then 0]" {:data-stax-err-type "error=parse-invoke-bad-function error=parse-invoke-bad-arity",
		    :data-stax-err-text "printl is not a known function!\n0 is not a valid arity (must be pos-int)!"},
     "[8 :then 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "a is not an allowed op"},
     "[8 :else 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "b is not an allowed op"}}
    )
   #+end_src
   
*** Second Version

    In v2 of the keyfnmap
    + keys match those in the error maps (:err-type and :err-text)
    + values are maps of keys
      + ~:key-fn~ :: a function to convert the key into its ~:data-stax-~ form
      + ~:val-fn~ :: a function to convert the values of the sequence of errors by key into a compound string of the key's values

    Now we've moved the call to ~key-to-data-stax-key~ out of ~map-vals-via-keyfnmap-v2~ and into the keyfnmap.
   
   #+begin_src clojure :ns user :results output :exports both :eval no-export
   (require '[medley.core :refer [map-vals map-kv]])

   (def err-to-data-stax-err-kfm-v2
     {:err-type {:key-fn key-to-data-stax-key
		 :val-fn (fn [som]
			   (apply str
				  (sequence (comp (map :err-type)
						  (map name)
						  (interpose " "))
					    som)))}
      :err-text {:key-fn key-to-data-stax-key
		 :val-fn (fn [som]
			   (apply str
				  (sequence (comp (map :err-text)
						  (interpose "\n"))
					    som)))}})

   (defn map-vals-via-keyfnmap-v2
     [keyfnmap target-map]
     (map-vals (fn [v]
		 (map-kv (fn [k {:keys [key-fn val-fn]}]
			   [(key-fn k) (val-fn v)])
			 keyfnmap))
	       target-map))


   (defn make-node-id-to-data-stax-err-map-v2
     ([nodes]
      (->> (nodes-to-indexed-property nodes (comp str :node-index) :errors)
	   (map-vals-via-keyfnmap-v2 err-to-data-stax-err-kfm-v2)))
     ([nodes err-key err-val-set]
      (->> (nodes-to-indexed-property nodes (comp str :node-index) :errors)
	   (map-vals (partial filter #(-> % err-key err-val-set)))
	   (remove-vals empty?)
	   (map-vals-via-keyfnmap-v2 err-to-data-stax-err-kfm-v2))))


   (->> (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)
	:nodes
	make-node-id-to-data-stax-err-map-v2)

   (=>
    {"[5 :then 0]" {:data-stax-err-type "error=parse-invoke-bad-function error=parse-invoke-bad-arity",
		    :data-stax-err-text "printl is not a known function!\n0 is not a valid arity (must be pos-int)!"},
     "[8 :then 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "a is not an allowed op"},
     "[8 :else 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "b is not an allowed op"}}
    )
   #+end_src
*** Third and Final Version

    In v3 of the keyfnmap
    + keys match those in the error maps (:err-type and :err-text)
    + values are a vector pair of functions [<key-fn> <val-fn>]
      + <key-fn> :: a function to convert the key into its ~:data-stax-~ form
      + ~:val-fn~ :: a function to convert the values of the sequence of errors by key into a compound string of the key's values

   #+begin_src clojure :ns user :results output :exports both :eval no-export
   (def err-to-data-stax-err-kfm-v3
     {:err-type [key-to-data-stax-key
		 (fn [som]
		   (apply str
			  (sequence (comp (map :err-type)
					  (map name)
					  (interpose " "))
				    som)))]
      :err-text [key-to-data-stax-key
		 (fn [som]
		   (apply str
			  (sequence (comp (map :err-text)
					  (interpose "\n"))
				    som)))]})

   (defn map-vals-via-keyfnmap-v3
	[keyfnmap target-map]
	(map-vals (fn [v]
		    (map-kv (fn [k [key-fn val-fn]]
			      [(key-fn k) (val-fn v)])
			    keyfnmap))
		  target-map))


   (defn make-node-id-to-data-stax-err-map-v3
     ([nodes]
      (->> (nodes-to-indexed-property nodes (comp str :node-index) :errors)
	   (map-vals-via-keyfnmap-v3 err-to-data-stax-err-kfm-v3)))
     ([nodes err-key err-val-set]
      (->> (nodes-to-indexed-property nodes (comp str :node-index) :errors)
	   (map-vals (partial filter #(-> % err-key err-val-set)))
	   (remove-vals empty?)
	   (map-vals-via-keyfnmap-v3 err-to-data-stax-err-kfm-v3))))

   (->> (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)
	:nodes
	make-node-id-to-data-stax-err-map-v3)


   (=>
    {"[5 :then 0]" {:data-stax-err-type "error=parse-invoke-bad-function error=parse-invoke-bad-arity",
		    :data-stax-err-text "printl is not a known function!\n0 is not a valid arity (must be pos-int)!"},
     "[8 :then 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "a is not an allowed op"},
     "[8 :else 0]" {:data-stax-err-type "error=parse-illegal-operation",
		    :data-stax-err-text "b is not an allowed op"}}
    )
   #+end_src

   Let's compare their benchmarks
   
*** Comparison
    #+begin_src clojure :ns user :results output :exports both :eval no-export
    (let [{:keys [nodes]} (build-node-data '[!a !b !c] ex/ops-kdh-bad-example)]
      (qb (make-node-id-to-data-stax-err-map-v1 nodes))
      (qb (make-node-id-to-data-stax-err-map-v2 nodes))
      (qb (make-node-id-to-data-stax-err-map-v3 nodes)))
    ;;+>
    ;; ================================================================================
    ;; (make-node-id-to-data-stax-err-map-v1 nodes)
    ;; --------------------------------------------------------------------------------
    ;; Evaluation count : 5466 in 6 samples of 911 calls.
    ;;              Execution time mean : 236.889674 µs
    ;;     Execution time std-deviation : 223.990691 µs
    ;;    Execution time lower quantile : 67.914610 µs ( 2.5%)
    ;;    Execution time upper quantile : 613.808271 µs (97.5%)
    ;;                    Overhead used : 9.100103 ns

    ;; Found 1 outliers in 6 samples (16.6667 %)
    ;; 	low-severe	 1 (16.6667 %)
    ;;  Variance from outliers : 83.1311 % Variance is severely inflated by outliers
    ;; ________________________________________________________________________________


    ;; ================================================================================
    ;; (make-node-id-to-data-stax-err-map-v2 nodes)
    ;; --------------------------------------------------------------------------------
    ;; Evaluation count : 30960 in 6 samples of 5160 calls.
    ;;              Execution time mean : 46.341016 µs
    ;;     Execution time std-deviation : 23.430830 µs
    ;;    Execution time lower quantile : 19.427353 µs ( 2.5%)
    ;;    Execution time upper quantile : 66.481346 µs (97.5%)
    ;;                    Overhead used : 9.100103 ns
    ;; ________________________________________________________________________________


    ;; ================================================================================
    ;; (make-node-id-to-data-stax-err-map-v3 nodes)
    ;; --------------------------------------------------------------------------------
    ;; Evaluation count : 30930 in 6 samples of 5155 calls.
    ;;              Execution time mean : 31.301246 µs
    ;;     Execution time std-deviation : 40.072520 µs
    ;;    Execution time lower quantile : 14.280134 µs ( 2.5%)
    ;;    Execution time upper quantile : 100.736196 µs (97.5%)
    ;;                    Overhead used : 9.100103 ns

    ;; Found 1 outliers in 6 samples (16.6667 %)
    ;; 	low-severe	 1 (16.6667 %)
    ;;  Variance from outliers : 83.2230 % Variance is severely inflated by outliers
    ;; ________________________________________________________________________________
    #+end_src

    ~make-node-id-to-data-stax-err-map-v1~ does what it should.
    But ~make-node-id-to-data-stax-err-map-v2~ does it over 5 times faster.
    And ~make-node-id-to-data-stax-err-map-v3~ does it over 7 times faster.

    Plus, I like that the vals in keyfnmap-v3 takes a map-entry like form of [key-fn val-fn], which is analogous to [k v].
    It's faster and easier to reason about.

* Project Structure ¿TODO?
** Files

   #+name: tree
#+begin_quote
  ROOT
  |
  +--foo
  |  +----bar
  |
  +--baz
  +--bax
  +--src
  |  +--main
  |  |  +---java
  |  |  |   +---something
  |  |  |
  |  |  +---fine
  |  |
  |  +--yes
  |  +--no
#+end_quote

svg.clj [[../src/clj/kdh/stax/svg.org][src]] [[../dev/clj/kdh/stax/svg.html][dev]]

** Project kdh.stax "0.1.0"
   #+begin_example
 stax
 ├── #notes.org#
 ├── 2022-04-27T09:38:58.512414700.edn
 ├── CHANGELOG.md
 ├── LICENSE
 ├── README.md
 ├── dev
 │   ├── clj
 │   │   ├── #dev.clj#
 │   │   ├── bubba.clj
 │   │   ├── dev.clj
 │   │   ├── kdh
 │   │   │   ├── dev_utils.clj
 │   │   │   └── stax
 │   │   │       ├── #error-tests.clj#
 │   │   │       ├── #svg-test.clj#
 │   │   │       ├── error-tests.clj
 │   │   │       ├── examples-20220629112159Z.clj
 │   │   │       ├── nodes-tests.clj
 │   │   │       └── svg-test.clj
 │   │   ├── resources
 │   │   ├── user.clj
 │   │   └── vizit.clj
 │   └── resources
 ├── doc
 │   └── intro.md
 ├── html
 │   ├── kdh-bad-example-dbg.html
 │   ├── kdh-better-example-dbg.html
 │   ├── kdh-runtime-error-example-dbg.html
 │   ├── kdh-some-bad-paths-example-fix1st-no-static.html
 │   ├── kdh-some-bad-paths-example-no-static.html
 │   ├── kdh-some-bad-paths-example.html
 │   ├── kdh-worse-example-dbg.html
 │   ├── mystyle.css
 │   └── rpl-example-dbg.html
 ├── html*
 │   ├── kdh-bad-example-dbg.html
 │   ├── kdh-better-example-dbg.html
 │   ├── kdh-runtime-error-example-dbg.html
 │   ├── kdh-worse-example-dbg.html
 │   ├── mystyle.css
 │   └── rpl-example-dbg.html
 ├── lein.1
 ├── lein.sh
 ├── log
 ├── nodify-ops*-kdh-better-example.html
 ├── org
 │   ├── 4mat.org
 │   ├── dot.org
 │   ├── graphviz.org
 │   ├── notes.org
 │   ├── ops-orig.dot
 │   └── switch.png
   #+end_example

** Notes on VOVOSON VOVON VOSON SON VON ¿EXPLAIN?
 + VOVOSON :: a vector of vector of sequence of nodes
   + itermediate form of cartesion paths
 + VOSON   :: a vector of sequence of nodes
   + a single path is a single term for cartesion product of paths
 + VOVON :: a vector of vectors of nodes
   + paths as contained in the node-data returned ~build-node-data~
   + nodes as contained in the node-data returned ~build-node-data~
 + VON :: a vector of nodes
   + a single path


   | KEY         | ::op=        | DESCRIPTION                                                    |
   |-------------+--------------+----------------------------------------------------------------|
   | :op         |              | the operation as a quoted value -e.g. '<pop> or '(invoke> + 2) |
   | :op-type    |              | See operation table                                            |
   | :needs      |              | how many stack values the operation requires                   |
   | :delta      |              | the change to the stack size after execution                   |
   | :op-index   |              | vector of pos-int to the operation in the original sequence    |
   | :node-index |              | vector of pos-int to the operation in the resulting node-tree  |
   | :fun        | invoke       | function value of invoke> operation                            |
   | :arity      | invoke       | number of stack items the invoke> operation will consume       |
   | :then       | if           | a node subtree to follow if the top of the stack is truthy     |
   | :else       | if           | a node subtree to follow if the top of the stack is falsey     |
   | :var-ref    | def/push-var | !v form symbol for stack variable                              |
   | :var-def    | def-var      | !v+ form for stack variable (::op=def-var only)                |
   | :errors     |              | vector of error maps with keys :err-zone :err-type :err-text   |

   | OPERATION       | :op-type      | :needs | :delta | DESCRIPTION                                                  |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | !v              | ::op=push-var |      0 |     +1 | to push the value of a stack variable onto the stack         |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | const           | ::op=push-sef |      0 |     +1 | to push the value of a self evaluating form onto the stack   |
   |                 |               |        |        | (number, string, character, keyword, boolean, nil)           |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | <pop>           | ::op=pop      |      1 |     -1 | to pop the top of the stack                                  |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | !v+             | ::op=def-var  |      1 |      0 | to define a (possibly new) stack variable and assign it      |
   |                 |               |        |        | the stack without changing the stack                         |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | (invoke> f n)   | ::op=invoke   |      n | -(n-1) | to invoke a function f :fun on a number of arguments :arity  |
   |                 |               |        |        | removed from the stack and replace with its return value     |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | (if> t1 t2...   | ::op=if       |      1 |     -1 | to branch conditionally on the top of the stack (popping it) |
   | else> e1 e2...) |               |        |        | into :then or :else which are vectors of nodes               |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|
   | any other form  | ::op=illegal  |     NA |     NA | not a legal op"                                              |
   |-----------------+---------------+--------+--------+--------------------------------------------------------------|

*** (nodify-ops operations) => node-tree
 The list of operations given to defstackfn is converted into a node-tree,
 which is a vector of nodes where if> nodes contain :then and :else branches,
 which are themselves vectors of nodes.
 Parse errors are added to the nodes at this stage and for:
 + invoke>
   + :kdh.stax.errs/error=invoke-wrong-number-args
   + :kdh.stax.errs/error=invoke-bad-function
   + :kdh.stax.errs/error=invoke-bad-arity
 + illegal operations
   + :kdh.stax.errs/error=illegal-operation
*** (flatten-node-tree node-tree) => nodes
 nodes is a vector of nodes in the same order left to right as operations given to defstackfn with the if> and else> terms and parenthesis removed. nodes main use is for scanning for tree errors in node-tree (errors found by nodify-ops). The kdh.stax.svg/node-data-to-html uses it to decorate the tree visualization (the black diagram) with global errors (errors whose :err-zone value is :kdh.stax.errs/zone=tree).
*** (node-tree-to-node-paths declarations node-tree) => paths a vovon where each path is a von
 For the static analysis checks, we want to analyze each path through the tree for consistency.

**** (check-refs-path path)
 Variables in a path cannot be referenced before being defined (except for the declarations supplied to defstackfn).
   + :kdh.stax.errs/error=insufficient-stack
**** (count-card-path path)
 Stack cardinality, if the needs of an op node are greater than the size of the stack, the node is given an error of :err-type:
   + :kdh.stax.errs/error=undefined-var



 Execution steps, we want to traverse the node-tree, maintaining state as we go, deciding on the fly whether to travel through :then or :else.  The trace of such traversal is a path (possibly incomplete due to runtime errors).
 + For stack cardinality (the size of stack must be >= the needs of an op node for the op to be executable).
*** TODO Notes to Self (fix for 0.1.0 release)
**** TODO print runtime errors
 Especially for static analysis failed -- throw them when *throw-on-error*
**** TODO Maybe rename and/or split *throw-on-error*
**** DOING enforce sef args to <stackfn>
**** TODO handle <stackfn>-debug case with 0 args and 0 dcls (i.e. exec once for results of one)
**** DONE test if> in first position for cardi fail
     CLOSED: [2022-06-21 Tue 02:01]
 this is fixed by addition of if-pop
**** DONE Fix "Cannot throw exception" - throw of nil
     CLOSED: [2022-06-21 Tue 13:00]
**** DONE enforce sef on result of invoke
     CLOSED: [2022-06-21 Tue 13:01]
**** CANCELED handle graph vs digraph ("--" vs "->")
     CLOSED: [2022-06-21 Tue 13:01]
**** TODO discuss constant as
***** self-evaluating?
***** simple vs complex
***** item vs collection
***** restriction on lookup
**** TODO note that invoke cannot take a literal or anonymous function
*** Notes to Future Self (fix for future releases)
**** TODO add tests
     In version 0.1.0 many of the tests are inside (comment )
     + This aids in quick testing of the code during development
     + These will be moved into test libraries for version 0.2.x
**** TODO defrecord OpNode and one or more defprotocol
     Now that the map version is understood, version 0.2.x should use a record with required keys [op op-index node-index needs delta]
     and protocols to extend
**** TODO defrecord OpError and one or more defprotocol
     Now that the map version is understood, version 0.2.x should use a record with required keys [err-text err-type err-zone]
     and protocols to define (message) and (data) for cleaner error to throw calls
     + (message #OpError) could return (:err-text self)
     + (data #OpError) could return (dissoc self :err-text)
**** TODO client-side stack op builder
     The html dbg generation shows that svg can be quite useful for visualizing errors.
     A re-frame app that allows for dynamic altering of ops and reactive path/results generation would be a good front-end dev project.
**** TODO harmonize :results :trace to :path
     Currently, the trace (which is generated from :node-tree) does not contain ::op=start or ::op=term nodes.
     This prevents :data-stax-path "good" "bad" marking of the resulting svg, which prevents css coloring of those nodes and adjacent edges.
     Fixing this is tricky and not necessary for the current html generation (which is for dev use only -- i.e. not a client-side app).
     But I have some thoughts now on adding this feature:
     + A completed (i.e. no :errors) :result :trace set is (keep :node-index) equivalent to a :path
       minus the path's first (i.e. ::op=start) and last (i.e ::op=term)
     + An incomplete result (i.e. has :errors) might have multiple branches after the :error
       I think I don't want to mark them, instead only mark from ::op=start to node of :error
* Environment
  I wrote this as in
  + org-mode ~release​_9.4.4~
  + emacs ~version 27.2~
  
  The code was built with
  + CIDER 1.3.0 (Ukraine)
  + Leiningen ~2.9.8~
  + Clojure ~1.11.1~
  + dot - graphviz version ~2.43.0~
  + Java ~17.0.3 OpenJDK 64-Bit Server VM on Ubuntu (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)

  The OS
  + Ubuntu ~20.04.4 LTS~
  + WSL2 on Windows-11
  
** Java Properties
  #+begin_src clojure :ns user :results value table :exports results :eval no-export :wrap (src-decorate "export org" "Java Properties")
  (->> (System/getProperties)
       seq
       (partition 2)
       (into {})
       (#(dissoc % "java.class.path"))
     (map-vals #(str/replace % "_" "​_"))
       (sort-by #(-> % first (str/split #"\.")) path-compare))
 #+end_src

  #+RESULTS:
  #+begin_ORG
  #+caption: Java Properties
  | apple.awt.UIElement           | true                                                                                                                            |
  | clojure.compile.path          | /mnt/e/Sync/clojure/rpl/stax/target/classes                                                                                     |
  | clojure.debug                 | false                                                                                                                           |
  | file.encoding                 | UTF-8                                                                                                                           |
  | file.separator                | /                                                                                                                               |
  | java.home                     | /usr/lib/jvm/java-17-openjdk-amd64                                                                                              |
  | java.io.tmpdir                | /tmp                                                                                                                            |
  | java.library.path             | /usr/java/packages/lib:/usr/lib/x86​_64-linux-gnu/jni:/lib/x86​_64-linux-gnu:/usr/lib/x86​_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib |
  | java.runtime.name             | OpenJDK Runtime Environment                                                                                                     |
  | java.runtime.version          | 17.0.3+7-Ubuntu-0ubuntu0.20.04.1                                                                                                |
  | java.specification.name       | Java Platform API Specification                                                                                                 |
  | java.specification.vendor     | Oracle Corporation                                                                                                              |
  | java.specification.version    | 17                                                                                                                              |
  | java.vendor                   | Private Build                                                                                                                   |
  | java.vendor.url               | Unknown                                                                                                                         |
  | java.vendor.url.bug           | Unknown                                                                                                                         |
  | java.version                  | 17.0.3                                                                                                                          |
  | java.version.date             | 2022-04-19                                                                                                                      |
  | java.vm.compressedOopsMode    | 32-bit                                                                                                                          |
  | java.vm.info                  | mixed mode, sharing                                                                                                             |
  | java.vm.name                  | OpenJDK 64-Bit Server VM                                                                                                        |
  | java.vm.specification.name    | Java Virtual Machine Specification                                                                                              |
  | java.vm.specification.vendor  | Oracle Corporation                                                                                                              |
  | java.vm.specification.version | 17                                                                                                                              |
  | java.vm.vendor                | Private Build                                                                                                                   |
  | java.vm.version               | 17.0.3+7-Ubuntu-0ubuntu0.20.04.1                                                                                                |
  | jdk.debug                     | release                                                                                                                         |
  | line.separator                | \n                                                                                                                              |
  | native.encoding               | UTF-8                                                                                                                           |
  | os.arch                       | amd64                                                                                                                           |
  | os.name                       | Linux                                                                                                                           |
  | os.version                    | 5.10.102.1-microsoft-standard-WSL2                                                                                              |
  | path.separator                | :                                                                                                                               |
  | stax.version                  | 0.1.0-SNAPSHOT                                                                                                                  |
  | sun.arch.data.model           | 64                                                                                                                              |
  | sun.boot.library.path         | /usr/lib/jvm/java-17-openjdk-amd64/lib                                                                                          |
  | sun.cpu.endian                | little                                                                                                                          |
  | sun.io.unicode.encoding       | UnicodeLittle                                                                                                                   |
  | sun.java.command              | clojure.main -i /tmp/form-init14542468886342858337.clj                                                                          |
  | sun.java.launcher             | SUN​_STANDARD                                                                                                                    |
  | sun.jnu.encoding              | UTF-8                                                                                                                           |
  | sun.management.compiler       | HotSpot 64-Bit Tiered Compilers                                                                                                 |
  | user.dir                      | /mnt/e/Sync/clojure/rpl/stax                                                                                                    |
  | user.home                     | /home/keith                                                                                                                     |
  | user.language                 | en                                                                                                                              |
  | user.name                     | keith                                                                                                                           |
  | user.timezone                 | America/New​_York                                                                                                                |
  #+end_ORG

** Java Class Path
 #+name: class_path
  #+begin_src clojure :ns user :results output pp :exports results :eval no-export :wrap export html
  (let [java-class-path
	(-> (->> (System/getProperties) seq (partition 2) (into {}))
	    (get "java.class.path")
	    (str/split #":"))]
    (->> java-class-path
	 (mapv (fn [s] [:tr [:td s]]))
	 (into [:table [:caption "Java Class Path"]])
	 hiccup.core/html
	 print))
  #+end_src

  #+RESULTS: fig:class_path
  #+begin_export html
  <table><caption>Java Class Path</caption><tr><td>/mnt/e/Sync/clojure/rpl/stax/test</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev/clj</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/src/clj</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev/clj/resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev-resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/target/classes</td></tr><tr><td>/home/keith/.m2/repository/djblue/portal/0.28.0/portal-0.28.0.jar</td></tr><tr><td>/home/keith/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.8.7/jackson-core-2.8.7.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-model-builder/3.5.3/maven-model-builder-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-builder-support/3.5.3/maven-builder-support-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/nrepl/incomplete/0.1.0/incomplete-0.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/msgpack/msgpack/0.6.12/msgpack-0.6.12.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/httpcomponents/httpclient/4.5.3/httpclient-4.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-io/commons-io/2.5/commons-io-2.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-model/3.5.3/maven-model-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-wagon/1.0.3/maven-resolver-transport-wagon-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/criterium/criterium/0.4.4/criterium-0.4.4.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-java/1.0.362/transit-java-1.0.362.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-util/1.1.1/maven-resolver-util-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/rpl/specter/1.1.4/specter-1.1.4.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/data.xml/0.0.8/data.xml-0.0.8.jar</td></tr><tr><td>/home/keith/.m2/repository/com/google/guava/guava/20.0/guava-20.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-repository-metadata/3.5.3/maven-repository-metadata-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/javax/xml/bind/jaxb-api/2.3.0/jaxb-api-2.3.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-resolver-provider/3.5.3/maven-resolver-provider-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-utils/3.1.0/plexus-utils-3.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-provider-api/3.0.0/wagon-provider-api-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/fipp/fipp/0.6.23/fipp-0.6.23.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-http/3.0.0/wagon-http-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-js/0.8.874/transit-js-0.8.874.jar</td></tr><tr><td>/home/keith/.m2/repository/mvxcvi/arrangement/1.2.0/arrangement-1.2.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-api/1.1.1/maven-resolver-api-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.7.1/plexus-component-annotations-1.7.1.jar</td></tr><tr><td>/home/keith/.m2/repository/rewrite-clj/rewrite-clj/0.6.1/rewrite-clj-0.6.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-http/1.0.3/maven-resolver-transport-http-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/zprint/zprint/1.1.1/zprint-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/math.numeric-tower/0.0.5/math.numeric-tower-0.0.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-connector-basic/1.0.3/maven-resolver-connector-basic-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/core.rrb-vector/0.1.2/core.rrb-vector-0.1.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-spi/1.1.1/maven-resolver-spi-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/mvxcvi/puget/1.3.1/puget-1.3.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/tcrawley/dynapath/1.0.0/dynapath-1.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/httpcomponents/httpcore/4.4.6/httpcore-4.4.6.jar</td></tr><tr><td>/home/keith/.m2/repository/macroz/tangle/0.2.2/tangle-0.2.2.jar</td></tr><tr><td>/home/keith/.m2/repository/rewrite-cljs/rewrite-cljs/0.4.5/rewrite-cljs-0.4.5.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/sci/0.2.1-alpha.1/sci-0.2.1-alpha.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/jsoup/jsoup/1.7.2/jsoup-1.7.2.jar</td></tr><tr><td>/home/keith/.m2/repository/com/googlecode/json-simple/json-simple/1.1.1/json-simple-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/hiccup/hiccup/1.0.5/hiccup-1.0.5.jar</td></tr><tr><td>/home/keith/.m2/repository/nrepl/nrepl/0.8.3/nrepl-0.8.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/flatland/ordered/1.5.7/ordered-1.5.7.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/core.specs.alpha/0.2.62/core.specs.alpha-0.2.62.jar</td></tr><tr><td>/home/keith/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/flatland/useful/0.11.6/useful-0.11.6.jar</td></tr><tr><td>/home/keith/.m2/repository/hashp/hashp/0.2.1/hashp-0.2.1.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/sci.impl.reflector/0.0.1/sci.impl.reflector-0.0.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-cljs/0.8.269/transit-cljs-0.8.269.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/spec.alpha/0.3.218/spec.alpha-0.3.218.jar</td></tr><tr><td>/home/keith/.m2/repository/org/slf4j/jcl-over-slf4j/1.6.2/jcl-over-slf4j-1.6.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-http-shared/3.0.0/wagon-http-shared-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-file/1.0.3/maven-resolver-transport-file-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar</td></tr><tr><td>/home/keith/.m2/repository/failjure/failjure/2.2.0/failjure-2.2.0.jar</td></tr><tr><td>/home/keith/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.24/plexus-interpolation-1.24.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jar</td></tr><tr><td>/home/keith/.m2/repository/cider/cider-nrepl/0.28.3/cider-nrepl-0.28.3.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cemerick/pomegranate/1.1.0/pomegranate-1.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-clj/1.0.329/transit-clj-1.0.329.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/tools.macro/0.1.1/tools.macro-0.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/edamame/0.0.11-alpha.28/edamame-0.0.11-alpha.28.jar</td></tr><tr><td>/home/keith/.m2/repository/org/javassist/javassist/3.18.1-GA/javassist-3.18.1-GA.jar</td></tr><tr><td>/home/keith/.m2/repository/http-kit/http-kit/2.6.0/http-kit-2.6.0.jar</td></tr><tr><td>/home/keith/.m2/repository/medley/medley/1.4.0/medley-1.4.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/slf4j/slf4j-api/1.6.2/slf4j-api-1.6.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-artifact/3.5.3/maven-artifact-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/clj-stacktrace/clj-stacktrace/0.2.8/clj-stacktrace-0.2.8.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-impl/1.1.1/maven-resolver-impl-1.1.1.jar</td></tr></table>
  #+end_export

