<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-07-14 Thu 03:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>kdhouser/kdh.stax</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Keith D Houser" />
<meta name="description" content="Project Notes for kdhouser24/kdh.stax"
 />
<meta name="keywords" content="syntax, org, document" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<style>pre.src{background:black;color:white;} </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">kdhouser/kdh.stax</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb3b08e1">TODOs</a>
<ul>
<li><a href="#orgf811c13"><span class="todo DOING">DOING</span> var-map (dynamic)</a></li>
<li><a href="#org7cb297a"><span class="todo TODO">TODO</span> File tree</a></li>
<li><a href="#orgc3e6202"><span class="todo TODO">TODO</span> path-compare</a></li>
<li><a href="#orge7f9577"><span class="todo DOING">DOING</span> verify all predicate return false, not nil</a></li>
<li><a href="#orgc347587"><span class="todo TODO">TODO</span> cleanup ¿TODO?</a></li>
<li><a href="#orgdbb7936"><span class="todo TODO">TODO</span> cleanup dev tree</a>
<ul>
<li><a href="#org77accb1"><span class="todo TODO">TODO</span> dev/clj/kdh/stax to this doc</a></li>
<li><a href="#org6a7e4b0"><span class="todo TODO">TODO</span> dev/clj to dev/clj/kdh/stax</a></li>
</ul>
</li>
<li><a href="#org3a0daed"><span class="todo DOING">DOING</span> cleanup #[​_p] (=&gt;) (comment) in src tree</a></li>
<li><a href="#org74a0557"><span class="todo TODO">TODO</span> cleanup ¿TODO?</a></li>
<li><a href="#org55dd1fd"><span class="todo DOING">DOING</span> record location of error in original ops</a></li>
<li><a href="#orgfd5fd45"><span class="done DONE">DONE</span> throw errors</a></li>
<li><a href="#org1c9050d"><span class="done DONE">DONE</span> expand (if&gt; !a !b else&gt; !b !c)</a></li>
<li><a href="#orgd36beb0"><span class="done DONE">DONE</span> snarfing let (lexical)</a></li>
<li><a href="#orge848a9e"><span class="done DONE">DONE</span> collect all errors</a></li>
<li><a href="#org51b65ea"><span class="done DONE">DONE</span> not an allowed operation</a></li>
<li><a href="#org5dbe82a"><span class="done DONE">DONE</span> invoke no such function</a></li>
<li><a href="#org82f3413"><span class="done DONE">DONE</span> invoke arity not pos-int</a></li>
<li><a href="#org389fb45"><span class="done DONE">DONE</span> ref before def</a></li>
<li><a href="#org8bd8abc"><span class="done DONE">DONE</span> insufficient stack for operation</a></li>
</ul>
</li>
<li><a href="#org91bbbbb">Introduction</a>
<ul>
<li><a href="#orge273106">Workflow</a>
<ul>
<li><a href="#org6db6607">Starting an nrepl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5bc4490">Assignment</a>
<ul>
<li>
<ul>
<li><a href="#org7b46cc7">Reformatted Assignment</a>
<ul>
<li><a href="#org524bc12">Page 1</a></li>
<li><a href="#orgfda0eac">Page 2</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf5f1f21">Requirements</a>
<ul>
<li><a href="#org0a2fd5d">Explicit Requirements</a>
<ul>
<li><a href="#org1469b7a"><span class="done DONE">DONE</span> <b>req-e-01</b>: Variables are symbols prefixed with "!", e.g. !v</a></li>
<li><a href="#orgd451465"><span class="done DONE">DONE</span> <b>req-e-02</b>: A stack function is defined with "defstackfn"</a></li>
<li><a href="#org4faaffd"><span class="done DONE">DONE</span> <b>req-e-03</b>: The first argument is the input declaration which also provides variable names to the arguments</a></li>
<li><a href="#org529d5be"><span class="done DONE">DONE</span> <b>req-e-04</b>: The stack always starts empty</a></li>
<li><a href="#org73f7528"><span class="done DONE">DONE</span> <b>req-e-05</b>: The implementation of a stackfn is a sequence of stack operations</a></li>
<li><a href="#org9f442e1"><span class="done DONE">DONE</span> <b>req-e-06</b>: Using a constant as a stack operation pushes that value onto the stack</a></li>
<li><a href="#org09c84a5"><span class="done DONE">DONE</span> <b>req-e-07</b>: A variable is assigned the top value of the stack by appending "​+" to the variable name,  e.g. !v​+</a></li>
<li><a href="#org0ed6433"><span class="done DONE">DONE</span> <b>req-e-08</b>: A function is invoked with "invoke&gt;".</a></li>
<li><a href="#org4d4815a"><span class="done DONE">DONE</span> <b>req-e-09</b>: "invoke&gt;" takes as input the operation</a></li>
<li><a href="#orgead0813"><span class="done DONE">DONE</span> <b>req-e-10</b>: "invoke&gt;" takes as input the arity to use</a></li>
<li><a href="#org810d0ce"><span class="done DONE">DONE</span> <b>req-e-11</b>: &lt;pop&gt; is a special operation which removes the top value of the stack</a></li>
<li><a href="#org6138466"><span class="done DONE">DONE</span> <b>req-e-12</b>: if&gt; tests if the top value of the stack is truthy to determine which branch to follow.</a></li>
<li><a href="#org58d889f"><span class="done DONE">DONE</span> <b>req-e-13</b>: The branches of if are separated with "else&gt;"</a></li>
<li><a href="#orged43b4c"><span class="done DONE">DONE</span> <b>req-e-14</b>: defstackfn should be a macro&#x2026;.</a></li>
<li><a href="#org86531cf"><span class="done DONE">DONE</span> <b>req-e-15</b>: defstackfn should produce a function invokable like any other function.</a></li>
<li><a href="#org80e8c52"><span class="done DONE">DONE</span> <b>req-e-16</b>: defstackfn should provide an informative error if there's an invalid stack operation</a></li>
<li><a href="#org5bd49b5"><span class="done DONE">DONE</span> <b>req-e-17</b>: defstackfn should provide an informative error if there's a variable is referenced that doesn't exist.</a></li>
<li><a href="#org0d47610"><span class="done DONE">DONE</span> <b>req-e-18</b>: It should be possible to shadow vars (naming a new local the name of an existing variable).</a></li>
<li><a href="#org83969b7"><span class="done DONE">DONE</span> <b>req-e-19</b>: The example below contains all functionality you need to implement.</a></li>
</ul>
</li>
<li><a href="#org5c96124">Implicit requirements (<b>req-i-#</b>)</a>
<ul>
<li><a href="#orgb593d11"><span class="done DONE">DONE</span> <b>req-i-01</b>: <code>defstackfn</code> can take an empty declarations argument</a></li>
<li><a href="#org364757a"><span class="done DONE">DONE</span> <b>req-i-02</b>: <code>if&gt;</code> consumes the top of the stack</a></li>
<li><a href="#orgead51ed"><span class="done DONE">DONE</span> <b>req-i-03</b>: <code>!v​+</code> (define variable and assign it top of stack) does not consume the top of the stack</a></li>
<li><a href="#orgb27fafd"><span class="done DONE">DONE</span> <b>req-i-04</b>: <code>(invoke&gt; fun n)</code> applies n items off the top of the stack in stack order (i.e. reverse of underlying vector's order)</a></li>
<li><a href="#org224c118"><span class="done DONE">DONE</span> <b>req-i-05</b>: <code>(invoke&gt; fun n)</code> for the sake of consistency, the return value of invoke should be <i>constant</i> (i.e. self-evaluating)</a></li>
<li><a href="#org4f51d75"><span class="done DONE">DONE</span> <b>req-i-06</b>: <code>(invoke&gt; fun n)</code> for the sake of consistency, values passed to the defstackfn defined function should be <i>constant</i> (i.e. self-evaluating)</a></li>
<li><a href="#orgf6e95db"><span class="done DONE">DONE</span> <b>req-i-07</b>: <code>kdh.stax.core/defstackfn</code> creates a named function that returns the remaining stack as a vector</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgafe3191">Using <code>defstackfn</code></a>
<ul>
<li><a href="#org27b0d75"><code>&lt;name&gt;</code>: the named function defined by <code>defstackfn</code></a></li>
<li><a href="#org0c412a0"><code>&lt;name&gt;-dbg</code>: the debug function defined by <code>defstackfn</code></a></li>
</ul>
</li>
<li><a href="#orgce7e3e8">Nodes</a></li>
<li><a href="#org9f786f9">Node Data</a></li>
<li><a href="#org39cecb6">Errors</a>
<ul>
<li><a href="#org7985061">Error Zones</a>
<ul>
<li><a href="#orgea8b659">Parse Errors</a></li>
<li><a href="#org0c08143">Static Path Analysis Errors</a></li>
<li><a href="#orgab7b54d">Runtime Errors</a></li>
</ul>
</li>
<li><a href="#org6a61ff3">Error Types</a>
<ul>
<li><a href="#orgbf3ba06"><code>:err-type</code> vs <code>err-zone</code></a></li>
<li><a href="#orgdf51c01">Debugging Errors</a></li>
<li><a href="#orgebf1377">NodeFailure</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb4effd4">Dynamic Variables</a></li>
<li><a href="#org6b3c31f">Visualization</a>
<ul>
<li><a href="#orga915fb4">Using Tangle to Generate dot</a></li>
<li><a href="#org6c85549">Turning Stax Node Data into dot and SVG</a></li>
<li><a href="#org92516ce">Debugging Stax Execution in SVG</a>
<ul>
<li><a href="#org6306b3a">A Walkthrough of Good Data Visualization</a></li>
<li><a href="#org2c0a9ee">A Walkthrough of Bad Data Visualization</a></li>
<li><a href="#org37d56e3">A Run Through Bad Data Visualization</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgab4f20a">Optimization Case Studies</a>
<ul>
<li><a href="#orgb5bb2b4">Sorting Paths</a></li>
<li><a href="#org47075ca"><code>nodify-ops</code> vs <code>nodify-ops*</code></a></li>
<li><a href="#org296cd27">KeyFnMap for Decorating SVG Nodes with Op Node Errors</a>
<ul>
<li><a href="#org5981227">First Version</a></li>
<li><a href="#orgf5549ad">Second Version</a></li>
<li><a href="#org6b3e442">Third and Final Version</a></li>
<li><a href="#org4a8918a">Comparison</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4026f7b">Project Structure ¿TODO?</a>
<ul>
<li><a href="#orgf885074">Files</a></li>
<li><a href="#orgfe279ae">Project kdh.stax "0.1.0"</a></li>
<li><a href="#org17c1ee6">Notes on VOVOSON VOVON VOSON SON VON ¿EXPLAIN?</a>
<ul>
<li><a href="#orgaaa7995">(nodify-ops operations) =&gt; node-tree</a></li>
<li><a href="#org7b48027">(flatten-node-tree node-tree) =&gt; nodes</a></li>
<li><a href="#org062a834">(node-tree-to-node-paths declarations node-tree) =&gt; paths a vovon where each path is a von</a>
<ul>
<li><a href="#orgc8f7acd">(check-refs-path path)</a></li>
<li><a href="#org1648764">(count-card-path path)</a></li>
</ul>
</li>
<li><a href="#org693e027"><span class="todo TODO">TODO</span> Notes to Self (fix for 0.1.0 release)</a>
<ul>
<li><a href="#org3199697"><span class="todo TODO">TODO</span> print runtime errors</a></li>
<li><a href="#orgbd816e5"><span class="todo TODO">TODO</span> Maybe rename and/or split <b>throw-on-error</b></a></li>
<li><a href="#orgd6c04e4"><span class="todo DOING">DOING</span> enforce sef args to &lt;stackfn&gt;</a></li>
<li><a href="#org1f916eb"><span class="todo TODO">TODO</span> handle &lt;stackfn&gt;-debug case with 0 args and 0 dcls (i.e. exec once for results of one)</a></li>
<li><a href="#org88f5236"><span class="done DONE">DONE</span> test if&gt; in first position for cardi fail</a></li>
<li><a href="#org95d07b0"><span class="done DONE">DONE</span> Fix "Cannot throw exception" - throw of nil</a></li>
<li><a href="#orgfc187ed"><span class="done DONE">DONE</span> enforce sef on result of invoke</a></li>
<li><a href="#orgf51a7be"><span class="done CANCELED">CANCELED</span> handle graph vs digraph ("&#x2013;" vs "-&gt;")</a></li>
<li><a href="#org50ed065"><span class="todo TODO">TODO</span> discuss constant as</a></li>
<li><a href="#orgef53c39"><span class="todo TODO">TODO</span> note that invoke cannot take a literal or anonymous function</a></li>
</ul>
</li>
<li><a href="#org1a29373">Notes to Future Self (fix for future releases)</a>
<ul>
<li><a href="#org270349b"><span class="todo TODO">TODO</span> add tests</a></li>
<li><a href="#orga284516"><span class="todo TODO">TODO</span> defrecord OpNode and one or more defprotocol</a></li>
<li><a href="#org6f82f29"><span class="todo TODO">TODO</span> defrecord OpError and one or more defprotocol</a></li>
<li><a href="#org0f53025"><span class="todo TODO">TODO</span> client-side stack op builder</a></li>
<li><a href="#org6b5a8a9"><span class="todo TODO">TODO</span> harmonize :results :trace to :path</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org244a779">Environment</a>
<ul>
<li><a href="#org4a78a28">Java Properties</a></li>
<li><a href="#orgb994717">Java Class Path</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
<a href="#org4a78a28">Java Properties</a>
</p>

<p>
<a href="#orgb994717">Java Class Path</a>
</p>

<div id="outline-container-orgb3b08e1" class="outline-2">
<h2 id="orgb3b08e1">TODOs</h2>
<div class="outline-text-2" id="text-orgb3b08e1">
</div>
<div id="outline-container-orgf811c13" class="outline-3">
<h3 id="orgf811c13"><span class="todo DOING">DOING</span> var-map (dynamic)</h3>
</div>
<div id="outline-container-org7cb297a" class="outline-3">
<h3 id="org7cb297a"><span class="todo TODO">TODO</span> File tree</h3>
</div>
<div id="outline-container-orgc3e6202" class="outline-3">
<h3 id="orgc3e6202"><span class="todo TODO">TODO</span> path-compare</h3>
</div>
<div id="outline-container-orge7f9577" class="outline-3">
<h3 id="orge7f9577"><span class="todo DOING">DOING</span> verify all predicate return false, not nil</h3>
</div>
<div id="outline-container-orgc347587" class="outline-3">
<h3 id="orgc347587"><span class="todo TODO">TODO</span> cleanup ¿TODO?</h3>
</div>
<div id="outline-container-orgdbb7936" class="outline-3">
<h3 id="orgdbb7936"><span class="todo TODO">TODO</span> cleanup dev tree</h3>
<div class="outline-text-3" id="text-orgdbb7936">
</div>
<div id="outline-container-org77accb1" class="outline-4">
<h4 id="org77accb1"><span class="todo TODO">TODO</span> dev/clj/kdh/stax to this doc</h4>
</div>
<div id="outline-container-org6a7e4b0" class="outline-4">
<h4 id="org6a7e4b0"><span class="todo TODO">TODO</span> dev/clj to dev/clj/kdh/stax</h4>
</div>
</div>
<div id="outline-container-org3a0daed" class="outline-3">
<h3 id="org3a0daed"><span class="todo DOING">DOING</span> cleanup #[​_p] (=&gt;) (comment) in src tree</h3>
</div>
<div id="outline-container-org74a0557" class="outline-3">
<h3 id="org74a0557"><span class="todo TODO">TODO</span> cleanup ¿TODO?</h3>
</div>
<div id="outline-container-org55dd1fd" class="outline-3">
<h3 id="org55dd1fd"><span class="todo DOING">DOING</span> record location of error in original ops</h3>
</div>
<div id="outline-container-orgfd5fd45" class="outline-3">
<h3 id="orgfd5fd45"><span class="done DONE">DONE</span> throw errors</h3>
<div class="outline-text-3" id="text-orgfd5fd45">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-07-13 Wed 11:05]</span></span></p>
</div>
</div>
<div id="outline-container-org1c9050d" class="outline-3">
<h3 id="org1c9050d"><span class="done DONE">DONE</span> expand (if&gt; !a !b else&gt; !b !c)</h3>
<div class="outline-text-3" id="text-org1c9050d">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-07 Sat 18:34]</span></span></p>
</div>
</div>
<div id="outline-container-orgd36beb0" class="outline-3">
<h3 id="orgd36beb0"><span class="done DONE">DONE</span> snarfing let (lexical)</h3>
<div class="outline-text-3" id="text-orgd36beb0">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-07 Sat 18:34]</span></span></p>
</div>
</div>
<div id="outline-container-orge848a9e" class="outline-3">
<h3 id="orge848a9e"><span class="done DONE">DONE</span> collect all errors</h3>
<div class="outline-text-3" id="text-orge848a9e">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
<div id="outline-container-org51b65ea" class="outline-3">
<h3 id="org51b65ea"><span class="done DONE">DONE</span> not an allowed operation</h3>
<div class="outline-text-3" id="text-org51b65ea">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
<div id="outline-container-org5dbe82a" class="outline-3">
<h3 id="org5dbe82a"><span class="done DONE">DONE</span> invoke no such function</h3>
<div class="outline-text-3" id="text-org5dbe82a">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
<div id="outline-container-org82f3413" class="outline-3">
<h3 id="org82f3413"><span class="done DONE">DONE</span> invoke arity not pos-int</h3>
<div class="outline-text-3" id="text-org82f3413">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
<div id="outline-container-org389fb45" class="outline-3">
<h3 id="org389fb45"><span class="done DONE">DONE</span> ref before def</h3>
<div class="outline-text-3" id="text-org389fb45">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
<div id="outline-container-org8bd8abc" class="outline-3">
<h3 id="org8bd8abc"><span class="done DONE">DONE</span> insufficient stack for operation</h3>
<div class="outline-text-3" id="text-org8bd8abc">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-05-29 Sun 17:41]</span></span></p>
</div>
</div>
</div>


<div id="outline-container-org91bbbbb" class="outline-2">
<h2 id="org91bbbbb">Introduction</h2>
<div class="outline-text-2" id="text-org91bbbbb">
<p>
This document covers <code>kdh/stax</code> version "0.1.0", which is an implementation of the requirements in <a href="rpl-take-home-project1-clj.pdf">rpl-take-home-project1-clj.pdf</a>.
</p>

<p>
I wrote this as an org-mode document in emacs and exported it to HTML using <a href="https://github.com/fniessen/org-html-themes">org-html-themes</a> (theme ReadTheOrg).  If you use org-mode, I highly recommend ReadTheOrg and another package <a href="https://github.com/fniessen/emacs-leuven-theme">emacs-leuven-theme</a> by the same author.
</p>

<p>
org-mode allows in-document evaluation using source blocks like
</p>
<pre class="example" id="orgbc8b87d">
#+begin_src clojure :ns user :results value pp :exports both :eval no-export
(clojure-version)
#+end_src
</pre>
<p>
which, when executed and exported, look like this:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(clojure-version)
</pre>
</div>

<pre class="example" id="org4738df2">
"1.11.1"
</pre>

<p>
For brevity, when many results are needed I show them in the source block like so:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f</span>
  [!a !b !c] <span style="color: #767283; font-style: italic;">; example uses input: 1 2 4. Stack starts empty.</span>
  !a !b (invoke&gt; + 2)!v1+ !c !c &lt;pop&gt; 2 (invoke&gt; * 2)!v2+ (invoke&gt; = 2)
  (if&gt;
      !v1 !v2 (invoke&gt; - 2)
      else&gt; <span style="color: #ff7fff;">"false!!"</span> (invoke&gt; println 1)&lt;pop&gt; !v1 !v2 (invoke&gt; * 2)))

(=&gt; <span style="color: #9fcb66;">#'user</span>/f )

(f 1 2 4)

<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; false!!</span>

(=&gt; [24] )
</pre>
</div>

<p>
Here, the output is shown as comments following <code>;;+&gt;</code> and return values are within <code>(=&gt; )</code> form which is an alias of the <code>comment</code> macro I use to contain the structured and highlighted values returned by an evaluation.  You can see more of this in my dev tree which is where I play with code as I develop.
</p>

<p>
Often, when I use the abbreviated format I do so within a <code>clj</code> block that is not meant to be evaluated within org-mode. I have configured <code>clj</code> for org-mode just enough to display clojure code formatting, but not enough to run with <code>C-c C-c</code> (<code>org-babel-execute-src-block</code>). Instead I <code>C-c '</code> in order to <code>org-edit-src-code</code> it in another window in clojure-mode with CIDER.  This is especially true in <code>benchmark</code> code, where timeouts are a problem.
</p>
</div>

<div id="outline-container-orge273106" class="outline-3">
<h3 id="orge273106">Workflow</h3>
<div class="outline-text-3" id="text-orge273106">
<p>
While I'm on the subject, this is how I work with a clojure project.  I start with a dev and src tree, that are identical in directory structure.
</p>
<pre class="example" id="org7df00ca">
src
└── clj(s)
    └── kdh  
        └── stax
	
dev
└── clj(s)
    └── kdh
        └── stax
</pre>

<p>
Every stax specific <code>file.clj</code> is in <code>src/clj/kdh/stax/file.clj</code> and has a dev cousin in <code>dev/clj/kdh/stax/file-dev.clj</code>
(not file​​_​dev.clj, so I can catch accidental requires of dev files through name mangling failure &#x2013; Could not locate kdh/stax/file​_​dev_​_​init.class,clj)
</p>
</div>

<div id="outline-container-org6db6607" class="outline-4">
<h4 id="org6db6607">Starting an nrepl</h4>
<div class="outline-text-4" id="text-org6db6607">
<p>
I start the project by opening an nrepl with lein or boot or clj tools in the project dir at a terminal first, and &#x2013; if it completes startup without errors &#x2013; quit and restart it in gnu screen (this allows re-attach following accidental disconnect from the terminal).  Then in emacs, I <code>cider-connect-clj</code> or <code>cider-connect-cljs</code> or <code>cider-connect-clj-and-cljs</code> as needed.
</p>

<p>
My dev profile in lein leaves me in ns user, which is defined in <code>/dev/clj/user.clj</code>, where a (dev) function exists to enter ns dev defined in <code>/dev/clj/dev.clj</code>. This allows me to keep experimental things in the ns dev and still get an nrepl up and running to debug.
</p>

<p>
<code>/dev/clj/dev.clj</code> requires all of the basic: <code>clojure.string</code> :as <code>str</code>, <code>clojure.file.io</code> :as <code>io</code>, etc.  All <code>-dev.clj</code> files are in ns dev, so they benefit from the standard requires in <code>dev.clj</code>. <code>-dev.clj</code> files mostly require src tree files (i.e. inside the project).
</p>

<p>
Any dev file can require any src tree file, but src tree files never require dev tree files!  When I develop something good in the dev files, I copy it over into a src tree file and require it back into the -dev.clj file cousin (ns-unmap'ing it if needed).
</p>

<p>
If I refactor (like when I split nodes.clj into node.clj and nodify.clj to fix a cyclic dependency), I restart the repl to achieve a clean namespace.
</p>

<p>
I favor mount over component because mount has a more granular restart.  I used neither in this project as it was sufficient to have an example file with operations of various complexity and errors.
</p>

<p>
Enough about me, onto the project.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org5bc4490" class="outline-2">
<h2 id="org5bc4490">Assignment</h2>
<div class="outline-text-2" id="text-org5bc4490">
<p target="_blank">
(original: <a href="rpl-take-home-project1-clj.pdf" target="_blank">rpl-take-home-project1-clj.pdf</a>)
</p>
</div>
<div id="outline-container-org7b46cc7" class="outline-4">
<h4 id="org7b46cc7">Reformatted Assignment</h4>
<div class="outline-text-4" id="text-org7b46cc7">
<p>
The goal of this project is to implement a Clojure interpreter for a stack-based DSL. An example of the API is on the next page. We are looking for an example of the quality of work you would do at RPL.
</p>
</div>
<div id="outline-container-org524bc12" class="outline-5">
<h5 id="org524bc12">Page 1</h5>
<div class="outline-text-5" id="text-org524bc12">
</div>
<div id="outline-container-org22dda52" class="outline-6">
<h6 id="org22dda52">Explanation of functionality:</h6>
<div class="outline-text-6" id="text-org22dda52">
<ul class="org-ul">
<li>Variables are symbols prefixed with "!", e.g. !v</li>
<li>A stack function is defined with "defstackfn".
<ul class="org-ul">
<li>The first argument is the input declaration which also provides variable names to the arguments.</li>
<li>The stack always starts empty</li>
<li>The implementation of a stackfn is a sequence of stack operations.
<ul class="org-ul">
<li>Using a constant as a stack operation pushes that value onto the stack</li>
<li>Using a variable as a stack operation pushes the value for that variable onto the stack</li>
<li>A variable is assigned the top value of the stack by appending "​+" to the variable name,  e.g. !v​+</li>
<li>A function is invoked with "invoke&gt;". "invoke&gt;" takes as input the operation and the arity to use.</li>
<li>&lt;pop&gt; is a special operation which removes the top value of the stack</li>
<li>if&gt; tests if the top value of the stack is truthy to determine which branch to follow. The branches are separated with "else&gt;"</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orgd299eec" class="outline-6">
<h6 id="orgd299eec">Notes about your implementation:</h6>
<div class="outline-text-6" id="text-orgd299eec">
<ul class="org-ul">
<li>defstackfn should be a macro that produces a function invokable like any other  function.</li>
<li>Should provide an informative error if there's an invalid stack operation or a variable is referenced that doesn't exist.</li>
<li>The example below contains all functionality you need to implement.</li>
<li>It should be possible to shadow vars (naming a new local the name of an existing  variable).</li>
<li>Code example with stack values in comments:</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfda0eac" class="outline-5">
<h5 id="orgfda0eac">Page 2</h5>
<div class="outline-text-5" id="text-orgfda0eac">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>Code example with stack values in comments:</label><pre class="src src-clojure">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f</span>
  [!a !b !c] <span style="color: #767283; font-style: italic;">; example uses input: 1 2 4. Stack starts empty.</span>
  !a <span style="color: #767283; font-style: italic;">; 1</span>
  !b <span style="color: #767283; font-style: italic;">; 1 2</span>
  (invoke&gt; + 2) <span style="color: #767283; font-style: italic;">; 3</span>
  !v1+ <span style="color: #767283; font-style: italic;">; 3</span>
  !c <span style="color: #767283; font-style: italic;">; 3 4</span>
  !c <span style="color: #767283; font-style: italic;">; 3 4 4</span>
  &lt;pop&gt; <span style="color: #767283; font-style: italic;">; 3 4</span>
  2 <span style="color: #767283; font-style: italic;">; 3 4 2</span>
  (invoke&gt; * 2) <span style="color: #767283; font-style: italic;">; 3 8</span>
  !v2+ <span style="color: #767283; font-style: italic;">; 3 8</span>
  (invoke&gt; = 2) <span style="color: #767283; font-style: italic;">; false</span>
  (if&gt; <span style="color: #767283; font-style: italic;">; stack empty</span>
    !v1
    !v2
    (invoke&gt; - 2)
   else&gt;
    <span style="color: #ff7fff;">"false!!"</span> <span style="color: #767283; font-style: italic;">; "false!!"</span>
    (invoke&gt; println 1) <span style="color: #767283; font-style: italic;">; nil</span>
    &lt;pop&gt; <span style="color: #767283; font-style: italic;">; stack empty</span>
    !v1 <span style="color: #767283; font-style: italic;">; 3</span>
    !v2 <span style="color: #767283; font-style: italic;">; 3 8</span>
    (invoke&gt; * 2) <span style="color: #767283; font-style: italic;">; 24</span>
    )
  )

<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(f 1 2 4) prints "false!!" and returns 24</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf5f1f21" class="outline-2">
<h2 id="orgf5f1f21">Requirements</h2>
<div class="outline-text-2" id="text-orgf5f1f21">
</div>
<div id="outline-container-org0a2fd5d" class="outline-3">
<h3 id="org0a2fd5d">Explicit Requirements</h3>
<div class="outline-text-3" id="text-org0a2fd5d">
<p>
Explicit requirements are taken directly from the assignment. They are split into individual testable requirements, and designated <b>req-e-#:</b> where <b>e</b> means explicit, and <b>#</b> is a number.
</p>
</div>

<div id="outline-container-org1469b7a" class="outline-4">
<h4 id="org1469b7a"><span class="done DONE">DONE</span> <a id="org484a1a4"></a> <b>req-e-01</b>: Variables are symbols prefixed with "!", e.g. !v</h4>
<div class="outline-text-4" id="text-org1469b7a">
<p>
<code>kdh.stax.nodify/nodify-op</code> will create a node of type <code>:kdh.stax.node/push-var</code> iff the op passes the predicate <code>kdh.stax.node/!symbol?</code>
</p>
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">!symbol?</span>
  <span style="color: #fd95fa; font-style: italic;">"True if op matches symbol of the form !v where v is anything but ! or +"</span>
  [op]
  (<span style="color: #ffff0b;">and</span> (symbol? op)
       (boolean (re-find #<span style="color: #ff7fff;">"^![^!</span><span style="color: #ffffff; font-weight: bold;">\+</span><span style="color: #ff7fff;">]+$"</span> (name op)))))
</pre>
</div>
<p>
declarations argument to defstackfn is also checked to pass <code>kdh.stax.node/!symbol?</code> in its :pre condition.
</p>
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-01</span> [a b c] a b c)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">!&gt;  Assert failed: (test/is (every? !symbol? declarations))</span>






</pre>
</div>
</div>
</div>
<div id="outline-container-orgd451465" class="outline-4">
<h4 id="orgd451465"><span class="done DONE">DONE</span> <a id="orge9654d9"></a> <b>req-e-02</b>: A stack function is defined with "defstackfn"</h4>
<div class="outline-text-4" id="text-orgd451465">
<p>
Define a trivial stack function (with no declarations and only push numbers).
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-02</span> [] 1 2 3)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-02 )
</pre>
</div>

<p>
Yields a function, which when called returns the stack.
</p>

<div class="org-src-container">
<pre class="src src-clj">(f-req-e-02)
(=&gt; [1 2 3] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org4faaffd" class="outline-4">
<h4 id="org4faaffd"><span class="done DONE">DONE</span> <a id="org546c07d"></a> <b>req-e-03</b>: The first argument is the input declaration which also provides variable names to the arguments</h4>
<div class="outline-text-4" id="text-org4faaffd">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-03</span> [!a !b !c] !b !a !c)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-03 )

(f-req-e-03 <span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:c</span>)
(=&gt; [<span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:c</span>] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org529d5be" class="outline-4">
<h4 id="org529d5be"><span class="done DONE">DONE</span> <a id="orgfd67817"></a> <b>req-e-04</b>: The stack always starts empty</h4>
<div class="outline-text-4" id="text-org529d5be">
<p>
Let's pop an empty stack to see what happens&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-04</span> [] &lt;pop&gt;)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">1st Path Errors [&gt;-start-term-&gt;]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `&lt;pop&gt;' at op[0] node[0]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              stack size=0, operation &lt;pop&gt; needs &gt;=1</span>
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">defstackfn-produced-errors</span> )
</pre>
</div>

<p>
I don't like to throw errors during dev, it's disruptive.  Instead, I return meaningful keys (here <code>:kdh.stax.errs/defstackfn-produced-errors</code>).
</p>

<p>
However, I recognize that others like Exceptions, so I allow them with a dynamic binding&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-04</span> [] &lt;pop&gt;)
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt;
 [<span style="color: #ff7fff;">"defstackfn produced errors"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"1st Path Errors [&gt;-start-term-&gt;]: "</span>

                 [{<span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=pop</span>,
                   <span style="color: #34c8d8; font-weight: bold;">:needs</span> 1,
                   <span style="color: #34c8d8; font-weight: bold;">:delta</span> -1,
                   <span style="color: #34c8d8; font-weight: bold;">:op</span> &lt;pop&gt;,
                   <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [0],
                   <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [0],
                   <span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=path</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=static-insufficient-stack</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"stack size=0, operation &lt;pop&gt; needs &gt;=1"</span>}]}]]],
   <span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">1st Path Errors [&gt;-start-term-&gt;]: </span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`&lt;pop&gt;' at op[0] node[0]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> stack size=0, operation &lt;pop&gt; needs &gt;=1</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>}]
 )
</pre>
</div>

<p>
Exceptions or not, I've proved the stack is initially empty!
</p>
</div>
</div>

<div id="outline-container-org73f7528" class="outline-4">
<h4 id="org73f7528"><span class="done DONE">DONE</span> <a id="org9a3bdfe"></a> <b>req-e-05</b>: The implementation of a stackfn is a sequence of stack operations</h4>
<div class="outline-text-4" id="text-org73f7528">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-05</span> [!a] !a 2 &lt;pop&gt; 3 (invoke&gt; = 2) (if&gt; <span style="color: #ff7fff;">"!a == 3&gt;"</span> else&gt; <span style="color: #ff7fff;">"!a &lt;&gt; 3"</span>) (invoke&gt; println 1))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-05 )

(f-req-e-05 1)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+ !a &lt;&gt; 3</span>
(=&gt; [<span style="color: #34c8d8; font-weight: bold;">nil</span>] )

(f-req-e-05 3)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+ !a == 3</span>
(=&gt; [<span style="color: #34c8d8; font-weight: bold;">nil</span>] )
</pre>
</div>
</div>
</div>
<div id="outline-container-org9f442e1" class="outline-4">
<h4 id="org9f442e1"><span class="done DONE">DONE</span> <a id="org78c50e1"></a> <b>req-e-06</b>: Using a constant as a stack operation pushes that value onto the stack</h4>
<div class="outline-text-4" id="text-org9f442e1">
<p>
In my implementation, I interpret <i>constant</i> as a form that evaluates to itself.
</p>

<p>
<a href="https://clojure.org/reference/evaluation">The Clojure reference page on evaluation</a> says:
</p>

<blockquote>
<p>
Strings, numbers, characters, true, false, nil and keywords evaluate to themselves.
</p>
</blockquote>

<p>
That quote is part of the documentation string for my function <code>ksh.stax.node/self-evaluating?</code>:
</p>

<div class="org-src-container">
<pre class="src src-clj">(doc self-evaluating?)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">-------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">kdh.stax.node/self-evaluating?</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">([op])</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">True if op is a self evaluating form.</span>
<span style="color: #767283;">;;   </span><span style="color: #767283; font-style: italic;">https://clojure.org/reference/evaluation says 'Strings, numbers, characters, true, false, nil and keywords evaluate to themselves.'</span>
</pre>
</div>

<p>
Let's push one of each onto the stack
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-06</span> [] <span style="color: #ff7fff;">"string"</span> 42 <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span>)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-06 )

(f-req-e-06)
(=&gt; [<span style="color: #ff7fff;">"string"</span> 42 <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span>] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org09c84a5" class="outline-4">
<h4 id="org09c84a5"><span class="done DONE">DONE</span> <a id="orgdcd4401"></a> <b>req-e-07</b>: A variable is assigned the top value of the stack by appending "​+" to the variable name,  e.g. !v​+</h4>
<div class="outline-text-4" id="text-org09c84a5">
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-07</span> [] <span style="color: #ff7fff;">"string"</span> 42 !v1+ <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span> !v1)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-07 )

(f-req-e-07)
(=&gt; [<span style="color: #ff7fff;">"string"</span> 42 <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span> 42] )
</pre>
</div>

<p>
!v1+ assigned the top of the stack (42) to the variable !v1 as evidenced by the top of the returned stack after the final !v1 push.
</p>
</div>
</div>

<div id="outline-container-org0ed6433" class="outline-4">
<h4 id="org0ed6433"><span class="done DONE">DONE</span> <a id="orgb9afe60"></a> <b>req-e-08</b>: A function is invoked with "invoke&gt;".</h4>
<div class="outline-text-4" id="text-org0ed6433">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-08</span> [] <span style="color: #ff7fff;">"string"</span> 42 !v1+ <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span> !v1 (invoke&gt; println 1))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-08 )

(f-req-e-08)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; 42</span>
(=&gt; [<span style="color: #ff7fff;">"string"</span> 42 <span style="color: #ff7fff;">\z</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">false</span> <span style="color: #34c8d8; font-weight: bold;">nil</span> <span style="color: #34c8d8; font-weight: bold;">:bubba</span> <span style="color: #34c8d8; font-weight: bold;">nil</span>] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org4d4815a" class="outline-4">
<h4 id="org4d4815a"><span class="done DONE">DONE</span> <a id="orga33c6ac"></a> <b>req-e-09</b>: "invoke&gt;" takes as input the operation</h4>
<div class="outline-text-4" id="text-org4d4815a">
<p>
The first argument to <code>invoke&gt;</code> must be a function (in this example <code>+</code>)
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-09</span> [!a !b] !a !b (invoke&gt; + 2))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-09 )

(f-req-e-09 2 3)
(=&gt; [5] )

(f-req-e-09 <span style="color: #34c8d8; font-weight: bold;">:foo</span> <span style="color: #ff7fff;">"bar"</span>)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">RUNTIME ERRORS:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `(invoke&gt; + 2)' at op[2] node[2]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              `(apply #'clojure.core/+ ("bar" :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))</span>
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">stackfn-produced-runtime-error</span> )
</pre>
</div>

<p>
Or, if you prefer Exceptions&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (f-req-e-09 <span style="color: #34c8d8; font-weight: bold;">:foo</span> <span style="color: #ff7fff;">"bar"</span>)
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt;
 [<span style="color: #ff7fff;">"Runtime Errors"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">RUNTIME ERRORS:</span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`(invoke&gt; + 2)' at op[2] node[2]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> `(apply #'clojure.core/+ (</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;">bar</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;"> :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>,
   <span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"RUNTIME ERRORS:"</span>
                 [{<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=exec</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=runtime-invoke-failed</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"`(apply #'clojure.core/+ (</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;">bar</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;"> :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))"</span>}],
                   <span style="color: #34c8d8; font-weight: bold;">:needs</span> 2,
                   <span style="color: #34c8d8; font-weight: bold;">:fun</span> +,
                   <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span>],
                   <span style="color: #34c8d8; font-weight: bold;">:invoke-args</span> (<span style="color: #ff7fff;">"bar"</span> <span style="color: #34c8d8; font-weight: bold;">:foo</span>),
                   <span style="color: #34c8d8; font-weight: bold;">:trace</span> [{<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                            <span style="color: #34c8d8; font-weight: bold;">:dot-opts</span> {<span style="color: #34c8d8; font-weight: bold;">:shape</span> <span style="color: #34c8d8; font-weight: bold;">:point</span>},
                            <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [],
                            <span style="color: #34c8d8; font-weight: bold;">:delta</span> 0,
                            <span style="color: #34c8d8; font-weight: bold;">:stack</span> [],
                            <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [],
                            <span style="color: #34c8d8; font-weight: bold;">:branch</span> <span style="color: #34c8d8; font-weight: bold;">:start</span>,
                            <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a <span style="color: #34c8d8; font-weight: bold;">:foo</span>,
                                      !b <span style="color: #ff7fff;">"bar"</span>},
                            <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=start</span>}
                           {<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                            <span style="color: #34c8d8; font-weight: bold;">:op</span> !a,
                            <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [0],
                            <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                            <span style="color: #34c8d8; font-weight: bold;">:stack</span> [<span style="color: #34c8d8; font-weight: bold;">:foo</span>],
                            <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [0],
                            <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a <span style="color: #34c8d8; font-weight: bold;">:foo</span>,
                                      !b <span style="color: #ff7fff;">"bar"</span>},
                            <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                            <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !a}
                           {<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                            <span style="color: #34c8d8; font-weight: bold;">:op</span> !b,
                            <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [1],
                            <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                            <span style="color: #34c8d8; font-weight: bold;">:stack</span> [<span style="color: #34c8d8; font-weight: bold;">:foo</span> <span style="color: #ff7fff;">"bar"</span>],
                            <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [1],
                            <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a <span style="color: #34c8d8; font-weight: bold;">:foo</span>,
                                      !b <span style="color: #ff7fff;">"bar"</span>},
                            <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                            <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !b}
                           {<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=exec</span>,
                                      <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=runtime-invoke-failed</span>,
                                      <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"`(apply #'clojure.core/+ (</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;">bar</span><span style="color: #ffffff; font-weight: bold;">\"</span><span style="color: #ff7fff;"> :foo))' failed during execution (class java.lang.String cannot be cast to class java.lang.Number (java.lang.String and java.lang.Number are in module java.base of loader 'bootstrap'))"</span>}],
                            <span style="color: #34c8d8; font-weight: bold;">:needs</span> 2,
                            <span style="color: #34c8d8; font-weight: bold;">:fun</span> +,
                            <span style="color: #34c8d8; font-weight: bold;">:invoke-args</span> (<span style="color: #ff7fff;">"bar"</span> <span style="color: #34c8d8; font-weight: bold;">:foo</span>),
                            <span style="color: #34c8d8; font-weight: bold;">:op</span> (invoke&gt; + 2),
                            <span style="color: #34c8d8; font-weight: bold;">:invoke-fn</span> <span style="color: #9fcb66;">#'clojure.core</span>/+,
                            <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [2],
                            <span style="color: #34c8d8; font-weight: bold;">:delta</span> -1,
                            <span style="color: #34c8d8; font-weight: bold;">:arity</span> 2,
                            <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [2],
                            <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=invoke</span>}],
                   <span style="color: #34c8d8; font-weight: bold;">:op</span> (invoke&gt; + 2),
                   <span style="color: #34c8d8; font-weight: bold;">:invoke-fn</span> <span style="color: #9fcb66;">#'clojure.core</span>/+,
                   <span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a <span style="color: #34c8d8; font-weight: bold;">:foo</span>,
                                  !b <span style="color: #ff7fff;">"bar"</span>},
                   <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [2],
                   <span style="color: #34c8d8; font-weight: bold;">:delta</span> -1,
                   <span style="color: #34c8d8; font-weight: bold;">:arity</span> 2,
                   <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [2],
                   <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=invoke</span>}]]]}]
 )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgead0813" class="outline-4">
<h4 id="orgead0813"><span class="done DONE">DONE</span> <a id="org3b93f60"></a> <b>req-e-10</b>: "invoke&gt;" takes as input the arity to use</h4>
<div class="outline-text-4" id="text-orgead0813">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-10</span> [!a !b] !a !b (invoke&gt; + 2))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-10 )

(f-req-e-10 2 3)
(=&gt; [5] )

(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-10*</span> [!a !b] !a !b (invoke&gt; + 0))
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Global Operation Tree Errors: </span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `(invoke&gt; + 0)' at op[2] node[2]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              0 is not a valid arity (must be pos-int)!</span>
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">defstackfn-produced-errors</span> )
</pre>
</div>

<p>
Or, if you prefer Exceptions&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-10*</span> [!a !b] !a !b (invoke&gt; + 0))
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt; [<span style="color: #ff7fff;">"defstackfn produced errors"</span>
     {<span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"Global Operation Tree Errors: "</span>
                    [{<span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=invoke</span>,
                      <span style="color: #34c8d8; font-weight: bold;">:op</span> (invoke&gt; + 0),
                      <span style="color: #34c8d8; font-weight: bold;">:fun</span> +,
                      <span style="color: #34c8d8; font-weight: bold;">:arity</span> 0,
                      <span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=tree</span>,
                                <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=parse-invoke-arity-not-pos-int</span>,
                                <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"0 is not a valid arity (must be pos-int)!"</span>}],
                      <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [2],
                      <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [2]}]]],
      <span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">Global Operation Tree Errors: </span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`(invoke&gt; + 0)' at op[2] node[2]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> 0 is not a valid arity (must be pos-int)!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>}] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org810d0ce" class="outline-4">
<h4 id="org810d0ce"><span class="done DONE">DONE</span> <a id="org0bd3d18"></a> <b>req-e-11</b>: &lt;pop&gt; is a special operation which removes the top value of the stack</h4>
<div class="outline-text-4" id="text-org810d0ce">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-11</span> [] 1 2 &lt;pop&gt; 3 )
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-11 )

(f-req-e-11)
(=&gt; [1 3] )
</pre>
</div>

<p>
2 got &lt;pop&gt;'d
</p>
</div>
</div>

<div id="outline-container-org6138466" class="outline-4">
<h4 id="org6138466"><span class="done DONE">DONE</span> <a id="org09da8f6"></a> <b>req-e-12</b>: if&gt; tests if the top value of the stack is truthy to determine which branch to follow.</h4>
<div class="outline-text-4" id="text-org6138466">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-12</span> [!a] !a (invoke&gt; even? 1) (if&gt; <span style="color: #ff7fff;">"even"</span> else&gt; <span style="color: #ff7fff;">"odd"</span>))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-12 )

(f-req-e-12 3)
(=&gt; [<span style="color: #ff7fff;">"odd"</span>] )

(f-req-e-12 4)
(=&gt; [<span style="color: #ff7fff;">"even"</span>] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org58d889f" class="outline-4">
<h4 id="org58d889f"><span class="done DONE">DONE</span> <a id="org25953b7"></a> <b>req-e-13</b>: The branches of if are separated with "else&gt;"</h4>
<div class="outline-text-4" id="text-org58d889f">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-13</span> [!a] !a (invoke&gt; even? 1) (if&gt; <span style="color: #ff7fff;">"even"</span> else&gt; <span style="color: #ff7fff;">"odd"</span>))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-13 )

(f-req-e-13 3)
(=&gt; [<span style="color: #ff7fff;">"odd"</span>] )

(f-req-e-13 4)
(=&gt; [<span style="color: #ff7fff;">"even"</span>] )
</pre>
</div>

<p>
Note, my implementation works with a missing <code>else&gt;</code>.
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-13*</span> [!a] !a (invoke&gt; even? 1) (if&gt; <span style="color: #ff7fff;">"even"</span>))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-13* )

(f-req-e-13* 3)
(=&gt; [] )

(f-req-e-13* 4)
(=&gt; [<span style="color: #ff7fff;">"even"</span>] )
</pre>
</div>

<p>
It works with an empty else&gt;.
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-13**</span> [!a] !a (invoke&gt; even? 1) (if&gt; <span style="color: #ff7fff;">"even"</span> else&gt;))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-13** )

(f-req-e-13** 3)
(=&gt; [] )

(f-req-e-13** 4)
(=&gt; [<span style="color: #ff7fff;">"even"</span>] )
</pre>
</div>

<p>
It works with an empty then (the ops between the <code>if&gt;</code> and <code>else&gt;</code>).
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-13***</span> [!a] !a (invoke&gt; even? 1) (if&gt; else&gt; <span style="color: #ff7fff;">"odd"</span>))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-13*** )

(f-req-e-13*** 3)
(=&gt; [<span style="color: #ff7fff;">"odd"</span>] )

(f-req-e-13*** 4)
(=&gt; [] )
</pre>
</div>

<p>
It even works with an empty then and missing else&gt;.
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-13****</span> [!a] !a (invoke&gt; even? 1) (if&gt;))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-13**** )

(f-req-e-13**** 3)
(=&gt; [] )

(f-req-e-13**** 4)
(=&gt; [] )
</pre>
</div>
</div>
</div>
<div id="outline-container-orged43b4c" class="outline-4">
<h4 id="orged43b4c"><span class="done DONE">DONE</span> <a id="org11efba4"></a> <b>req-e-14</b>: defstackfn should be a macro&#x2026;.</h4>
<div class="outline-text-4" id="text-orged43b4c">
<div class="org-src-container">
<pre class="src src-clj">(meta #'defstackfn)
(=&gt;
 {<span style="color: #34c8d8; font-weight: bold;">:arglists</span> ([stackfn-sym declarations &amp; operations]),
  <span style="color: #34c8d8; font-weight: bold;">:doc</span> <span style="color: #ff7fff;">"Defines a stack function that takes declaration as its args,</span>
<span style="color: #ff7fff;">and performs to operations given"</span>,
  <span style="color: #34c8d8; font-weight: bold;">:line</span> 81,
  <span style="color: #34c8d8; font-weight: bold;">:column</span> 1,
  <span style="color: #34c8d8; font-weight: bold;">:file</span> <span style="color: #ff7fff;">"/home/keith/clj/rpl/stax/src/clj/kdh/stax/core.clj"</span>,
  <span style="color: #34c8d8; font-weight: bold;">:name</span> defstackfn,
  <span style="color: #34c8d8; font-weight: bold;">:ns</span> #namespace[kdh.stax.core],
  <span style="color: #34c8d8; font-weight: bold;">:macro</span> <span style="color: #34c8d8; font-weight: bold;">true</span>}
)
</pre>
</div>
</div>
</div>

<div id="outline-container-org86531cf" class="outline-4">
<h4 id="org86531cf"><span class="done DONE">DONE</span> <a id="orgd17cb30"></a> <b>req-e-15</b>: defstackfn should produce a function invokable like any other function.</h4>
<div class="outline-text-4" id="text-org86531cf">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-15</span> [!a !b !c] !c !b !a)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-15 )

(f-req-e-15 1 2 3)

(=&gt; [3 2 1] )

(<span style="color: #ffff0b;">-&gt;&gt;</span> [1 2 3 <span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:c</span>]
     (partition 3)
     (map (partial apply f-req-e-15)))

(=&gt; ([3 2 1] [<span style="color: #34c8d8; font-weight: bold;">:c</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:a</span>]) )
</pre>
</div>
</div>
</div>

<div id="outline-container-org80e8c52" class="outline-4">
<h4 id="org80e8c52"><span class="done DONE">DONE</span> <a id="org9616391"></a> <b>req-e-16</b>: defstackfn should provide an informative error if there's an invalid stack operation</h4>
<div class="outline-text-4" id="text-org80e8c52">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-16</span> [] <span style="color: #34c8d8; font-weight: bold;">true</span> (if&gt; <span style="color: #ff7fff;">"even"</span> else&gt; else&gt; <span style="color: #ff7fff;">"odd"</span>))
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">defstackfn-produced-errors</span> )
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Global Operation Tree Errors:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `else&gt;' at op[1 3] node[1 :else 0]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              else&gt; is not an allowed op</span>
</pre>
</div>

<p>
Or, if you prefer Exceptions&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-16</span> [] <span style="color: #34c8d8; font-weight: bold;">true</span> (if&gt; <span style="color: #ff7fff;">"even"</span> else&gt; else&gt; <span style="color: #ff7fff;">"odd"</span>))
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt;
 [<span style="color: #ff7fff;">"defstackfn produced errors"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"Global Operation Tree Errors: "</span>
                 [{<span style="color: #34c8d8; font-weight: bold;">:op</span> else&gt;,
                   <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.nodify</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=illegal</span>,
                   <span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=tree</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=parse-illegal-operation</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"else&gt; is not an allowed op"</span>}],
                   <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [1 <span style="color: #34c8d8; font-weight: bold;">:else</span> 0],
                   <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [1 3]}]]],
   <span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">Global Operation Tree Errors: </span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`else&gt;' at op[1 3] node[1 :else 0]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> else&gt; is not an allowed op</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>}]
 )
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bd49b5" class="outline-4">
<h4 id="org5bd49b5"><span class="done DONE">DONE</span> <a id="orge4c831e"></a> <b>req-e-17</b>: defstackfn should provide an informative error if there's a variable is referenced that doesn't exist.</h4>
<div class="outline-text-4" id="text-org5bd49b5">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-17</span> [] <span style="color: #34c8d8; font-weight: bold;">true</span> !a)
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">defstackfn-produced-errors</span> )
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">1st Path Errors [&gt;-start-term-&gt;]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `!a' at op[1] node[1]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              !a is a reference before definition</span>
</pre>
</div>

<p>
Or, if you prefer Exceptions&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-17</span> [] <span style="color: #34c8d8; font-weight: bold;">true</span> !a)
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt;
 [<span style="color: #ff7fff;">"defstackfn produced errors"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"1st Path Errors [&gt;-start-term-&gt;]: "</span>
                 [{<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=path</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=static-var-not-defined</span>,
                             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"!a is a reference before definition"</span>}],
                   <span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                   <span style="color: #34c8d8; font-weight: bold;">:op</span> !a,
                   <span style="color: #34c8d8; font-weight: bold;">:cardi</span> 2,
                   <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [1],
                   <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                   <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [1],
                   <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                   <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !a}]]],
   <span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">1st Path Errors [&gt;-start-term-&gt;]: </span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`!a' at op[1] node[1]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> !a is a reference before definition</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>}]
 )
</pre>
</div>
</div>
</div>
<div id="outline-container-org0d47610" class="outline-4">
<h4 id="org0d47610"><span class="done DONE">DONE</span> <a id="org768736e"></a> <b>req-e-18</b>: It should be possible to shadow vars (naming a new local the name of an existing variable).</h4>
<div class="outline-text-4" id="text-org0d47610">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-e-18</span> [!a !b] !a <span style="color: #34c8d8; font-weight: bold;">true</span> !b !a+ 3 !b+ <span style="color: #ff7fff;">"help"</span> !a !b)
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-e-18 )

(f-req-e-18 <span style="color: #34c8d8; font-weight: bold;">:red</span> <span style="color: #34c8d8; font-weight: bold;">:blue</span>)
(=&gt; [<span style="color: #34c8d8; font-weight: bold;">:red</span> <span style="color: #34c8d8; font-weight: bold;">true</span> <span style="color: #34c8d8; font-weight: bold;">:blue</span> 3 <span style="color: #ff7fff;">"help"</span> <span style="color: #34c8d8; font-weight: bold;">:blue</span> 3] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org83969b7" class="outline-4">
<h4 id="org83969b7"><span class="done DONE">DONE</span> <a id="org3c7002f"></a> <b>req-e-19</b>: The example below contains all functionality you need to implement.</h4>
<div class="outline-text-4" id="text-org83969b7">
<p>
This is not a testable requirement, but I will rely on it for justification of implicit requirements
</p>
</div>
</div>
</div>
<div id="outline-container-org5c96124" class="outline-3">
<h3 id="org5c96124">Implicit requirements (<b>req-i-#</b>)</h3>
<div class="outline-text-3" id="text-org5c96124">
<p>
Implicit requirements are those not expressed in the explicit requirements, but implied by them or by simple logical extension.
</p>
</div>
<div id="outline-container-orgb593d11" class="outline-4">
<h4 id="orgb593d11"><span class="done DONE">DONE</span> <a id="orgb87ed3f"></a> <b>req-i-01</b>: <code>defstackfn</code> can take an empty declarations argument</h4>
<div class="outline-text-4" id="text-orgb593d11">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-i-01</span> [] 1 2 (invoke&gt; + 2))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-i-01 )

(f-req-i-01)
(=&gt; [3] )
</pre>
</div>
</div>
</div>
<div id="outline-container-org364757a" class="outline-4">
<h4 id="org364757a"><span class="done DONE">DONE</span> <a id="org64f31dc"></a> <b>req-i-02</b>: <code>if&gt;</code> consumes the top of the stack</h4>
<div class="outline-text-4" id="text-org364757a">
<ul class="org-ul">
<li><p>
According to the explicit requirements,
</p>
<blockquote>
<p>
if&gt; tests if the top value of the stack is truthy to determine which branch to follow. The branches are separated with "else&gt;"
</p>
</blockquote></li>
<li>However, the example shows the stack as empty on line 14:</li>
</ul>
<div class="org-src-container">
<pre class="src src-clj"><span class="linenr">13: </span>(invoke&gt; = 2) <span style="color: #767283; font-style: italic;">; false</span>
<span class="linenr">14: </span>(if&gt; <span style="color: #767283; font-style: italic;">; stack empty</span>
</pre>
</div>

<p>
if <code>if&gt;</code> simply tested the top of the stack without popping, the push of the constant value <code>"false!!"</code> (line 19 above) would result in a stack of <code>[false "false!!"]</code> not <code>["false!!"]</code> as indicated:
</p>
<div class="org-src-container">
<pre class="src src-clj"><span class="linenr">18: </span>else&gt;
<span class="linenr">19: </span> <span style="color: #ff7fff;">"false!!"</span> <span style="color: #767283; font-style: italic;">; "false!!"</span>
</pre>
</div>

<p>
Therefore, I deduce an implicit requirement that <code>if&gt;</code> first tests the top value and then pops it from the stack
</p>
</div>
</div>
<div id="outline-container-orgead51ed" class="outline-4">
<h4 id="orgead51ed"><span class="done DONE">DONE</span> <a id="org774bb92"></a> <b>req-i-03</b>: <code>!v​+</code> (define variable and assign it top of stack) does not consume the top of the stack</h4>
<div class="outline-text-4" id="text-orgead51ed">
<p>
Otherwise the following section of the example would not be correct
</p>
<ul class="org-ul">
<li>push of value in stack variable <code>!c</code> would result in a stack of <code>[4]</code> if <code>!v1+</code> consumed to top, but the example shows:</li>
</ul>
<div class="org-src-container">
<pre class="src src-clj"><span class="linenr">5: </span>(invoke&gt; + 2) <span style="color: #767283; font-style: italic;">; 3</span>
<span class="linenr">6: </span>!v1+ <span style="color: #767283; font-style: italic;">; 3</span>
<span class="linenr">7: </span>!c <span style="color: #767283; font-style: italic;">; 3 4</span>
</pre>
</div>
<p>
<code>!v2+</code> would leave the stack at <code>[3]</code> if assignment consumed the top.  This would cause <code>(invoke&gt; = 2)</code> to fail, as the stack would have would  only one value, but the example shows:
</p>
<div class="org-src-container">
<pre class="src src-clj"><span class="linenr">11: </span>(invoke&gt; * 2) <span style="color: #767283; font-style: italic;">; 3 8</span>
<span class="linenr">12: </span>!v2+ <span style="color: #767283; font-style: italic;">; 3 8</span>
<span class="linenr">13: </span>(invoke&gt; = 2) <span style="color: #767283; font-style: italic;">; false</span>
</pre>
</div>
<hr />
</div>
</div>
<div id="outline-container-orgb27fafd" class="outline-4">
<h4 id="orgb27fafd"><span class="done DONE">DONE</span> <a id="orgf278cac"></a> <b>req-i-04</b>: <code>(invoke&gt; fun n)</code> applies n items off the top of the stack in stack order (i.e. reverse of underlying vector's order)</h4>
<div class="outline-text-4" id="text-orgb27fafd">
<p>
This is not explicitly stated in the assignment.  And it is not evident in the example, where all invoked functions are either associative functions (<code>+</code>, <code>*</code>, and <code>=</code>) with arity=2, or are only given n=1 (e.g. <code>println</code>).  But I find this an implicit requirement of stack logic.  If an invoked function of one argument takes its argument from the top of the stack, then a function of two should take its first from the top, pop the stack, then take its next from the new top.  Internally, this is accomplished with the <code>apply</code> of the reverse (through <code>rseq</code>) of the <code>subvec</code> of the last <code>n</code> items in the stack.
</p>
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-i-04</span> [] 1 2 3 4 (invoke&gt; println 4))
(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-i-04 )

(f-req-i-04)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; 4 3 2 1</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org224c118" class="outline-4">
<h4 id="org224c118"><span class="done DONE">DONE</span> <a id="org5ff4bd3"></a> <b>req-i-05</b>: <code>(invoke&gt; fun n)</code> for the sake of consistency, the return value of invoke should be <i>constant</i> (i.e. self-evaluating)</h4>
<div class="outline-text-4" id="text-org224c118">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-i-05</span> [!a !b !c] !a !b !c (invoke&gt; vector 3))

(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-i-05 )


(f-req-i-05 1 2 3)
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">RUNTIME ERRORS:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     `(invoke&gt; vector 3)' at op[3] node[3]:</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">              `(apply #'clojure.core/vector (3 2 1))' =&gt; `[3 2 1]' with *stax-require-simple-stack-values* = true</span>
(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">stackfn-produced-runtime-error</span> )

(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (f-req-i-05 1 2 3)
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))
(=&gt;
 [<span style="color: #ff7fff;">"Runtime Errors"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:error-text</span> <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">RUNTIME ERRORS:</span><span style="color: #ffffff; font-weight: bold;">\n\t</span><span style="color: #ff7fff;">`(invoke&gt; vector 3)' at op[3] node[3]:</span><span style="color: #ffffff; font-weight: bold;">\n\t\t</span><span style="color: #ff7fff;"> `(apply #'clojure.core/vector (3 2 1))' =&gt; `[3 2 1]' with *stax-require-simple-stack-values* = true</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>,
   <span style="color: #34c8d8; font-weight: bold;">:error-data</span> [[<span style="color: #ff7fff;">"RUNTIME ERRORS:"</span> [{<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=exec</span>,
                                               <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=runtime-invoke-returned-complex-val</span>,
                                               <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"`(apply #'clojure.core/vector (3 2 1))' =&gt; `[3 2 1]' with *stax-require-simple-stack-values* = true"</span>}],
                                     <span style="color: #34c8d8; font-weight: bold;">:invoke-val</span> [3 2 1],
                                     <span style="color: #34c8d8; font-weight: bold;">:needs</span> 3,
                                     <span style="color: #34c8d8; font-weight: bold;">:fun</span> vector,
                                     <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span>],
                                     <span style="color: #34c8d8; font-weight: bold;">:invoke-args</span> (3 2 1),
                                     <span style="color: #34c8d8; font-weight: bold;">:trace</span> [{<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                                              <span style="color: #34c8d8; font-weight: bold;">:dot-opts</span> {<span style="color: #34c8d8; font-weight: bold;">:shape</span> <span style="color: #34c8d8; font-weight: bold;">:point</span>},
                                              <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [],
                                              <span style="color: #34c8d8; font-weight: bold;">:delta</span> 0,
                                              <span style="color: #34c8d8; font-weight: bold;">:stack</span> [],
                                              <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [],
                                              <span style="color: #34c8d8; font-weight: bold;">:branch</span> <span style="color: #34c8d8; font-weight: bold;">:start</span>,
                                              <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1,
                                                        !b 2,
                                                        !c 3},
                                              <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=start</span>}
                                             {<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                                              <span style="color: #34c8d8; font-weight: bold;">:op</span> !a,
                                              <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [0],
                                              <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                                              <span style="color: #34c8d8; font-weight: bold;">:stack</span> [1],
                                              <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [0],
                                              <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1,
                                                        !b 2,
                                                        !c 3},
                                              <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                                              <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !a}
                                             {<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                                              <span style="color: #34c8d8; font-weight: bold;">:op</span> !b,
                                              <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [1],
                                              <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                                              <span style="color: #34c8d8; font-weight: bold;">:stack</span> [1 2],
                                              <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [1],
                                              <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1,
                                                        !b 2,
                                                        !c 3},
                                              <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                                              <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !b}
                                             {<span style="color: #34c8d8; font-weight: bold;">:needs</span> 0,
                                              <span style="color: #34c8d8; font-weight: bold;">:op</span> !c,
                                              <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [2],
                                              <span style="color: #34c8d8; font-weight: bold;">:delta</span> 1,
                                              <span style="color: #34c8d8; font-weight: bold;">:stack</span> [1 2 3],
                                              <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [2],
                                              <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1,
                                                        !b 2,
                                                        !c 3},
                                              <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=push-var</span>,
                                              <span style="color: #34c8d8; font-weight: bold;">:var-ref</span> !c}
                                             {<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=exec</span>,
                                                        <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=runtime-invoke-returned-complex-val</span>,
                                                        <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"`(apply #'clojure.core/vector (3 2 1))' =&gt; `[3 2 1]' with *stax-require-simple-stack-values* = true"</span>}],
                                              <span style="color: #34c8d8; font-weight: bold;">:invoke-val</span> [3 2 1],
                                              <span style="color: #34c8d8; font-weight: bold;">:needs</span> 3,
                                              <span style="color: #34c8d8; font-weight: bold;">:fun</span> vector,
                                              <span style="color: #34c8d8; font-weight: bold;">:invoke-args</span> (3 2 1),
                                              <span style="color: #34c8d8; font-weight: bold;">:invoke-apply</span> (apply <span style="color: #9fcb66;">#'clojure.core</span>/vector (3 2 1)),
                                              <span style="color: #34c8d8; font-weight: bold;">:op</span> (invoke&gt; vector 3),
                                              <span style="color: #34c8d8; font-weight: bold;">:invoke-fn</span> <span style="color: #9fcb66;">#'clojure.core</span>/vector,
                                              <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [3],
                                              <span style="color: #34c8d8; font-weight: bold;">:delta</span> -2,
                                              <span style="color: #34c8d8; font-weight: bold;">:arity</span> 3,
                                              <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [3],
                                              <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=invoke</span>}],
                                     <span style="color: #34c8d8; font-weight: bold;">:invoke-apply</span> (apply <span style="color: #9fcb66;">#'clojure.core</span>/vector (3 2 1)),
                                     <span style="color: #34c8d8; font-weight: bold;">:op</span> (invoke&gt; vector 3),
                                     <span style="color: #34c8d8; font-weight: bold;">:invoke-fn</span> <span style="color: #9fcb66;">#'clojure.core</span>/vector,
                                     <span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 1,
                                                    !b 2,
                                                    !c 3},
                                     <span style="color: #34c8d8; font-weight: bold;">:node-index</span> [3],
                                     <span style="color: #34c8d8; font-weight: bold;">:delta</span> -2,
                                     <span style="color: #34c8d8; font-weight: bold;">:arity</span> 3,
                                     <span style="color: #34c8d8; font-weight: bold;">:op-index</span> [3],
                                     <span style="color: #34c8d8; font-weight: bold;">:op-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.node</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">op=invoke</span>}]]]}]
 )

</pre>
</div>
</div>
</div>
<div id="outline-container-org4f51d75" class="outline-4">
<h4 id="org4f51d75"><span class="done DONE">DONE</span> <a id="org157562f"></a> <b>req-i-06</b>: <code>(invoke&gt; fun n)</code> for the sake of consistency, values passed to the defstackfn defined function should be <i>constant</i> (i.e. self-evaluating)</h4>
<div class="outline-text-4" id="text-org4f51d75">
<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f-req-i-05</span> [!a !b !c] !a !b !c (invoke&gt; println 3))

(=&gt; <span style="color: #9fcb66;">#'user</span>/f-req-i-05 )


(f-req-i-05 1 [<span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:c</span>] 3)

<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; Complex args are forbidden: arg#1:[:a :b :c]</span>

(=&gt; <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">stackfn-complex-args-forbidden</span> )

(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-throw-on-error*</span> <span style="color: #34c8d8; font-weight: bold;">true</span>]
  (<span style="color: #ffff0b;">try</span> (f-req-i-05 1 [<span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:b</span>] 3)
       (<span style="color: #ffff0b;">catch</span> Exception e [(ex-message e)
                           (ex-data e)])))

(=&gt;
 [<span style="color: #ff7fff;">"Complex args are forbidden: arg#1:[:a :b :b]"</span>
  {<span style="color: #34c8d8; font-weight: bold;">:complex-args</span> ([1 [<span style="color: #34c8d8; font-weight: bold;">:a</span> <span style="color: #34c8d8; font-weight: bold;">:b</span> <span style="color: #34c8d8; font-weight: bold;">:b</span>]])}]
)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgf6e95db" class="outline-4">
<h4 id="orgf6e95db"><span class="done DONE">DONE</span> <a id="org2f358e0"></a> <b>req-i-07</b>: <code>kdh.stax.core/defstackfn</code> creates a named function that returns the remaining stack as a vector</h4>
<div class="outline-text-4" id="text-orgf6e95db">
<p>
Internally, I represent the stack as a vector whose rightmost value is its top.  This choice is idiomatic because <code>clojure.core/pop</code> of a vector returns a vector like it's argument, but without the last item.  I note that none of the stack state comments in the given example show any enclosing structure.  And they all treat the right-most as the top.  Of course, there is nothing preventing the choice of a list or queue, as pop works on those. It is just my reasoned and experience choice to use a vector.
Further, I return the stack and not its top because that would destroy important information (the rest of the stack).  As a general principle, I do not believe in descarding valid data &#x2013; the final state of the stack is useful in debugging.  And if the user wishes to only have the top, they can always peek it.  If I only return the top, however, the user cannot access (or even be aware of) the remaining discarded stack.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgafe3191" class="outline-2">
<h2 id="orgafe3191">Using <code>defstackfn</code></h2>
<div class="outline-text-2" id="text-orgafe3191">
</div>
<div id="outline-container-org27b0d75" class="outline-3">
<h3 id="org27b0d75"><code>&lt;name&gt;</code>: the named function defined by <code>defstackfn</code></h3>
<div class="outline-text-3" id="text-org27b0d75">
<p>
As required (see <a href="#orgf5f1f21">Requirements</a>), <code>(defstackfn &lt;name&gt; &lt;declarations&gt; &lt;operations&gt;...)</code>
defines a function of name <code>&lt;name&gt;</code> that takes a vector of !v like <code>&lt;declarations&gt;</code> and any number of <code>&lt;operations&gt;</code>.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">defstackfn</span> <span style="color: #ff996f;">f</span>
  [!a !b !c]
  !a
  !b
  (invoke&gt; + 2)
  !v1+
  !c
  !c
  &lt;pop&gt;
  2
  (invoke&gt; * 2)
  !v2+
  (invoke&gt; = 2)
  (if&gt;
    !v1
    !v2
    (invoke&gt; - 2)
   else&gt;
    <span style="color: #ff7fff;">"false!!"</span>
    (invoke&gt; println 1)
    &lt;pop&gt;
    !v1
    !v2
    (invoke&gt; * 2)
    )
  )

(=&gt; <span style="color: #9fcb66;">#'user</span>/f )
</pre>
</div>

<p>
Calling the newly created function with the 3 args in the example gives the expected output and return value.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>RPL Example as a function call to the <code>defstackfn</code> defined <code>f</code></label><pre class="src src-clojure">(f 1 2 4)

<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; false!!</span>

(=&gt; [24] )
</pre>
</div>

<p>
This is implemented in the <code>defstackfn</code> macro expansion as a call to <code>kdh.stax.core/stackfn</code> whose first argument is the node-data that &lt;name&gt; closes over, and whose remaining arguments are the values you give <code>defstackfn</code> defined function.
</p>

<p>
<code>stackfn</code> can be called using <code>kdh.stax.nodify/build-node-data</code> to achieve the same results as the named function:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>RPL Example as a function call to <code>kdh.stax.core/stackfn</code></label><pre class="src src-clojure">(stackfn (build-node-data '[!a !b !c]
                           <span style="color: #9fcb66;">ex</span>/ops-rpl-example)
          1 2 4)

<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt; false!!</span>

(=&gt; [24] )
</pre>
</div>
</div>
</div>

<div id="outline-container-org0c412a0" class="outline-3">
<h3 id="org0c412a0"><code>&lt;name&gt;-dbg</code>: the debug function defined by <code>defstackfn</code></h3>
<div class="outline-text-3" id="text-org0c412a0">
<p>
In addition, <code>kdh.stax.core/defstackfn</code> also defines a function named <code>&lt;name&gt;-dbg</code> (in the example, <code>f-dbg</code>), which when called with no arguments, returns the node-data as a map. This is the same node data that <code>f</code> closes over, hence the name <code>f-dbg</code>.
</p>

<p>
Like the named function <code>&lt;name&gt;</code> (in the example, <code>f</code>), <code>&lt;name&gt;-dbg</code> can take arguments of the the same number as the <code>declarations</code> given to <code>defstackfn</code>.  Called with arguments, <code>&lt;name&gt;-dbg</code> returns the node-data with an extra key <code>:results</code>. <code>&lt;name&gt;-dbg</code> can take arguments in any number that is a multiple of <code>declarations</code>, returning for results (allowing the user to simulate multiple calls to <code>name</code> function with different values).
</p>

<p>
Here is the structure of <code>:results</code>
</p>

<dl class="org-dl">
<dt><code>:results</code></dt><dd>a vector of result maps
<ul class="org-ul">
<li>a result map is the last op node executed in one of the runs, with the following additional keys:
<dl class="org-dl">
<dt><code>:errors</code></dt><dd>if present a vector of runtime errors for the last node in the result.</dd>
<dt><code>:output</code></dt><dd>a string of the output ("false!!" in the RPL example)</dd>
<dt><code>:trace</code></dt><dd>a vector of nodes passed through from start of the execution to this node</dd>
<dt><code>:stack</code></dt><dd>the final value of the stack (<code>[24]</code> in the RPL example)
<ul class="org-ul">
<li><code>:stack</code> is not present if <code>:errors</code> is present, as <code>stack</code> is the value after executing the result node
<ul class="org-ul">
<li>to find the last good state of <code>stack</code> if the result has <code>:errors</code>, peek the pop of <code>:trace</code></li>
</ul></li>
</ul></dd>
<dt><code>:turns</code></dt><dd>like the path turns, a vector of strings describing the branches passed through until the result node</dd>
<dt><code>:var-init-map</code></dt><dd>the map of the declarations given to the execution that ends in the result node</dd>
<dt><code>:var-map</code></dt><dd>the map of the current variable bindings
<ul class="org-ul">
<li><code>:var-map</code> is not present if <code>:errors</code> is present
<ul class="org-ul">
<li>peek the pop of <code>:trace</code> for the last good value of <code>:var-map</code></li>
</ul></li>
</ul></dd>
</dl></li>
</ul></dd>
</dl>



<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>RPL Example as a function call to the <code>defstackfn</code> defined <code>f-dbg</code></label><pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;&gt;</span> (f-dbg 1 2 4)
     <span style="color: #34c8d8; font-weight: bold;">:results</span>
     (mapv #(select-keys <span style="color: #4ac964;">%</span> [<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> <span style="color: #34c8d8; font-weight: bold;">:var-map</span> <span style="color: #34c8d8; font-weight: bold;">:turns</span> <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #34c8d8; font-weight: bold;">:stack</span>])))

(=&gt; [{<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 1, !b 2, !c 4},
      <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1, !b 2, !c 4, !v1 3, !v2 8},
      <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span>],
      <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #ff7fff;">"false!!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>,
      <span style="color: #34c8d8; font-weight: bold;">:stack</span> [24]}] )


<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">AND WITH MULTIPLE RUNS</span>

(<span style="color: #ffff0b;">-&gt;&gt;</span> (f-dbg 1 2 4
            3 3 3)
     <span style="color: #34c8d8; font-weight: bold;">:results</span>
     (mapv #(select-keys <span style="color: #4ac964;">%</span> [<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> <span style="color: #34c8d8; font-weight: bold;">:var-map</span> <span style="color: #34c8d8; font-weight: bold;">:turns</span> <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #34c8d8; font-weight: bold;">:stack</span>])))

(=&gt; [{<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 1, !b 2, !c 4},
      <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1, !b 2, !c 4, !v1 3, !v2 8},
      <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span>],
      <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #ff7fff;">"false!!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>, <span style="color: #34c8d8; font-weight: bold;">:stack</span> [24]}
     {<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 3, !b 3, !c 3},
      <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 3, !b 3, !c 3, !v1 6, !v2 6},
      <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span>],
      <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #ff7fff;">""</span>, <span style="color: #34c8d8; font-weight: bold;">:stack</span> [0]}] )
</pre>
</div>

<p>
Like with the relationship between the <code>defstackfn</code> defined function <code>f</code> and its call to <code>stackfn</code> with the node-data closure, <code>&lt;name&gt;-dbg</code> also calls its own helper function, <code>stackfn-dbg</code>.  And we can use that to debug without touching <code>defstackfn</code>.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>RPL Example as a function call to <code>kdh.stax.core/stackfn-dbg</code></label><pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;&gt;</span> (stackfn-dbg
      (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-rpl-example)
      1 2 4
      3 3 3)
     <span style="color: #34c8d8; font-weight: bold;">:results</span>
     (mapv #(select-keys <span style="color: #4ac964;">%</span> [<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> <span style="color: #34c8d8; font-weight: bold;">:var-map</span> <span style="color: #34c8d8; font-weight: bold;">:turns</span> <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #34c8d8; font-weight: bold;">:stack</span>])))

(=&gt; [{<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 1, !b 2, !c 4},
      <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 1, !b 2, !c 4, !v1 3, !v2 8},
      <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span>],
      <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #ff7fff;">"false!!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>,
      <span style="color: #34c8d8; font-weight: bold;">:stack</span> [24]}
     {<span style="color: #34c8d8; font-weight: bold;">:var-init-map</span> {!a 3, !b 3, !c 3},
      <span style="color: #34c8d8; font-weight: bold;">:var-map</span> {!a 3, !b 3, !c 3, !v1 6, !v2 6},
      <span style="color: #34c8d8; font-weight: bold;">:turns</span> [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span>],
      <span style="color: #34c8d8; font-weight: bold;">:output</span> <span style="color: #ff7fff;">""</span>, <span style="color: #34c8d8; font-weight: bold;">:stack</span> [0]}] )
</pre>
</div>

<hr />
<p>
Now that we've played with the results of <code>defstackfn</code> and its helper functions, lets explore the node-data
</p>
</div>
</div>
</div>

<div id="outline-container-orgce7e3e8" class="outline-2">
<h2 id="orgce7e3e8">Nodes</h2>
<div class="outline-text-2" id="text-orgce7e3e8">
<p>
nodes are maps, describing an operation and its properties
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> Operations, Nodes, and Their Predicates</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operation</th>
<th scope="col" class="org-left">Op Predicate</th>
<th scope="col" class="org-left">Node <code>:op-type</code></th>
<th scope="col" class="org-left">Node Predicate</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">!v</td>
<td class="org-left">!symbol?</td>
<td class="org-left">::op=push-var</td>
<td class="org-left">push-var-node?</td>
<td class="org-left">op to push the value of a stack variable onto the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">const</td>
<td class="org-left">self-evaluating?</td>
<td class="org-left">::op=push-sef</td>
<td class="org-left">push-sef-node?</td>
<td class="org-left">op to push the value of a self evaluating form onto the stack (number, string, character, keyword, boolean, nil)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;pop&gt;</td>
<td class="org-left">&lt;pop&gt;?</td>
<td class="org-left">::op=pop</td>
<td class="org-left">pop-node?</td>
<td class="org-left">op to pop the top of the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">!v+</td>
<td class="org-left">!symbol+?</td>
<td class="org-left">::op=def-var</td>
<td class="org-left">def-var-node?</td>
<td class="org-left">op to define a (possibly new) stack variable and assign it the top of the stack without changing the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(invoke&gt; f n)</td>
<td class="org-left">invoke&gt;?</td>
<td class="org-left">::op=invoke</td>
<td class="org-left">invoke-node?</td>
<td class="org-left">op to invoke a function (f) on a number (n) of stack values. Those n values are removed from the stack and the return value of f pushed onto the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(if&gt;&#x2026; else&gt;&#x2026;)</td>
<td class="org-left">if&gt;?</td>
<td class="org-left">::op=if</td>
<td class="org-left">if-node?</td>
<td class="org-left">op to branch conditionally into :then or :else based on the thruthiness of the top of the stack.  The top of the stack is pop'd. :then and :else are vectors of nodes</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">any other form</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">::op=illegal</td>
<td class="org-left">illegal-node?</td>
<td class="org-left">not a legal op</td>
</tr>
</tbody>
</table>

<p>
Each legal op node requires 0 or more stack values (its <code>:needs</code>), and changes the size of the stack by some integer number (its <code>:delta</code>)
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> Node and Their Effect on the Stack</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Node <code>:op-type</code></th>
<th scope="col" class="org-right">:needs</th>
<th scope="col" class="org-right">:delta</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">::op=push-var</td>
<td class="org-right">0</td>
<td class="org-right">+1</td>
</tr>

<tr>
<td class="org-left">::op=push-sef</td>
<td class="org-right">0</td>
<td class="org-right">+1</td>
</tr>

<tr>
<td class="org-left">::op=pop</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
</tr>

<tr>
<td class="org-left">::op=def-var</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">::op=invoke</td>
<td class="org-right">n</td>
<td class="org-right">-(n-1)</td>
</tr>

<tr>
<td class="org-left">::op=if</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
</tr>

<tr>
<td class="org-left">::op=illegal</td>
<td class="org-right">NA</td>
<td class="org-right">NA</td>
</tr>
</tbody>
</table>

<p>
Each op node has some of the keys.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 3:</span> Node Keys</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">KEY</th>
<th scope="col" class="org-left">VALUE</th>
<th scope="col" class="org-left">OPTIONALITY</th>
<th scope="col" class="org-left">DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>:op</code></td>
<td class="org-left">expr</td>
<td class="org-left">All nodes</td>
<td class="org-left">the operation as a quoted value</td>
</tr>

<tr>
<td class="org-left"><code>:op-type</code></td>
<td class="org-left">key</td>
<td class="org-left">All nodes</td>
<td class="org-left">See operation table</td>
</tr>

<tr>
<td class="org-left"><code>:needs</code></td>
<td class="org-left">int &gt;= 0</td>
<td class="org-left">All legal</td>
<td class="org-left">how many stack values the operation requires</td>
</tr>

<tr>
<td class="org-left"><code>:delta</code></td>
<td class="org-left">int</td>
<td class="org-left">All legal</td>
<td class="org-left">the change to the stack size after execution of the node</td>
</tr>

<tr>
<td class="org-left"><code>:op-index</code></td>
<td class="org-left">vector</td>
<td class="org-left">All nodes</td>
<td class="org-left">vector of pos-int to the operation in the original sequence</td>
</tr>

<tr>
<td class="org-left"><code>:node-index</code></td>
<td class="org-left">vector</td>
<td class="org-left">All nodes</td>
<td class="org-left">vector of pos-int to the operation in the resulting node-tree</td>
</tr>

<tr>
<td class="org-left"><code>:fun</code></td>
<td class="org-left">fn?</td>
<td class="org-left">invoke&gt;</td>
<td class="org-left">function value of invoke&gt; operation</td>
</tr>

<tr>
<td class="org-left"><code>:arity</code></td>
<td class="org-left">pos-int?</td>
<td class="org-left">invoke&gt;</td>
<td class="org-left">number of stack items the invoke&gt; :fun will consume (same as needs)</td>
</tr>

<tr>
<td class="org-left"><code>:then</code></td>
<td class="org-left">vector of nodes</td>
<td class="org-left">if&gt;</td>
<td class="org-left">a node subtree to follow if the top of the stack is truthy</td>
</tr>

<tr>
<td class="org-left"><code>:else</code></td>
<td class="org-left">vector of nodes</td>
<td class="org-left">if&gt;</td>
<td class="org-left">a node subtree to follow if the top of the stack is falsey</td>
</tr>

<tr>
<td class="org-left"><code>:var-ref</code></td>
<td class="org-left">!v</td>
<td class="org-left">def-var push-var</td>
<td class="org-left">!v form symbol for stack variable</td>
</tr>

<tr>
<td class="org-left"><code>:var-def</code></td>
<td class="org-left">!v+</td>
<td class="org-left">def-var</td>
<td class="org-left">!v+ form for stack variable (::op=def-var only)</td>
</tr>

<tr>
<td class="org-left"><code>:branch</code></td>
<td class="org-left">keyword</td>
<td class="org-left">start if-pop termn</td>
<td class="org-left">Represents path start, turn , and end</td>
</tr>

<tr>
<td class="org-left"><code>:errors</code></td>
<td class="org-left">vector of maps</td>
<td class="org-left">Any</td>
<td class="org-left">(See <a href="#org39cecb6">Errors</a>)</td>
</tr>
</tbody>
</table>




<p>
Internally, nodes are created by <code>kdh.stax.nodify/nodify-ops</code>, which returns a node-tree.
Operationally, build-node-data takes the declarations and operations arguments of defstackfn and returns a map of node data.
</p>
</div>
</div>

<div id="outline-container-org9f786f9" class="outline-2">
<h2 id="org9f786f9">Node Data</h2>
<div class="outline-text-2" id="text-org9f786f9">
<p>
The node data generated by <code>kdh.stax.nodify/build-node-data</code> is a map that contains the following keys:
</p>
<dl class="org-dl">
<dt><code>:declarations</code></dt><dd>The declarations vector passed to <code>defstackfn</code></dd>
<dt><code>:operations</code></dt><dd>The operations sequence passed to <code>defstackfn</code></dd>
<dt><code>:node-tree</code></dt><dd><ul class="org-ul">
<li>A vector of <a href="#orgce7e3e8">nodes</a> with <code>if&gt;</code> nodes containing <code>:then</code> and <code>:else</code> subtrees</li>
</ul></dd>
<dt><code>:nodes</code></dt><dd><ul class="org-ul">
<li>The node-tree flattened into a vector of nodes.</li>
<li>Because this is derived from the node-tree, it contains all of the parse errors (illegal ops, and malformed invoke&gt;).</li>
<li>It is used to inject tree errors into the <a href="#org6b3c31f">visualization</a></li>
</ul></dd>
<dt><code>:paths</code></dt><dd><ul class="org-ul">
<li>All of the traversable paths through the node-tree as a vector of vectors of nodes
(the outer vector is the paths, and an inner vector is a single path).</li>
<li>Each path begins with a start node and ends with a terminal node.</li>
<li><code>if&gt;</code> nodes in the tree become <code>if-pop</code> nodes in the path with a branch key <code>:branch</code> recording the branch taken (<code>:then</code> or <code>:else</code>)</li>
<li>Paths are in then-over-else order, meaning the first path is all <code>:then</code> branches, the last is all <code>:else</code> branches. See <a href="#orgb5bb2b4">Sorting Paths</a></li>
</ul></dd>
<dt><code>:turns</code></dt><dd><ul class="org-ul">
<li>A vector of vectors of strings, turns is one-for-one matched to paths, such that each turn vector has the same index in turns as its path has in paths.
<ul class="org-ul">
<li>as an example, there are two turn vectors in the node-data for the rpl example ops, which has a single <code>if&gt;</code>
<ul class="org-ul">
<li>["start" "then" "term"]</li>
<li>["start" "else" "term"]</li>
</ul></li>
<li>Used to name the visualization for each path and uniquely identify paths</li>
</ul></li>
</ul></dd>
<dt>:errors-for-print</dt><dd><ul class="org-ul">
<li>a vector of errors found through parsing (of <code>:node-tree</code>) and static analysis (of <code>:paths</code>)</li>
</ul></dd>
</dl>

<hr />
</div>
</div>

<div id="outline-container-org39cecb6" class="outline-2">
<h2 id="org39cecb6">Errors</h2>
<div class="outline-text-2" id="text-org39cecb6">
<p>
At its simplest, an error is a map of keys:
</p>
<dl class="org-dl">
<dt><code>:err-zone</code></dt><dd>Where/When the error occurred (e.g. <code>:kdh.stax.errs/zone=tree</code>)</dd>
<dt><code>:err-type</code></dt><dd>A richly descriptive keyword (e.g. <code>:kdh.stax.errs/error=parse-illegal-operation</code>)</dd>
<dt><code>:err-text</code></dt><dd>A string describing the error (e.g. <code>"&lt;clear&gt; is not an allowed op"</code>)</dd>
</dl>

<p>
Errors are added to a node with <code>:kdh.stax.errs/error+</code> which adds an <code>:errors</code> key if necessary
</p>

<div class="org-src-container">
<pre class="src src-clojure">(require '[kdh.stax.node <span style="color: #34c8d8; font-weight: bold;">:refer</span> [start-node]]
         '[kdh.stax.errs <span style="color: #34c8d8; font-weight: bold;">:refer</span> [error+] <span style="color: #34c8d8; font-weight: bold;">:as</span> err])

(<span style="color: #ffff0b;">-&gt;</span> {}
    (error+ {<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">::</span><span style="color: #9fcb66;">err</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=mom</span>
             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">::</span><span style="color: #9fcb66;">err</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=stop-hitting-your-brother</span>
             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"Hands are for holding, not hitting."</span>})
    (error+ {<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">::</span><span style="color: #9fcb66;">err</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=dad</span>
             <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">::</span><span style="color: #9fcb66;">err</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=listen-to-your-mother</span>
             <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"I swear to god, I will pull this car over!"</span>}))

(=&gt; {<span style="color: #34c8d8; font-weight: bold;">:errors</span> [{<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=mom</span>,
               <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=stop-hitting-your-brother</span>,
               <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"Hands are for holding, not hitting."</span>}
              {<span style="color: #34c8d8; font-weight: bold;">:err-zone</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">zone=dad</span>,
               <span style="color: #34c8d8; font-weight: bold;">:err-type</span> <span style="color: #34c8d8; font-weight: bold;">:</span><span style="color: #9fcb66;">kdh.stax.errs</span><span style="color: #cfccd2; background-color: #25202a;">/</span><span style="color: #34c8d8; font-weight: bold;">error=listen-to-your-mother</span>,
               <span style="color: #34c8d8; font-weight: bold;">:err-text</span> <span style="color: #ff7fff;">"I swear to god, I will pull this car over!"</span>}]} )
</pre>
</div>
</div>

<div id="outline-container-org7985061" class="outline-3">
<h3 id="org7985061">Error Zones</h3>
<div class="outline-text-3" id="text-org7985061">
<p>
There are three zones of stax errors, each representing a phase of error analysis
</p>
</div>
<div id="outline-container-orgea8b659" class="outline-4">
<h4 id="orgea8b659">Parse Errors</h4>
<div class="outline-text-4" id="text-orgea8b659">
<p>
Some operations are always erroneous.
</p>
<ul class="org-ul">
<li><code>!v3+</code> is a legal operation</li>
<li><code>v3</code> is not ever a legal operation, regardless of where it occurs in the tree.</li>
</ul>
<p>
Such errors have the following facts:
</p>
<ul class="org-ul">
<li>They have <code>:err-zone</code> key with value <code>:kdh.stax.errs/zone=tree</code></li>
<li>They have <code>:err-type</code> key with value <code>:kdh.stax.errs/error=parse-&lt;something&gt;</code></li>
<li>They are created during the conversion of an operation into an op node in by <code>kdh.stax.nodify/nodify-op</code> and <code>kdh.stax.nodify/nodify-ops</code></li>
<li>They are present in nodes within the <code>:node-tree</code>, <code>:nodes</code>, and <code>:paths</code> keys of the node-data</li>
</ul>
</div>
</div>

<div id="outline-container-org0c08143" class="outline-4">
<h4 id="org0c08143">Static Path Analysis Errors</h4>
<div class="outline-text-4" id="text-org0c08143">
<p>
Other errors are only true within a given context of traversal &#x2013; within a path:
</p>
<ul class="org-ul">
<li>the same op <code>!v3</code> could be valid or invalid depending on whether <code>!v3+</code> is present earlier in the path.</li>
</ul>
<p>
Such errors have the following facts:
</p>
<ul class="org-ul">
<li>They have <code>:err-zone</code> key with value <code>:kdh.stax.errs/zone=path</code></li>
<li>They have <code>:err-type</code> key with value <code>:kdh.stax.errs/error=static-&lt;something&gt;</code></li>
<li>They are created during the static analysis (iff <code>*stax-perform-static-analysis*</code> is bound to <code>true</code>, the default) by <code>kdh.stax.nodify/check-refs-in-path</code> and <code>kdh.stax.nodify/count-card-in-path</code></li>
<li>They are present in nodes within the <code>:paths</code> key of the node-data</li>
</ul>
</div>
</div>

<div id="outline-container-orgab7b54d" class="outline-4">
<h4 id="orgab7b54d">Runtime Errors</h4>
<div class="outline-text-4" id="text-orgab7b54d">
<p>
Finally, some errors can only occur within the context of evaluation (which is a traversal of the node-tree with values given to <code>stackfn</code> or <code>stackfn-dbg, or the ~defstackfn</code> defined functions that call them)
</p>
<ul class="org-ul">
<li><code>(invoke&gt;</code> + 2) will fail at runtime if either or both of the top two values on the stack are not numbers</li>
</ul>
<p>
Such errors have the following facts:
</p>
<ul class="org-ul">
<li>They have <code>:err-zone</code> key with value <code>:kdh.stax.errs/zone=exec</code></li>
<li>They have <code>:err-type</code> key with value <code>:kdh.stax.errs/error=runtime-&lt;something&gt;</code></li>
<li>They are created during the execution of nodes via <code>kdh.stax.nodify/exec-nodes</code>, which stops execution at the first node with errors.</li>
<li>They are present in nodes within the <code>:results</code> key of the node-data</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6a61ff3" class="outline-3">
<h3 id="org6a61ff3">Error Types</h3>
<div class="outline-text-3" id="text-org6a61ff3">
<p>
Error type are richly descriptive, namespaced keywords.
Richly descriptive means that their names contain multiple parts that allow them easily distinguished out of context.
On their own, <code>:error=runtime-illegal-operation</code> and <code>:error=parse-illegal-operation</code> tell you more than <code>:error=illegal-operation</code>.
</p>

<p>
And <code>:error=runtime-&lt;something&gt;</code> is easily targeted by tooling (e.g. grep emacs/occur) and css matching.
For example, here is a list of all of the errors found by grep'ing 'error=':
</p>

<div class="org-src-container">
<pre class="src src-shell">find ~/clj/rpl/stax/src/clj/kdh/stax/ -type f -name <span style="color: #ff7fff;">'*.clj'</span> -print0 | xargs -0 grep <span style="color: #4ac964;">error</span>= | tr <span style="color: #ff7fff;">'\011\042/:()'</span> <span style="color: #ff7fff;">' '</span> | tr -s <span style="color: #ff7fff;">' '</span> | tr <span style="color: #ff7fff;">' '</span> <span style="color: #ff7fff;">'\012'</span> | grep <span style="color: #4ac964;">error</span>= | sort | uniq
</pre>
</div>

<pre class="example" id="orgffb7fe1">
- error=parse-illegal-operation
- error=parse-invoke-arity-not-pos-int
- error=parse-invoke-fun-not-function
- error=parse-invoke-wrong-number-args
- error=runtime-arity-not-pos-int
- error=runtime-debug-needs-not-pos-int
- error=runtime-debug-op-not-sef
- error=runtime-debug-stack-is-empty
- error=runtime-debug-stack-is-not-a-vector
- error=runtime-debug-var-map-is-not-a-map
- error=runtime-illegal-operation
- error=runtime-insufficient-stack
- error=runtime-invoke-failed
- error=runtime-invoke-fun-not-function
- error=runtime-invoke-returned-complex-val
- error=runtime-invoke-wrong-number-args
- error=runtime-var-not-defined
- error=static-insufficient-stack
- error=static-var-not-defined
</pre>

<p>
In addition to its use in :err-type, I also use the pattern <code>:&lt;type&gt;=&lt;ordered-properties&gt;</code> for op-type values:
</p>
<ul class="org-ul">
<li><code>:op=if</code> (the <code>if&gt;</code> operation's node)</li>
<li><code>:op=if-pop</code> (the isolation of the <code>if&gt;</code> node's pop-like conditional)</li>
</ul>
</div>



<div id="outline-container-orgbf3ba06" class="outline-4">
<h4 id="orgbf3ba06"><code>:err-type</code> vs <code>err-zone</code></h4>
<div class="outline-text-4" id="text-orgbf3ba06">
<p>
Many erroneous conditions that are caught in either parsing or static analysis, also have runtime variants.  This is to allow for full runtime checking even in the presents of parse or static analyis error by binding the <code>*stax-errors-prevent-exec*</code> to <code>false</code> or <code>nil</code>.
</p>

<table id="orgd61b3d3" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 4:</span> Table of Node <code>:err-type</code> <code>:err-zone</code> interaction</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">zone=tree</th>
<th scope="col" class="org-left">zone=path</th>
<th scope="col" class="org-left">zone=exec</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">error=parse-…</th>
<th scope="col" class="org-left">error=static-…</th>
<th scope="col" class="org-left">error=runtime-…</th>
</tr>

<tr>
<th scope="col" class="org-left">op type</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">!v</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">var-not-defined</td>
<td class="org-left">var-not-defined</td>
</tr>

<tr>
<td class="org-left">!v+</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">insufficient-stack</td>
<td class="org-left">insufficient-stack</td>
</tr>

<tr>
<td class="org-left">&lt;pop&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">insufficient-stack</td>
<td class="org-left">insufficient-stack</td>
</tr>

<tr>
<td class="org-left">if&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">insufficient-stack</td>
<td class="org-left">insufficient-stack</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">invoke-wrong-number-args</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">invoke-wrong-number-args</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">invoke-fun-not-function</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">invoke-fun-not-function</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">arity-not-pos-int</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">arity-not-pos-int</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">insufficient-stack</td>
<td class="org-left">insufficient-stack</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">invoke-failed</td>
</tr>

<tr>
<td class="org-left">invoke&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">invoke-returned-complex-val</td>
</tr>

<tr>
<td class="org-left">NA</td>
<td class="org-left">illegal-operation</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">illegal-operation</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgdf51c01" class="outline-4">
<h4 id="orgdf51c01">Debugging Errors</h4>
<div class="outline-text-4" id="text-orgdf51c01">
<p>
Some errors should never occur &#x2013; their occurence indicates a serious flaw in the logic of the program.
</p>
<ul class="org-ul">
<li><code>kdh.stax.errs/error=runtime-debug-needs-not-pos-int</code></li>
<li><code>kdh.stax.errs/error=runtime-debug-op-not-sef</code></li>
<li><code>kdh.stax.errs/error=runtime-debug-stack-is-empty</code></li>
<li><code>kdh.stax.errs/error=runtime-debug-stack-is-not-a-vector</code></li>
<li><code>kdh.stax.errs/error=runtime-debug-var-map-is-not-a-map</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgebf1377" class="outline-4">
<h4 id="orgebf1377">NodeFailure</h4>
<div class="outline-text-4" id="text-orgebf1377">
<p>
The multimethod <code>kdh.stax.node/stack-op-exec</code> takes a node and dispatches on <code>:op-type</code>.
To simplify error handling, it uses <a href="https://github.com/adambard/failjure">failjure</a>, a monadic library for errors.
In kdh.stax.errs, I define a <code>NodeFailure</code> record that implements the <code>failjure.core/HasFailed</code> protocol.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">defrecord</span> <span style="color: #9fcb66;">NodeFailure</span> [node err-msg]
  <span style="color: #9fcb66;">f</span>/HasFailed
  (failed? [self] <span style="color: #34c8d8; font-weight: bold;">true</span>)
  (message [self] (<span style="color: #34c8d8; font-weight: bold;">:err-msg</span> self)))
</pre>
</div>

<p>
<code>NodeFailure-&gt;</code> creates a new NodeFailure with the node and an err-msg.
</p>

<p>
The fail-node-if functions test and maybe fail conditions individually:
</p>
<ul class="org-ul">
<li><code>kdh.stax.errs/fail-node-if-var-ref-not-defined</code></li>
<li><code>kdh.stax.errs/fail-node-if-op-not-sef</code></li>
<li><code>kdh.stax.errs/fail-node-if-stack-not-vector</code></li>
<li><code>kdh.stax.errs/fail-node-if-stack-empty</code></li>
<li><code>kdh.stax.errs/fail-node-if-var-map-not-map</code></li>
<li><code>kdh.stax.errs/fail-node-if-needs-gt-stack</code></li>
<li><code>kdh.stax.errs/fail-node-if-invoke-fn-error</code></li>
<li><code>kdh.stax.errs/fail-node-if-invoke-wrong-number-args</code></li>
<li><code>kdh.stax.errs/fail-node-if-invoke-arity-error</code></li>
<li><code>kdh.stax.errs/fail-node-if-invoke-apply-error</code></li>
<li><code>kdh.stax.errs/fail-node-if-invoke-val-error</code></li>
</ul>
<p>
The fail-node-do functions test and maybe fail on the multiple fail-node-if conditions:
</p>
<ul class="org-ul">
<li><code>kdh.stax.errs/fail-node-do-pop</code></li>
<li><code>kdh.stax.errs/fail-node-do-push-sef</code></li>
<li><code>kdh.stax.errs/fail-node-do-push-var</code></li>
<li><code>kdh.stax.errs/fail-node-do-def-var</code></li>
<li><code>kdh.stax.errs/fail-node-do-invoke</code></li>
</ul>
<p>
The <code>kdh.stax.nodify/stack-op-exec</code> methods call the fail-node-do functions and (on failure) return the <code>NodeFailure</code>'s node without keys <code>:stack</code> <code>:var-map</code> and <code>:cardi</code> so that nodes with errors do not propagate exec state.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb4effd4" class="outline-2">
<h2 id="orgb4effd4">Dynamic Variables</h2>
<div class="outline-text-2" id="text-orgb4effd4">
<dl class="org-dl">
<dt><code>*stax-node-star-mode*</code></dt><dd><ul class="org-ul">
<li>default is false</li>
<li>If true, defstackfn generate the node-data closure from <code>kdh.stax.nodify/build-node-data*</code></li>
<li>experimental use only - build-node-data outperforms build-node-data*</li>
</ul></dd>
<dt><code>*stax-require-simple-stack-values*</code></dt><dd><ul class="org-ul">
<li>default is true</li>
<li>if true, checks arguments to defstackfn fn, and invoke return are simple &#x2013; i.e. self evaluating forms</li>
</ul></dd>
<dt><code>*stax-throw-on-error*</code></dt><dd><ul class="org-ul">
<li>default is false</li>
<li>if true, throw on error; if false, return error as a keyword</li>
</ul></dd>
<dt><code>*stax-defstackfn-fails-on-errors*</code></dt><dd><ul class="org-ul">
<li>default is true</li>
<li>if false, continue to the execution phase even though there are parse errors and/or static analysis errors</li>
<li>used for testing runtime equivalents of parse/static errors (see <a href="#orgd61b3d3">4</a>)</li>
</ul></dd>
<dt><code>*stax-perform-path-analysis*</code></dt><dd><ul class="org-ul">
<li>default is true</li>
<li>if true, defstackfn performs static path analysis</li>
</ul></dd>
<dt><code>*stax-default-dot-options*</code></dt><dd><ul class="org-ul">
<li>default</li>
<li>graph, node, and edge properties for dot generation</li>
</ul></dd>
</dl>

<div class="org-src-container">
<pre class="src src-shell" id="org9427499">find ~/clj/rpl/stax/src/clj/kdh/ -type f -name <span style="color: #ff7fff;">'*.clj'</span> -print0 | xargs -0 grep <span style="color: #ff7fff;">"\^:dynamic"</span> | sed <span style="color: #ff7fff;">'s%[^\*]\*[^\*]+\*cut -f2-3 -d\*</span>
</pre>
</div>

<pre class="example" id="orge5c1db0">
- stax-require-simple-stack-values*
- stax-throw-on-error*
- stax-perform-path-analysis*
- stax-errors-prevent-exec*
- node-star-mode* false)
- default-dot-options*
- unescape-at-dot* true)
</pre>

<p>
/home/keith/clj/rpl/stax/dev/clj/dev.clj:         (binding [*stack-variables-are-dynamic-scoped* true]
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic <b>stax-require-simple-stack-values</b>
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic <b>stax-throw-on-error</b>
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic <b>stax-perform-path-analysis</b>
/home/keith/clj/rpl/stax/src/clj/kdh.stax.errs.clj:(def ^:dynamic <b>stax-errors-prevent-exec</b>
/home/keith/clj/rpl/stax/src/clj/kdh/stax/nodes.clj:(def ^:dynamic <b>node-star-mode</b> false)
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:(def ^:dynamic <b>default-dot-options</b>
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:  "A dynamic var of default global dot options"
/home/keith/clj/rpl/stax/src/clj/kdh/stax/svg.clj:(def ^:dynamic <b>unescape-at-dot</b> true)
</p>
</div>
</div>

<div id="outline-container-org6b3c31f" class="outline-2">
<h2 id="org6b3c31f">Visualization</h2>
<div class="outline-text-2" id="text-org6b3c31f">
<p>
The node-data map returned by <code>kdh.stax.nodify/build-node-data</code> is large, and dificult to debug.
</p>
<p target="_blank">
<a href="https://github.com/djblue/portal" target="_blank">Portal</a> helped in diving into the data somewhat, but ever since I started working on this project, I wanted to display a graph of the op nodes in the <code>:node-tree</code> key of the node-data and I also wanted to visually represent overlays of <code>:paths</code> and <code>:results</code> data onto the node-tree. I've found that nothing beats a good visualization of data for the end user and the developer.
</p>
</div>
<div id="outline-container-orga915fb4" class="outline-3">
<h3 id="orga915fb4">Using Tangle to Generate dot</h3>
<div class="outline-text-3" id="text-orga915fb4">
<p target="_blank">
I looked into a few graphing libraries, but most seemed overly complex for the problem at hand: draw a simple tree of nodes and decorate them using the node-data.  I previously used graphviz to draw diagrams manually in dot format using emacs org-mode and babel dot code blocks. So I went back to look for clojure libraries that handle graphviz dot, and found a few, but settled on <a href="https://github.com/Macroz/tangle" target="_blank">tangle</a>.
</p>

<p>
<code>tangle.core/graph-&gt;dot</code> takes 3 args:
</p>
<ol class="org-ol">
<li>nodes :: a collection of ids or maps with :id key</li>
<li>edges :: a collection of vector of from-node id and and to-node ids with optional map of edge options</li>
<li>an optional map for dot graph, node, and edge defaults, plus some conversion functions.</li>
</ol>

<p>
As noted before, this website is written in org-mode, so I can show the tangle testing I did here:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;</span> (<span style="color: #9fcb66;">tangle.core</span>/graph-&gt;dot [<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"b"</span> <span style="color: #ff7fff;">"c"</span>]              <span style="color: #767283; font-style: italic;">; nodes</span>
                            [[<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"b"</span>] [<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"c"</span>]]      <span style="color: #767283; font-style: italic;">; edges</span>
                            {<span style="color: #34c8d8; font-weight: bold;">:graph</span> {<span style="color: #34c8d8; font-weight: bold;">:rankdir</span> <span style="color: #34c8d8; font-weight: bold;">:LR</span>}})   <span style="color: #767283; font-style: italic;">; options</span>
    print)
</pre>
</div>

<pre class="example" id="org911af5b">
graph {

graph[dpi=100, rankdir=LR]
"a"
"b"
"c"

"a" -- "b"
"a" -- "c"
}
</pre>

<p>
OK, looks like dot syntax.  Now lets convert it to SVG:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;</span> (<span style="color: #9fcb66;">tangle.core</span>/graph-&gt;dot [<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"b"</span> <span style="color: #ff7fff;">"c"</span>]              <span style="color: #767283; font-style: italic;">; nodes</span>
                            [[<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"b"</span>] [<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"c"</span>]]      <span style="color: #767283; font-style: italic;">; edges</span>
                            {<span style="color: #34c8d8; font-weight: bold;">:graph</span> {<span style="color: #34c8d8; font-weight: bold;">:rankdir</span> <span style="color: #34c8d8; font-weight: bold;">:LR</span>}})   <span style="color: #767283; font-style: italic;">; options</span>
    <span style="color: #9fcb66;">tangle.core</span>/dot-&gt;svg
    print)
</pre>
</div>


<div id="orgac3fff1" class="figure">
<p><object type="image/svg+xml" data="tangle1.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
Now a slightly more sophisticated tree like I want if&gt; to become:
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;</span> (<span style="color: #9fcb66;">tangle.core</span>/graph-&gt;dot [{<span style="color: #34c8d8; font-weight: bold;">:id</span> <span style="color: #ff7fff;">"a"</span> <span style="color: #34c8d8; font-weight: bold;">:label</span> <span style="color: #ff7fff;">"if&amp;gt;"</span> <span style="color: #34c8d8; font-weight: bold;">:shape</span> <span style="color: #34c8d8; font-weight: bold;">:diamond</span>}    <span style="color: #767283; font-style: italic;">; nodes</span>
                             {<span style="color: #34c8d8; font-weight: bold;">:id</span> <span style="color: #ff7fff;">"b"</span> <span style="color: #34c8d8; font-weight: bold;">:label</span> <span style="color: #ff7fff;">"!b"</span>}
                             {<span style="color: #34c8d8; font-weight: bold;">:id</span> <span style="color: #ff7fff;">"c"</span> <span style="color: #34c8d8; font-weight: bold;">:label</span> <span style="color: #ff7fff;">"!c"</span>}]
                            [[<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"b"</span> {<span style="color: #34c8d8; font-weight: bold;">:label</span> <span style="color: #ff7fff;">"then"</span>}]                    <span style="color: #767283; font-style: italic;">; edges</span>
                             [<span style="color: #ff7fff;">"a"</span> <span style="color: #ff7fff;">"c"</span> {<span style="color: #34c8d8; font-weight: bold;">:label</span> <span style="color: #ff7fff;">"else"</span>}]]
                            {<span style="color: #34c8d8; font-weight: bold;">:graph</span> {<span style="color: #34c8d8; font-weight: bold;">:rankdir</span> <span style="color: #34c8d8; font-weight: bold;">:LR</span>}                        <span style="color: #767283; font-style: italic;">; options</span>
                             <span style="color: #34c8d8; font-weight: bold;">:node</span> {<span style="color: #34c8d8; font-weight: bold;">:shape</span> <span style="color: #34c8d8; font-weight: bold;">:box</span>}
                             <span style="color: #34c8d8; font-weight: bold;">:node-&gt;id</span> (<span style="color: #ffff0b;">fn</span> [n] (<span style="color: #ffff0b;">if</span> (keyword? n) (name n) (<span style="color: #34c8d8; font-weight: bold;">:id</span> n)))   <span style="color: #767283; font-style: italic;">; conversion functions</span>
                             <span style="color: #34c8d8; font-weight: bold;">:node-&gt;descriptor</span> (<span style="color: #ffff0b;">fn</span> [n] (<span style="color: #ffff0b;">when-not</span> (keyword? n) n))})
    <span style="color: #9fcb66;">tangle.core</span>/dot-&gt;svg
    print)
</pre>
</div>


<div id="orga0ce4de" class="figure">
<p><object type="image/svg+xml" data="tangle2.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>

<div id="outline-container-org6c85549" class="outline-3">
<h3 id="org6c85549">Turning Stax Node Data into dot and SVG</h3>
<div class="outline-text-3" id="text-org6c85549">
<p>
<code>kdh.stax.svg/paths-to-dot</code> takes node-data <code>:paths</code> and
</p>
<ul class="org-ul">
<li>generates deduplicated, labeled, and indexed nodes and edges</li>
<li>sort the edges so graphviz generates then above else</li>
<li>and calls tangle.core/graph-&gt;dot to generate the dot</li>
</ul>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">-&gt;</span> (build-node-data '[!a !b !c] '((if&gt; !a else&gt; !b)))
    <span style="color: #34c8d8; font-weight: bold;">:paths</span>
    paths-to-dot
    (<span style="color: #9fcb66;">str</span>/replace <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\\</span><span style="color: #ff7fff;">"</span> <span style="color: #ff7fff;">""</span>)   <span style="color: #767283; font-style: italic;">; necessary to unescape the brackets and colon in id which is a :node-index</span>
    <span style="color: #9fcb66;">tangle.core</span>/dot-&gt;svg
    print)
</pre>
</div>


<div id="org0ae66c5" class="figure">
<p><object type="image/svg+xml" data="tangle3.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
In code, I use <code>tangle.core/dot-&gt;svg</code> and <code>clojure.data.xml/parse-str</code> to get the svg as edn for later maniplulation.
</p>

<p>
<code>kdh.stax.svg/add-svg-data</code> converts node-data <code>:paths</code> into dot node ids (strings of <code>:node-index</code>, which is unique) and edges (vector pairs of dot node ids) sometimes with labels (start, then, and else) from node <code>:branch</code> values.  SVG is an xml vocabulary, which <code>clojure.data.xml/parse-string</code> turns into edn that can be manipulated with specter.  I like this multi-step process:  edn-&gt;dot then dot-&gt;svg then svg-&gt;edn because the intermediate dot and svg allow me to quickly play with dot and svg in org-mode.
</p>
</div>
</div>

<div id="outline-container-org92516ce" class="outline-3">
<h3 id="org92516ce">Debugging Stax Execution in SVG</h3>
<div class="outline-text-3" id="text-org92516ce">
<p>
The node-data created by <code>kdh.stax.nodify/build-node-data</code> can be passed into <code>kdh.stax.core/stackfn-dbg</code> to add the execution values. <code>kdh.stax.svg/node-data-to-html-file</code> calls the decorator functions in <code>kdh.stax.svg</code> to complete the visualization and outputs an html file.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(str
 (node-data-to-html-file (<span style="color: #9fcb66;">io</span>/file <span style="color: #ff7fff;">"org"</span> <span style="color: #ff7fff;">"svg"</span> <span style="color: #ff7fff;">"rpl-example-tree-path-exec.html"</span>)
                         (<span style="color: #ffff0b;">-&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-rpl-example)
                             (stackfn-dbg 1 2 4
                                           3 3 3))))
</pre>
</div>
</div>

<div id="outline-container-org6306b3a" class="outline-4">
<h4 id="org6306b3a">A Walkthrough of Good Data Visualization</h4>
<div class="outline-text-4" id="text-org6306b3a">
<p>
Click on the link below to open the visualization that exercises the paths in the assignment example in another tab
</p>
<p target="_blank">
<a href="svg/rpl-example-tree-path-exec.html" target="_blank">rpl-example-tree-path-exec.html</a>
</p>

<p>
Looking at the html visualization, you should see three sections differentiated by color:
</p>
<dl class="org-dl">
<dt>Gray/Black</dt><dd>Shows the parsed <code>:node-tree</code> of the node-data
<ul class="org-ul">
<li>If you hover over nodes, you should see a popup with "node=[&lt;node-index&gt;]"
<ul class="org-ul">
<li>this bracketed value is the <code>:node-index</code> for the node
<ul class="org-ul">
<li>an alternating vector of numbers (index in the straight section) and keywords (<code>:then</code> or <code>:else</code>) for branches.</li>
</ul></li>
</ul></li>
<li>Note that all the nodes are Gray (no parse errors) and the edges are black (always the case in the parse tree).</li>
</ul></dd>
<dt>Blue</dt><dd>Shows the <code>:paths</code> overlay of the <code>:node-tree</code>
<ul class="org-ul">
<li>This is the static analysis section</li>
<li>Note the turns vector [start→then→term] after the name "graph0-path1"</li>
<li>If you hover over nodes, you should see a popup with "node=[&lt;node-index&gt;]" and a new value "size=&lt;n&gt;"
<ul class="org-ul">
<li>this the cardinality of the stack as determined by the <code>:delta</code> value of the nodes prior on the path</li>
</ul></li>
<li>Note that the path (the edges and the perimeter of the polygons) is colored blue from start node to terminal node
<ul class="org-ul">
<li>That indicates no cardinality or ref before def errors</li>
</ul></li>
<li>Note that the nodes in the path are filled with blue
<ul class="org-ul">
<li>That indicates there are no nodes with errors in either path</li>
</ul></li>
</ul></dd>
<dt>Green</dt><dd>Shows the <code>:results</code> overlay of the <code>:node-tree</code>
<ul class="org-ul">
<li>This is the execution section</li>
<li>If you hover over nodes, you should see the popup no longer has "size=n"</li>
<li>Instead, you see "var-map={&lt;!var&gt; &lt;val&gt;}" which is the state of the variables after the node executes</li>
<li>Also in the popup is the "stack=[&lt;values&gt;]" which is the state of the stack after the node executes</li>
<li>Note that the path (the edges and the perimeter of the polygons) is colored green from start node to terminal node
<ul class="org-ul">
<li>That indicates no runtime errors in that path</li>
</ul></li>
<li>Note that the nodes in the path are filled with blue
<ul class="org-ul">
<li>That indicates there are no nodes with runtime errors</li>
</ul></li>
<li>Each result also has a section below it with
<ul class="org-ul">
<li>Variables Table (Init and Last state)</li>
<li>the final Stack value(s)</li>
<li>and the Output text box (if present)</li>
</ul></li>
</ul></dd>
</dl>
</div>
</div>

<div id="outline-container-org2c0a9ee" class="outline-4">
<h4 id="org2c0a9ee">A Walkthrough of Bad Data Visualization</h4>
<div class="outline-text-4" id="text-org2c0a9ee">
<p>
Boy, that RPL example visualization sure was pretty&#x2026;.But it lacked the a vibrancy that can only come from&#x2026;.ERRORS!!!
</p>

<div class="org-src-container">
<pre class="src src-clojure">(str
 (node-data-to-html-file
  (<span style="color: #9fcb66;">io</span>/file <span style="color: #ff7fff;">"org"</span> <span style="color: #ff7fff;">"svg"</span> <span style="color: #ff7fff;">"kdh-bad-example-tree-path-noexec.html"</span>)
  (<span style="color: #ffff0b;">-&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)
      (stackfn-dbg 1 2 4
                    3 3 3))))
</pre>
</div>

<p>
Click on the link below to open the visualization that exercises some bad nodes and paths in another tab
</p>
<p target="_blank">
<a href="svg/kdh-bad-example-tree-path-noexec.html" target="_blank">kdh-bad-example-tree-path-noexec.html</a>
</p>

<p>
Looking at the html visualization, you should now see two sections differentiated by color:
</p>
<dl class="org-dl">
<dt>Gray/Black</dt><dd>Shows the parsed <code>:node-tree</code> of the node-data
<ul class="org-ul">
<li><p>
But now some of the nodes are OrangeRed. Hover over them to see what's wrong&#x2026;
</p>
<pre class="example" id="org5cd916d">
node=[8 :then 0]

TREE ERRORS:
a is not an allowed op
</pre>
<pre class="example" id="org084f809">
node=[8 :else 0]

TREE ERRORS:
b is not an allowed op
</pre>
<ul class="org-ul">
<li><p>
the css for this is
</p>
<div class="org-src-container">
<pre class="src src-css"><span style="color: #ffff0b; font-weight: bold;">svg&gt;g.graph&gt;g.node&gt;polygon[data-stax-err-type~=</span><span style="color: #ff7fff;">"error=parse-illegal-operation"</span><span style="color: #ffff0b; font-weight: bold;">] </span>{
    <span style="color: #ff55ff;">fill</span>: <span style="color: #ffffff; background-color: #ff4500;">orangered</span>;
}
</pre>
</div></li>
</ul></li>
<li><p>
Another node is Orange. Hovering over it reveals&#x2026;two errors in one node - ouch!
</p>
<pre class="example" id="org768d9c1">
node=[5 :then 0]

TREE ERRORS:
printl is not a known function!
0 is not a valid arity (must be pos-int)!
</pre>
<ul class="org-ul">
<li><p>
the css for this is
</p>
<div class="org-src-container">
<pre class="src src-css"><span style="color: #ffff0b; font-weight: bold;">svg&gt;g.graph&gt;g.node&gt;polygon[data-stax-err-type^=</span><span style="color: #ff7fff;">"error=parse-invoke"</span><span style="color: #ffff0b; font-weight: bold;">] </span>{
    <span style="color: #ff55ff;">fill</span>: <span style="color: #ffffff; background-color: #ffa500;">orange</span>;
}
</pre>
</div></li>
</ul></li>
</ul></dd>
<dt>Blue</dt><dd>Shows the <code>:paths</code> overlay of the <code>:node-tree</code>
<ul class="org-ul">
<li>Note the parse errors are still showing &#x2013; parse errors are always shown in both zone=tree and zone=path</li>
<li>Note also that paths (edges and polygon lines) turn DeepPink at an error and beyond.</li>
<li>But we see more errors in the paths&#x2026;but sometime not, depending on the path
<ul class="org-ul">
<li><p>
Path1 [start→then→then→term] has two instances of
</p>
<pre class="example" id="org8edb79b">
PATH ERRORS:
!v2 is a reference before definition
</pre>
<ul class="org-ul">
<li><p>
Because <code>!v2+</code> is not present in the path prior to either node, the css catches the <code>data-stax-err-type</code> with "error=static-var-not-defined"
</p>
<div class="org-src-container">
<pre class="src src-css"><span style="color: #ffff0b; font-weight: bold;">svg&gt;g.graph&gt;g.node&gt;polygon[data-stax-err-type~=</span><span style="color: #ff7fff;">"error=static-var-not-defined"</span><span style="color: #ffff0b; font-weight: bold;">] </span>{
    <span style="color: #ff55ff;">fill</span>: <span style="color: #ffffff; background-color: #da70d6;">orchid</span>;
}
</pre>
</div></li>
</ul></li>
<li><p>
Path2 [start→then→else→term] has two instances of "!v2 is a reference before definition", but later on is a diferrent node.
</p>
<pre class="example" id="org54c619c">
PATH ERRORS:
!v2 is a reference before definition
</pre></li>
<li>"error=static-var-not-defined" will show for every ref-before-def in a given path</li>
<li><p>
Path3+4 both have the same bad node filled by CSS which was in Path1+2, but not filled there
</p>
<pre class="example" id="org076af3b">
node=[7]

PATH ERRORS:
stack size=1, operation (invoke&gt; = 2) needs &gt;=2
</pre>
<div class="org-src-container">
<pre class="src src-css"><span style="color: #ffff0b; font-weight: bold;">svg&gt;g.graph&gt;g.node&gt;polygon[data-stax-err-type~=</span><span style="color: #ff7fff;">"error=static-insufficient-stack"</span><span style="color: #ffff0b; font-weight: bold;">] </span>{
    <span style="color: #ff55ff;">fill</span>: <span style="color: #000000; background-color: #ff00ff;">magenta</span>;
}
</pre>
</div>
<ul class="org-ul">
<li>That is because cardinality can not be calculated through bad paths &#x2013; Errors invalidate the count</li>
</ul></li>
</ul></li>
</ul></dd>
</dl>
<hr />
</div>
</div>
<div id="outline-container-org37d56e3" class="outline-4">
<h4 id="org37d56e3">A Run Through Bad Data Visualization</h4>
<div class="outline-text-4" id="text-org37d56e3">
<p>
That last example had no Results trees, even though we supplied values. That's because the default behavior of <code>stackfn</code> and <code>stackfn-dbg</code> is to not execute with parse or static errors present in the tree (technically, in the flattened tree of the node-data <code>:nodes</code> and the <code>:paths</code>).
</p>

<p>
We can allow result by binding a dynamic variable:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-errors-prevent-exec*</span> <span style="color: #34c8d8; font-weight: bold;">false</span>]
  (str
   (node-data-to-html-file
    (<span style="color: #9fcb66;">io</span>/file <span style="color: #ff7fff;">"org"</span> <span style="color: #ff7fff;">"svg"</span> <span style="color: #ff7fff;">"kdh-bad-example-tree-path-exec.html"</span>)
    (<span style="color: #ffff0b;">-&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)
        (stackfn-dbg 1 2 3
                      3 2 1
                      1 3 2
                      2 3 1
                      4 2 1
                      1 4 2
                      2 1 4
                      1 2 4)))))
</pre>
</div>

<p>
Click on the link below to open the visualization that exercises some bad nodes and paths in another tab
</p>
<p target="_blank">
<a href="svg/kdh-bad-example-tree-path-exec.html" target="_blank">kdh-bad-example-tree-path-exec.html</a>
</p>


<p>
If you hover over nodes, you should see a popup with "node=[&lt;node-index&gt;]" and a new value "size=&lt;n&gt;"
</p>
<ul class="org-ul">
<li>this the cardinality of the stack as determined by the <code>:delta</code> value of the nodes prior on the path</li>
</ul>
<ul class="org-ul">
<li>Note that the path (the edges and the perimeter of the polygons) is colored blue from start node to terminal node
<ul class="org-ul">
<li>That indicates no cardinality or ref before def errors</li>
</ul></li>
<li>Note that the nodes in the path are filled with blue
<ul class="org-ul">
<li>That indicates there are no nodes with errors in either path</li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgab4f20a" class="outline-2">
<h2 id="orgab4f20a">Optimization Case Studies</h2>
<div class="outline-text-2" id="text-orgab4f20a">
<p>
Throughout the development of <code>kdh/stax</code>, I optimized several sections of code.  While an exhaustive review is not feasible, I would like to show a few optimizations I made to give a sense of the work I did.
</p>
</div>

<div id="outline-container-orgb5bb2b4" class="outline-3">
<h3 id="orgb5bb2b4">Sorting Paths</h3>
<div class="outline-text-3" id="text-orgb5bb2b4">
<p>
I want <code>build-node-data</code> and <code>build-node-data*</code> to produce the same node-data (specifically <code>:node-tree</code>, and <code>:paths</code>, as the others are derived from these).
Since paths is a vector of vectors, order matters. Because of their underlying implementations, <code>build-node-data</code> and <code>build-node-data*</code> produce paths in different order.
I wrote <code>mapify-paths</code> to make paths into a deep associative structure in order to compare them with <code>clojure.core/diff</code>.
</p>

<p>
But I want my tree visualization to flow left to right and with <code>then</code> ranked above <code>else</code>.
I want the enumerated paths in the visualization to display the top most path (all <code>then</code>) to bottom most (all <code>else</code>).
To accomplish this, I sort the paths reverse alphabetically by their turns (simplified here to sorting their turns).
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">let</span> [turns [<span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span>]
      else-over-then (vec (<span style="color: #ffff0b;">for</span> [t1 turns t2 turns t3 turns] [<span style="color: #ff7fff;">"start"</span> t1 t2 t3 <span style="color: #ff7fff;">"term"</span>]))
      then-over-else (vec (sort-by str (comp - compare) else-over-then))]
     {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span>  else-over-then
      <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span>  then-over-else})
(=&gt;
 {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]],
  <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]]}
 )
</pre>
</div>

<p>
This works perfectly only because the paths have the same length.  If they don't (often the case), sort favors length over content.
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example
      paths (mapv path-to-turns (<span style="color: #ffff0b;">-&gt;</span> ops nodify-ops* <span style="color: #34c8d8; font-weight: bold;">:paths</span>))
      else-over-then (vec (sort-by identity paths))
      then-over-else (vec (sort-by identity (comp - compare) else-over-then))]
     {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span>  else-over-then
      <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span>  then-over-else})

(=&gt;
 {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]],
  <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]]}
 )
</pre>
</div>

<p>
Years ago, I needed to sort vectors like this - i.e. sort sequences (regardless of length) by comparing each sequential item.
After realizing that the different length of the data was confounding my sort, I hit upon a genius idea (always a bad sign, right?)
</p>

<p>
What if I could make the length of all of the sequences equal?
</p>

<p>
So I wrote a function <code>seq-to-deep</code> that turns a sequence into a two length vector containing item one in the first slot,
and another two length vector whose first was item two in the second slot&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">seq-to-deep</span> [v]
  (<span style="color: #ffff0b;">-&gt;&gt;</span> v reverse
       (map vector)
       (reduce (<span style="color: #ffff0b;">fn</span> [l r] (into r [l])) [])))

(=&gt; <span style="color: #9fcb66;">#'user</span>/seq-to-deep )

(seq-to-deep [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>])

(=&gt; [<span style="color: #ff7fff;">"start"</span> [<span style="color: #ff7fff;">"else"</span> [<span style="color: #ff7fff;">"then"</span> [<span style="color: #ff7fff;">"else"</span> [<span style="color: #ff7fff;">"else"</span> [<span style="color: #ff7fff;">"else"</span> [<span style="color: #ff7fff;">"else"</span> [<span style="color: #ff7fff;">"term"</span> []]]]]]]]] )
</pre>
</div>

<p>
This basically reduces a list or vector of any length into a vector of two-tuples,
where the first is a value and the second is, recursively, another two tuple
(similar to a linked list as a one legged cons tree in lisps of old - with [] standing in for nil to end the cons cell chain)
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example
      paths (mapv path-to-turns (<span style="color: #ffff0b;">-&gt;</span> ops nodify-ops* <span style="color: #34c8d8; font-weight: bold;">:paths</span>))
      else-over-then (vec (sort-by seq-to-deep paths))
      then-over-else (vec (sort-by seq-to-deep (comp - compare) else-over-then))]
  {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span>  else-over-then
   <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span>  then-over-else})

(=&gt;
 {<span style="color: #34c8d8; font-weight: bold;">:else-over-then</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]],
  <span style="color: #34c8d8; font-weight: bold;">:then-over-else</span> [[<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"then"</span> <span style="color: #ff7fff;">"term"</span>]
                   [<span style="color: #ff7fff;">"start"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"else"</span> <span style="color: #ff7fff;">"term"</span>]]}
 )
</pre>
</div>

<p>
It's ugly, and not very space efficient &#x2013; look at all those vectors!
But, it worked in a pinch!!  And remained one of my favorite ad-hoc odd-hacks!!!
Top of my utils for many years.
</p>

<p>
I pulled it out to use for stax, but having learned more in the intervening decade,
I decided that what I really want is a compare fn for <code>sort-by</code>'s compare arg,
not another function to comp onto <code>sort-by</code>'s keyfn arg.
</p>

<p>
The function sequential-compare1 compares each succesive term in two paths
returning the comparison at the first difference
</p>

<div class="org-src-container">
<pre class="src src-clj"><span class="linenr"> 1: </span>(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">sequential-compare1</span> [path-1 path-2]
<span class="linenr"> 2: </span>  (<span style="color: #ffff0b;">if</span> (= path-1 path-2) 0
<span class="linenr"> 3: </span>      (<span style="color: #ffff0b;">loop</span> [[nth-1 &amp; more-1] path-1
<span class="linenr"> 4: </span>             [nth-2 &amp; more-2] path-2]
<span class="linenr"> 5: </span>        (<span style="color: #ffff0b;">let</span> [comparison (compare nth-1 nth-2)]
<span class="linenr"> 6: </span>          (<span style="color: #ffff0b;">if-not</span> (zero? comparison)
<span class="linenr"> 7: </span>            comparison
<span class="linenr"> 8: </span>            (<span style="color: #ffff0b;">if</span> (nil? more-1)
<span class="linenr"> 9: </span>              -1
<span class="linenr">10: </span>              (<span style="color: #ffff0b;">if</span> (nil? more-2)
<span class="linenr">11: </span>                +1
<span class="linenr">12: </span>                (<span style="color: #ffff0b;">recur</span> more-1 more-2))))))))
<span class="linenr">13: </span>
<span class="linenr">14: </span>(=&gt; <span style="color: #9fcb66;">#'user</span>/sequential-compare1 )
</pre>
</div>

<p>
We can take advantage of the following facts to simplify sequential-compare1:
</p>
<ol class="org-ol">
<li>binding form [item &amp; more-items] when bound to the last item
(i.e. no more-items) makes more-item nil like next, not '() like rest</li>
<li>nil &lt; item, if item is not nil, so the shorter path that is identical
to the longer, up until its end, sorts &lt;</li>
<li>in the loop, there will never be two paths that are equal in size
and equal in each item, because they would be equal in the first if and return 0</li>
</ol>


<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">sequential-compare2</span> [path-1 path-2]
  (<span style="color: #ffff0b;">if</span> (= path-1 path-2) 0
      (<span style="color: #ffff0b;">loop</span> [[nth-1 &amp; more-1] path-1
             [nth-2 &amp; more-2] path-2]
        (<span style="color: #ffff0b;">let</span> [comparison (compare nth-1 nth-2)]
          (<span style="color: #ffff0b;">if</span> (zero? comparison)
            (<span style="color: #ffff0b;">recur</span> more-1 more-2)
            comparison)))))

(=&gt; <span style="color: #9fcb66;">#'user</span>/sequential-compare2 )
</pre>
</div>

<p>
Now we can compare the three alternatives (seq-to-deep, sequential-compare1, sequential-compare2)
for equality and execution speed in best (already sorted) and worst cases (reverse of sort)
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example
      paths (<span style="color: #ffff0b;">-&gt;</span> ops nodify-ops* <span style="color: #34c8d8; font-weight: bold;">:paths</span>)
      turns (mapv path-to-turns paths)
      else-over-then-with-seq-to-deep (sort-by seq-to-deep turns)
      then-over-else-with-seq-to-deep (sort-by seq-to-deep (comp - compare) turns)
      else-over-then-with-sequential-compare1 (vec (sort-by identity sequential-compare1 turns))
      then-over-else-with-sequential-compare1 (vec (sort-by identity (comp - sequential-compare1) turns))
      else-over-then-with-sequential-compare2 (vec (sort-by identity sequential-compare2 turns))
      then-over-else-with-sequential-compare2 (vec (sort-by identity (comp - sequential-compare2) turns))
      they-are-equal (<span style="color: #ffff0b;">and</span> (= else-over-then-with-seq-to-deep
                             else-over-then-with-sequential-compare1
                             else-over-then-with-sequential-compare2)
                          (= then-over-else-with-seq-to-deep
                             then-over-else-with-sequential-compare1
                             then-over-else-with-sequential-compare2))]
  (<span style="color: #ffff0b;">when</span> they-are-equal
    (<span style="color: #ffff0b;">let</span> [then-over-else then-over-else-with-seq-to-deep
          else-over-then else-over-then-with-seq-to-deep]
      (qb (sort-by seq-to-deep (comp - compare) then-over-else))
      (qb (sort-by seq-to-deep (comp - compare) else-over-then))
      (qb (sort-by seq-to-deep compare then-over-else))
      (qb (sort-by seq-to-deep compare else-over-then))
      (qb (sort-by identity (comp - sequential-compare1) then-over-else))
      (qb (sort-by identity (comp - sequential-compare1) else-over-then))
      (qb (sort-by identity sequential-compare1 then-over-else))
      (qb (sort-by identity sequential-compare1 else-over-then))
      (qb (sort-by identity (comp - sequential-compare2) then-over-else))
      (qb (sort-by identity (comp - sequential-compare2) else-over-then))
      (qb (sort-by identity sequential-compare2 then-over-else))
      (qb (sort-by identity sequential-compare2 else-over-then))
      they-are-equal)))

(=&gt; <span style="color: #34c8d8; font-weight: bold;">true</span> )
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 5:</span> <code>seq-to-deep</code> vs <code>sequential-compare1</code> vs <code>sequential-compare2</code></caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Evaluation</th>
<th scope="col" class="org-left">Execution time mean</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(sort-by seq-to-deep (comp - compare) then-over-else)</td>
<td class="org-left">29.105317 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by seq-to-deep (comp - compare) else-over-then)</td>
<td class="org-left">28.966610 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by seq-to-deep compare then-over-else)</td>
<td class="org-left">31.041590 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by seq-to-deep compare else-over-then)</td>
<td class="org-left">29.071545 µs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">29.546266 μs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare1) then-over-else)</td>
<td class="org-left">2.491231 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare1) else-over-then)</td>
<td class="org-left">2.517452 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare1 then-over-else)</td>
<td class="org-left">2.337029 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare1 else-over-then)</td>
<td class="org-left">2.383909 µs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">2.4324053 μs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare2) then-over-else)</td>
<td class="org-left">2.517697 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare2) else-over-then)</td>
<td class="org-left">2.479772 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare2 then-over-else)</td>
<td class="org-left">2.343008 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare2 else-over-then)</td>
<td class="org-left">2.313736 µs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">2.4135533 μs</td>
</tr>
</tbody>
</table>

<p>
As hoped, both sequential-compare1 and sequential-compare2 outperform seq-to-deep (by an order of magnitude)
sequential-compare2 outperforms sequential-compare1 by about 0.8%
</p>

<p>
Let's see how the two sequential-compare functions do with a bigger tree
</p>

<div class="org-src-container">
<pre class="src src-clj">(<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-worse-example
      paths (<span style="color: #ffff0b;">-&gt;</span> ops nodify-ops* <span style="color: #34c8d8; font-weight: bold;">:paths</span>)
      number-of-paths (count paths)
      longest-path (apply max (map count paths))]
  {<span style="color: #34c8d8; font-weight: bold;">:number-of-paths</span> number-of-paths
   <span style="color: #34c8d8; font-weight: bold;">:longest-path</span> longest-path})

(=&gt; {<span style="color: #34c8d8; font-weight: bold;">:number-of-paths</span> 86, <span style="color: #34c8d8; font-weight: bold;">:longest-path</span> 68} )


(<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-worse-example
      paths (<span style="color: #ffff0b;">-&gt;</span> ops nodify-ops* <span style="color: #34c8d8; font-weight: bold;">:paths</span>)
      turns (mapv path-to-turns paths)
      else-over-then-with-sequential-compare1 (sort-by identity sequential-compare1 turns)
      then-over-else-with-sequential-compare1 (sort-by identity (comp - sequential-compare1) turns)
      else-over-then-with-sequential-compare2 (sort-by identity sequential-compare2 turns)
      then-over-else-with-sequential-compare2 (sort-by identity (comp - sequential-compare2) turns)
      they-are-equal (<span style="color: #ffff0b;">and</span> (= else-over-then-with-sequential-compare1
                             else-over-then-with-sequential-compare2)
                          (= then-over-else-with-sequential-compare1
                             then-over-else-with-sequential-compare2))]
  (<span style="color: #ffff0b;">when</span> they-are-equal
    (<span style="color: #ffff0b;">let</span> [then-over-else then-over-else-with-sequential-compare1
          else-over-then else-over-then-with-sequential-compare1]
      (qb (sort-by identity (comp - sequential-compare1) then-over-else))
      (qb (sort-by identity (comp - sequential-compare1) else-over-then))
      (qb (sort-by identity sequential-compare1 then-over-else))
      (qb (sort-by identity sequential-compare1 else-over-then))
      (qb (sort-by identity (comp - sequential-compare2) then-over-else))
      (qb (sort-by identity (comp - sequential-compare2) else-over-then))
      (qb (sort-by identity sequential-compare2 then-over-else))
      (qb (sort-by identity sequential-compare2 else-over-then))
      they-are-equal)))

(=&gt; <span style="color: #34c8d8; font-weight: bold;">true</span> )
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 6:</span> <code>sequential-compare1</code> vs <code>sequential-compare2</code> final round</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Evaluation</th>
<th scope="col" class="org-left">Execution time mean</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare1) then-over-else)</td>
<td class="org-left">52.638949 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare1) else-over-then)</td>
<td class="org-left">50.717881 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare1 then-over-else)</td>
<td class="org-left">49.913771 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare1 else-over-then)</td>
<td class="org-left">49.833063 µs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">50.775916 μs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare2) then-over-else)</td>
<td class="org-left">50.668951 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity (comp - sequential-compare2) else-over-then)</td>
<td class="org-left">49.301679 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare2 then-over-else)</td>
<td class="org-left">48.979257 µs</td>
</tr>

<tr>
<td class="org-left">(sort-by identity sequential-compare2 else-over-then)</td>
<td class="org-left">49.346938 µs</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">49.574206 μs</td>
</tr>
</tbody>
</table>

<p>
<code>sequential-compare2</code> does even better against <code>sequential-compare1</code> by about 2.2%
</p>

<p>
So <code>kdh.stax.util/sequential-compare</code> is now <code>sequential-compare2</code>, and <code>seq-to-deep</code> can be retired!
</p>
</div>
</div>

<div id="outline-container-org47075ca" class="outline-3">
<h3 id="org47075ca"><code>nodify-ops</code> vs <code>nodify-ops*</code></h3>
<div class="outline-text-3" id="text-org47075ca">
<p>
¿EXPLAIN?
</p>

<div class="org-src-container">
<pre class="src src-clj"><span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">nodify-ops* returns a map with :node-tree and :paths</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">nodify-ops only returns a node-tree - so we need to call node-tree-to-node-paths with *stax-perform-path-analysis* false to make these equivalent</span>

(<span style="color: #ffff0b;">binding</span> [<span style="color: #4ac964;">*stax-perform-path-analysis*</span> <span style="color: #34c8d8; font-weight: bold;">false</span>]
  (<span style="color: #ffff0b;">let</span> [ops <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example
        decls '[!a !b !c]
        nodified (<span style="color: #ffff0b;">let</span> [node-tree (nodify-ops ops)
                       paths (node-tree-to-node-paths decls node-tree)]
                   {<span style="color: #34c8d8; font-weight: bold;">:node-tree</span> node-tree
                    <span style="color: #34c8d8; font-weight: bold;">:paths</span> paths})
        <span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">nodify-ops* returns a map with extra keys [:raw-paths has :sticky sub-paths]</span>
        nodified* (select-keys (nodify-ops* ops) [<span style="color: #34c8d8; font-weight: bold;">:node-tree</span> <span style="color: #34c8d8; font-weight: bold;">:paths</span>])
        they-are-equal (=  nodified nodified*)]
    (<span style="color: #ffff0b;">if</span> they-are-equal
      (<span style="color: #ffff0b;">do</span>
        (qb (node-tree-to-node-paths decls (nodify-ops ops)))
        (qb (<span style="color: #34c8d8; font-weight: bold;">:paths</span> (nodify-ops* ops)))
        they-are-equal)
      (take 2 (<span style="color: #9fcb66;">clojure.data</span>/diff (update nodified <span style="color: #34c8d8; font-weight: bold;">:paths</span> mapify-paths)
                                 (update nodified* <span style="color: #34c8d8; font-weight: bold;">:paths</span> mapify-paths))))))

<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">================================================================================</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(node-tree-to-node-paths decls (nodify-ops ops))</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">--------------------------------------------------------------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Evaluation count : 4590 in 6 samples of 765 calls.</span>
<span style="color: #767283;">;;              </span><span style="color: #767283; font-style: italic;">Execution time mean : 137.892144 &#181;s</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">Execution time std-deviation : 5.518452 &#181;s</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time lower quantile : 132.664061 &#181;s ( 2.5%)</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time upper quantile : 144.552999 &#181;s (97.5%)</span>
<span style="color: #767283;">;;                    </span><span style="color: #767283; font-style: italic;">Overhead used : 7.966002 ns</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">________________________________________________________________________________</span>
<span style="color: #767283;">;;</span>
<span style="color: #767283;">;;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">================================================================================</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(:paths (nodify-ops* ops))</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">--------------------------------------------------------------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Evaluation count : 2826 in 6 samples of 471 calls.</span>
<span style="color: #767283;">;;              </span><span style="color: #767283; font-style: italic;">Execution time mean : 213.668540 &#181;s</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">Execution time std-deviation : 4.777139 &#181;s</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time lower quantile : 208.771866 &#181;s ( 2.5%)</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time upper quantile : 220.715470 &#181;s (97.5%)</span>
<span style="color: #767283;">;;                    </span><span style="color: #767283; font-style: italic;">Overhead used : 7.966002 ns</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">________________________________________________________________________________</span>
</pre>
</div>
</div>
</div>


<div id="outline-container-org296cd27" class="outline-3">
<h3 id="org296cd27">KeyFnMap for Decorating SVG Nodes with Op Node Errors</h3>
<div class="outline-text-3" id="text-org296cd27">
<p>
For the visualization of <code>:node-tree</code>, <code>:paths</code>, and <code>:results</code>, I use SVG in HTML.  While I toyed with directly manipulating the look of SVG (changing the <code>:fill</code> color of a <code>g.node</code>'s <code>:polygon</code>, or the <code>:stroke</code> color of a <code>g.edge</code>'s <code>:path</code> with specter), as soon as I became aware of SVG user data attributes, I focused on marking the SVG with custon attributes that I could then target from CSS.
SVG allows custom attributes named :data-&lt;your-name-here&gt;. These are legal SVG, and are useful for adding data to your SVG elements. However, the user data attributes are just that, attributes.  Attributes are simple &#x2013; i.e cannot contain child values, like elements can.  To convert vectors of error maps into data attributes, I would need to write conversion functions.
</p>

<p>
I add two custom attributes for node error the visualization
</p>
<dl class="org-dl">
<dt><code>:data-stax-err-type</code></dt><dd><ul class="org-ul">
<li>To be used by css to style an svg node based on the <code>:err-type</code> values in its corresponding op node's <code>:errors</code></li>
<li>This is a string of space delimited names of keywords assigned as the values of the <code>:err-type</code> key in the error maps within the vector <code>:errors</code>.</li>
</ul></dd>
</dl>
<pre class="example" id="org9c2fc6e">
[{:err-type &lt;keyword-1&gt;}
 {:err-type &lt;keyword-2&gt;}
 ...
 {:err-type &lt;keyword-n}]  ==&gt; "&lt;name-1&gt; &lt;name-2&gt; ... &lt;name-n&gt;"
</pre>

<dl class="org-dl">
<dt><code>:data-stax-err-text</code></dt><dd><ul class="org-ul">
<li>To be used by css to style an svg node based on the <code>:err-text</code> values in its corresponding op node's <code>:errors</code></li>
<li>Its form is a string of newline delimited values derived from <code>:err-text</code> values</li>
<li>It is displayed in the label text that pops up when hovering over the node in the visualization</li>
</ul></dd>
</dl>
<pre class="example" id="org83fd899">
[{:err-text &lt;string-1&gt;}
 {:err-text &lt;string-2&gt;}
 ...
 {:err-text &lt;string-n}]   ==&gt; "&lt;string-1&gt;\n&lt;string-2&gt;\n...\n&lt;string-n&gt;"
</pre>

<p>
To simplified this, I came up with KeyFnMap, a map of match keys to conversion functions.
</p>
</div>

<div id="outline-container-org5981227" class="outline-4">
<h4 id="org5981227">First Version</h4>
<div class="outline-text-4" id="text-org5981227">
<p>
In v1 of the keyfnmap
</p>
<ul class="org-ul">
<li>keys match those in the error maps (:err-type and :err-text)</li>
<li>values are functions to convert :errors into the corresponding values for the :data-stax-err-type and :data-stax-err-text values</li>
</ul>

<p>
Given a sequence of op nodes, <code>make-node-id-to-data-stax-err-map-v1</code> calls <code>index-property-of-nodes</code> to create a map of node-index string (which is the id of the svg nodes we will decorate) to errors from the node specified by the node-index. This is passed to <code>map-vals-via-keyfnmap-v1</code> along with the keyfnmap to return a map of maps from node-index string to a map of svg data keyed converted values.
</p>

<p>
Below, we sit it works, but <code>map-vals-via-keyfnmap-v1</code> has the key fixing call to <code>key-to-data-stax-key</code> locked within it.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">def</span> <span style="color: #4ac964;">err-to-data-stax-err-kfm-v1</span>
  {<span style="color: #34c8d8; font-weight: bold;">:err-type</span> (<span style="color: #ffff0b;">fn</span> [som]
               (apply str
                      (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-type</span>)
                                      (map name)
                                      (interpose <span style="color: #ff7fff;">" "</span>))
                                som)))
   <span style="color: #34c8d8; font-weight: bold;">:err-text</span> (<span style="color: #ffff0b;">fn</span> [som]
               (apply str
                      (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-text</span>)
                                      (interpose <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>))
                                som)))})


(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">map-vals-via-keyfnmap-v1</span>
  [keyfnmap target-map]
  (map-vals (<span style="color: #ffff0b;">fn</span> [errors]
              (into {} (map (<span style="color: #ffff0b;">fn</span> [[k val-fn]]
                              [(key-to-data-stax-key k) (val-fn errors)]))
                    keyfnmap))
            target-map))


(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">make-node-id-to-data-stax-err-map-v1</span>
  ([nodes]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> nodes
        (index-property-of-nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals-via-keyfnmap-v1 err-to-data-stax-err-kfm-v1)))
  ([nodes err-key err-val-set]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> nodes
        (index-property-of-nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals (partial filter #(<span style="color: #ffff0b;">-&gt;</span> <span style="color: #4ac964;">%</span> err-key err-val-set)))
        (remove-vals empty?)
        (map-vals-via-keyfnmap-v1 err-to-data-stax-err-kfm-v1))))


(<span style="color: #ffff0b;">-&gt;&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)
     <span style="color: #34c8d8; font-weight: bold;">:nodes</span>
     make-node-id-to-data-stax-err-map-v1)

(=&gt;
 {<span style="color: #ff7fff;">"[5 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-invoke-bad-function error=parse-invoke-bad-arity"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"printl is not a known function!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">0 is not a valid arity (must be pos-int)!"</span>},
  <span style="color: #ff7fff;">"[8 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"a is not an allowed op"</span>},
  <span style="color: #ff7fff;">"[8 :else 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"b is not an allowed op"</span>}}
 )
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5549ad" class="outline-4">
<h4 id="orgf5549ad">Second Version</h4>
<div class="outline-text-4" id="text-orgf5549ad">
<p>
In v2 of the keyfnmap
</p>
<ul class="org-ul">
<li>keys match those in the error maps (:err-type and :err-text)</li>
<li>values are maps of keys
<dl class="org-dl">
<dt><code>:key-fn</code></dt><dd>a function to convert the key into its <code>:data-stax-</code> form</dd>
<dt><code>:val-fn</code></dt><dd>a function to convert the values of the sequence of errors by key into a compound string of the key's values</dd>
</dl></li>
</ul>

<p>
Now we've moved the call to <code>key-to-data-stax-key</code> out of <code>map-vals-via-keyfnmap-v2</code> and into the keyfnmap.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(require '[medley.core <span style="color: #34c8d8; font-weight: bold;">:refer</span> [map-vals map-kv]])

(<span style="color: #ffff0b;">def</span> <span style="color: #4ac964;">err-to-data-stax-err-kfm-v2</span>
  {<span style="color: #34c8d8; font-weight: bold;">:err-type</span> {<span style="color: #34c8d8; font-weight: bold;">:key-fn</span> key-to-data-stax-key
              <span style="color: #34c8d8; font-weight: bold;">:val-fn</span> (<span style="color: #ffff0b;">fn</span> [som]
                        (apply str
                               (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-type</span>)
                                               (map name)
                                               (interpose <span style="color: #ff7fff;">" "</span>))
                                         som)))}
   <span style="color: #34c8d8; font-weight: bold;">:err-text</span> {<span style="color: #34c8d8; font-weight: bold;">:key-fn</span> key-to-data-stax-key
              <span style="color: #34c8d8; font-weight: bold;">:val-fn</span> (<span style="color: #ffff0b;">fn</span> [som]
                        (apply str
                               (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-text</span>)
                                               (interpose <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>))
                                         som)))}})

(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">map-vals-via-keyfnmap-v2</span>
  [keyfnmap target-map]
  (map-vals (<span style="color: #ffff0b;">fn</span> [v]
              (map-kv (<span style="color: #ffff0b;">fn</span> [k {<span style="color: #34c8d8; font-weight: bold;">:keys</span> [key-fn val-fn]}]
                        [(key-fn k) (val-fn v)])
                      keyfnmap))
            target-map))


(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">make-node-id-to-data-stax-err-map-v2</span>
  ([nodes]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> (nodes-to-indexed-property nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals-via-keyfnmap-v2 err-to-data-stax-err-kfm-v2)))
  ([nodes err-key err-val-set]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> (nodes-to-indexed-property nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals (partial filter #(<span style="color: #ffff0b;">-&gt;</span> <span style="color: #4ac964;">%</span> err-key err-val-set)))
        (remove-vals empty?)
        (map-vals-via-keyfnmap-v2 err-to-data-stax-err-kfm-v2))))


(<span style="color: #ffff0b;">-&gt;&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)
     <span style="color: #34c8d8; font-weight: bold;">:nodes</span>
     make-node-id-to-data-stax-err-map-v2)

(=&gt;
 {<span style="color: #ff7fff;">"[5 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-invoke-bad-function error=parse-invoke-bad-arity"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"printl is not a known function!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">0 is not a valid arity (must be pos-int)!"</span>},
  <span style="color: #ff7fff;">"[8 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"a is not an allowed op"</span>},
  <span style="color: #ff7fff;">"[8 :else 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"b is not an allowed op"</span>}}
 )
</pre>
</div>
</div>
</div>
<div id="outline-container-org6b3e442" class="outline-4">
<h4 id="org6b3e442">Third and Final Version</h4>
<div class="outline-text-4" id="text-org6b3e442">
<p>
In v3 of the keyfnmap
</p>
<ul class="org-ul">
<li>keys match those in the error maps (:err-type and :err-text)</li>
<li>values are a vector pair of functions [&lt;key-fn&gt; &lt;val-fn&gt;]
<dl class="org-dl">
<dt>&lt;key-fn&gt;</dt><dd>a function to convert the key into its <code>:data-stax-</code> form</dd>
<dt><code>:val-fn</code></dt><dd>a function to convert the values of the sequence of errors by key into a compound string of the key's values</dd>
</dl></li>
</ul>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">def</span> <span style="color: #4ac964;">err-to-data-stax-err-kfm-v3</span>
  {<span style="color: #34c8d8; font-weight: bold;">:err-type</span> [key-to-data-stax-key
              (<span style="color: #ffff0b;">fn</span> [som]
                (apply str
                       (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-type</span>)
                                       (map name)
                                       (interpose <span style="color: #ff7fff;">" "</span>))
                                 som)))]
   <span style="color: #34c8d8; font-weight: bold;">:err-text</span> [key-to-data-stax-key
              (<span style="color: #ffff0b;">fn</span> [som]
                (apply str
                       (sequence (comp (map <span style="color: #34c8d8; font-weight: bold;">:err-text</span>)
                                       (interpose <span style="color: #ff7fff;">"</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">"</span>))
                                 som)))]})

(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">map-vals-via-keyfnmap-v3</span>
     [keyfnmap target-map]
     (map-vals (<span style="color: #ffff0b;">fn</span> [v]
                 (map-kv (<span style="color: #ffff0b;">fn</span> [k [key-fn val-fn]]
                           [(key-fn k) (val-fn v)])
                         keyfnmap))
               target-map))


(<span style="color: #ffff0b;">defn</span> <span style="color: #ff996f;">make-node-id-to-data-stax-err-map-v3</span>
  ([nodes]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> (nodes-to-indexed-property nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals-via-keyfnmap-v3 err-to-data-stax-err-kfm-v3)))
  ([nodes err-key err-val-set]
   (<span style="color: #ffff0b;">-&gt;&gt;</span> (nodes-to-indexed-property nodes (comp str <span style="color: #34c8d8; font-weight: bold;">:node-index</span>) <span style="color: #34c8d8; font-weight: bold;">:errors</span>)
        (map-vals (partial filter #(<span style="color: #ffff0b;">-&gt;</span> <span style="color: #4ac964;">%</span> err-key err-val-set)))
        (remove-vals empty?)
        (map-vals-via-keyfnmap-v3 err-to-data-stax-err-kfm-v3))))

(<span style="color: #ffff0b;">-&gt;&gt;</span> (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)
     <span style="color: #34c8d8; font-weight: bold;">:nodes</span>
     make-node-id-to-data-stax-err-map-v3)


(=&gt;
 {<span style="color: #ff7fff;">"[5 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-invoke-bad-function error=parse-invoke-bad-arity"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"printl is not a known function!</span><span style="color: #ffffff; font-weight: bold;">\n</span><span style="color: #ff7fff;">0 is not a valid arity (must be pos-int)!"</span>},
  <span style="color: #ff7fff;">"[8 :then 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"a is not an allowed op"</span>},
  <span style="color: #ff7fff;">"[8 :else 0]"</span> {<span style="color: #34c8d8; font-weight: bold;">:data-stax-err-type</span> <span style="color: #ff7fff;">"error=parse-illegal-operation"</span>,
                 <span style="color: #34c8d8; font-weight: bold;">:data-stax-err-text</span> <span style="color: #ff7fff;">"b is not an allowed op"</span>}}
 )
</pre>
</div>

<p>
Let's compare their benchmarks
</p>
</div>
</div>

<div id="outline-container-org4a8918a" class="outline-4">
<h4 id="org4a8918a">Comparison</h4>
<div class="outline-text-4" id="text-org4a8918a">
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #ffff0b;">let</span> [{<span style="color: #34c8d8; font-weight: bold;">:keys</span> [nodes]} (build-node-data '[!a !b !c] <span style="color: #9fcb66;">ex</span>/ops-kdh-bad-example)]
  (qb (make-node-id-to-data-stax-err-map-v1 nodes))
  (qb (make-node-id-to-data-stax-err-map-v2 nodes))
  (qb (make-node-id-to-data-stax-err-map-v3 nodes)))
<span style="color: #767283;">;;</span><span style="color: #767283; font-style: italic;">+&gt;</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">================================================================================</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(make-node-id-to-data-stax-err-map-v1 nodes)</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">--------------------------------------------------------------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Evaluation count : 5466 in 6 samples of 911 calls.</span>
<span style="color: #767283;">;;              </span><span style="color: #767283; font-style: italic;">Execution time mean : 236.889674 &#181;s</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">Execution time std-deviation : 223.990691 &#181;s</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time lower quantile : 67.914610 &#181;s ( 2.5%)</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time upper quantile : 613.808271 &#181;s (97.5%)</span>
<span style="color: #767283;">;;                    </span><span style="color: #767283; font-style: italic;">Overhead used : 9.100103 ns</span>

<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Found 1 outliers in 6 samples (16.6667 %)</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     low-severe       1 (16.6667 %)</span>
<span style="color: #767283;">;;  </span><span style="color: #767283; font-style: italic;">Variance from outliers : 83.1311 % Variance is severely inflated by outliers</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">________________________________________________________________________________</span>


<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">================================================================================</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(make-node-id-to-data-stax-err-map-v2 nodes)</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">--------------------------------------------------------------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Evaluation count : 30960 in 6 samples of 5160 calls.</span>
<span style="color: #767283;">;;              </span><span style="color: #767283; font-style: italic;">Execution time mean : 46.341016 &#181;s</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">Execution time std-deviation : 23.430830 &#181;s</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time lower quantile : 19.427353 &#181;s ( 2.5%)</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time upper quantile : 66.481346 &#181;s (97.5%)</span>
<span style="color: #767283;">;;                    </span><span style="color: #767283; font-style: italic;">Overhead used : 9.100103 ns</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">________________________________________________________________________________</span>


<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">================================================================================</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">(make-node-id-to-data-stax-err-map-v3 nodes)</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">--------------------------------------------------------------------------------</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Evaluation count : 30930 in 6 samples of 5155 calls.</span>
<span style="color: #767283;">;;              </span><span style="color: #767283; font-style: italic;">Execution time mean : 31.301246 &#181;s</span>
<span style="color: #767283;">;;     </span><span style="color: #767283; font-style: italic;">Execution time std-deviation : 40.072520 &#181;s</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time lower quantile : 14.280134 &#181;s ( 2.5%)</span>
<span style="color: #767283;">;;    </span><span style="color: #767283; font-style: italic;">Execution time upper quantile : 100.736196 &#181;s (97.5%)</span>
<span style="color: #767283;">;;                    </span><span style="color: #767283; font-style: italic;">Overhead used : 9.100103 ns</span>

<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">Found 1 outliers in 6 samples (16.6667 %)</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">     low-severe       1 (16.6667 %)</span>
<span style="color: #767283;">;;  </span><span style="color: #767283; font-style: italic;">Variance from outliers : 83.2230 % Variance is severely inflated by outliers</span>
<span style="color: #767283;">;; </span><span style="color: #767283; font-style: italic;">________________________________________________________________________________</span>
</pre>
</div>

<p>
<code>make-node-id-to-data-stax-err-map-v1</code> does what it should.
But <code>make-node-id-to-data-stax-err-map-v2</code> does it over 5 times faster.
And <code>make-node-id-to-data-stax-err-map-v3</code> does it over 7 times faster.
</p>

<p>
Plus, I like that the vals in keyfnmap-v3 takes a map-entry like form of [key-fn val-fn], which is analogous to [k v].
It's faster and easier to reason about.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4026f7b" class="outline-2">
<h2 id="org4026f7b">Project Structure ¿TODO?</h2>
<div class="outline-text-2" id="text-org4026f7b">
</div>
<div id="outline-container-orgf885074" class="outline-3">
<h3 id="orgf885074">Files</h3>
<div class="outline-text-3" id="text-orgf885074">
<blockquote id="orgf5a9121">
<p>
ROOT
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
+&#x2013;foo
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">+-&#x2014;bar</td>
</tr>
<tbody>
<tr>
</tr>
</tbody>
</table>
<p>
+&#x2013;baz
+&#x2013;bax
+&#x2013;src
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">+&#x2013;main</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">+&#x2014;java</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">+&#x2014;something</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">+&#x2014;fine</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">+&#x2013;yes</td>
</tr>

<tr>
<td class="org-left">+&#x2013;no</td>
</tr>
</tbody>
</table>
</blockquote>

<p>
svg.clj <a href="../src/clj/kdh/stax/svg.html">src</a> <a href="../dev/clj/kdh/stax/svg.html">dev</a>
</p>
</div>
</div>

<div id="outline-container-orgfe279ae" class="outline-3">
<h3 id="orgfe279ae">Project kdh.stax "0.1.0"</h3>
<div class="outline-text-3" id="text-orgfe279ae">
<pre class="example" id="org494dad9">
stax
├── #notes.org#
├── 2022-04-27T09:38:58.512414700.edn
├── CHANGELOG.md
├── LICENSE
├── README.md
├── dev
│   ├── clj
│   │   ├── #dev.clj#
│   │   ├── bubba.clj
│   │   ├── dev.clj
│   │   ├── kdh
│   │   │   ├── dev_utils.clj
│   │   │   └── stax
│   │   │       ├── #error-tests.clj#
│   │   │       ├── #svg-test.clj#
│   │   │       ├── error-tests.clj
│   │   │       ├── examples-20220629112159Z.clj
│   │   │       ├── nodes-tests.clj
│   │   │       └── svg-test.clj
│   │   ├── resources
│   │   ├── user.clj
│   │   └── vizit.clj
│   └── resources
├── doc
│   └── intro.md
├── html
│   ├── kdh-bad-example-dbg.html
│   ├── kdh-better-example-dbg.html
│   ├── kdh-runtime-error-example-dbg.html
│   ├── kdh-some-bad-paths-example-fix1st-no-static.html
│   ├── kdh-some-bad-paths-example-no-static.html
│   ├── kdh-some-bad-paths-example.html
│   ├── kdh-worse-example-dbg.html
│   ├── mystyle.css
│   └── rpl-example-dbg.html
├── html*
│   ├── kdh-bad-example-dbg.html
│   ├── kdh-better-example-dbg.html
│   ├── kdh-runtime-error-example-dbg.html
│   ├── kdh-worse-example-dbg.html
│   ├── mystyle.css
│   └── rpl-example-dbg.html
├── lein.1
├── lein.sh
├── log
├── nodify-ops*-kdh-better-example.html
├── org
│   ├── 4mat.org
│   ├── dot.org
│   ├── graphviz.org
│   ├── notes.org
│   ├── ops-orig.dot
│   └── switch.png
</pre>
</div>
</div>

<div id="outline-container-org17c1ee6" class="outline-3">
<h3 id="org17c1ee6">Notes on VOVOSON VOVON VOSON SON VON ¿EXPLAIN?</h3>
<div class="outline-text-3" id="text-org17c1ee6">
<dl class="org-dl">
<dt>VOVOSON</dt><dd>a vector of vector of sequence of nodes
<ul class="org-ul">
<li>itermediate form of cartesion paths</li>
</ul></dd>
<dt>VOSON  </dt><dd>a vector of sequence of nodes
<ul class="org-ul">
<li>a single path is a single term for cartesion product of paths</li>
</ul></dd>
<dt>VOVON</dt><dd>a vector of vectors of nodes
<ul class="org-ul">
<li>paths as contained in the node-data returned <code>build-node-data</code></li>
<li>nodes as contained in the node-data returned <code>build-node-data</code></li>
</ul></dd>
<dt>VON</dt><dd>a vector of nodes
<ul class="org-ul">
<li>a single path</li>
</ul></dd>
</dl>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">KEY</th>
<th scope="col" class="org-left">::op=</th>
<th scope="col" class="org-left">DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">:op</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">the operation as a quoted value -e.g. '&lt;pop&gt; or '(invoke&gt; + 2)</td>
</tr>

<tr>
<td class="org-left">:op-type</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">See operation table</td>
</tr>

<tr>
<td class="org-left">:needs</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">how many stack values the operation requires</td>
</tr>

<tr>
<td class="org-left">:delta</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">the change to the stack size after execution</td>
</tr>

<tr>
<td class="org-left">:op-index</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">vector of pos-int to the operation in the original sequence</td>
</tr>

<tr>
<td class="org-left">:node-index</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">vector of pos-int to the operation in the resulting node-tree</td>
</tr>

<tr>
<td class="org-left">:fun</td>
<td class="org-left">invoke</td>
<td class="org-left">function value of invoke&gt; operation</td>
</tr>

<tr>
<td class="org-left">:arity</td>
<td class="org-left">invoke</td>
<td class="org-left">number of stack items the invoke&gt; operation will consume</td>
</tr>

<tr>
<td class="org-left">:then</td>
<td class="org-left">if</td>
<td class="org-left">a node subtree to follow if the top of the stack is truthy</td>
</tr>

<tr>
<td class="org-left">:else</td>
<td class="org-left">if</td>
<td class="org-left">a node subtree to follow if the top of the stack is falsey</td>
</tr>

<tr>
<td class="org-left">:var-ref</td>
<td class="org-left">def/push-var</td>
<td class="org-left">!v form symbol for stack variable</td>
</tr>

<tr>
<td class="org-left">:var-def</td>
<td class="org-left">def-var</td>
<td class="org-left">!v+ form for stack variable (::op=def-var only)</td>
</tr>

<tr>
<td class="org-left">:errors</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">vector of error maps with keys :err-zone :err-type :err-text</td>
</tr>
</tbody>
</table>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">OPERATION</th>
<th scope="col" class="org-left">:op-type</th>
<th scope="col" class="org-right">:needs</th>
<th scope="col" class="org-right">:delta</th>
<th scope="col" class="org-left">DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">!v</td>
<td class="org-left">::op=push-var</td>
<td class="org-right">0</td>
<td class="org-right">+1</td>
<td class="org-left">to push the value of a stack variable onto the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">const</td>
<td class="org-left">::op=push-sef</td>
<td class="org-right">0</td>
<td class="org-right">+1</td>
<td class="org-left">to push the value of a self evaluating form onto the stack</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">(number, string, character, keyword, boolean, nil)</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">&lt;pop&gt;</td>
<td class="org-left">::op=pop</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
<td class="org-left">to pop the top of the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">!v+</td>
<td class="org-left">::op=def-var</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">to define a (possibly new) stack variable and assign it</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">the stack without changing the stack</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(invoke&gt; f n)</td>
<td class="org-left">::op=invoke</td>
<td class="org-right">n</td>
<td class="org-right">-(n-1)</td>
<td class="org-left">to invoke a function f :fun on a number of arguments :arity</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">removed from the stack and replace with its return value</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(if&gt; t1 t2&#x2026;</td>
<td class="org-left">::op=if</td>
<td class="org-right">1</td>
<td class="org-right">-1</td>
<td class="org-left">to branch conditionally on the top of the stack (popping it)</td>
</tr>

<tr>
<td class="org-left">else&gt; e1 e2&#x2026;)</td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-left">into :then or :else which are vectors of nodes</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">any other form</td>
<td class="org-left">::op=illegal</td>
<td class="org-right">NA</td>
<td class="org-right">NA</td>
<td class="org-left">not a legal op"</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-orgaaa7995" class="outline-4">
<h4 id="orgaaa7995">(nodify-ops operations) =&gt; node-tree</h4>
<div class="outline-text-4" id="text-orgaaa7995">
<p>
The list of operations given to defstackfn is converted into a node-tree,
which is a vector of nodes where if&gt; nodes contain :then and :else branches,
which are themselves vectors of nodes.
Parse errors are added to the nodes at this stage and for:
</p>
<ul class="org-ul">
<li>invoke&gt;
<ul class="org-ul">
<li>:kdh.stax.errs/error=invoke-wrong-number-args</li>
<li>:kdh.stax.errs/error=invoke-bad-function</li>
<li>:kdh.stax.errs/error=invoke-bad-arity</li>
</ul></li>
<li>illegal operations
<ul class="org-ul">
<li>:kdh.stax.errs/error=illegal-operation</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-org7b48027" class="outline-4">
<h4 id="org7b48027">(flatten-node-tree node-tree) =&gt; nodes</h4>
<div class="outline-text-4" id="text-org7b48027">
<p>
nodes is a vector of nodes in the same order left to right as operations given to defstackfn with the if&gt; and else&gt; terms and parenthesis removed. nodes main use is for scanning for tree errors in node-tree (errors found by nodify-ops). The kdh.stax.svg/node-data-to-html uses it to decorate the tree visualization (the black diagram) with global errors (errors whose :err-zone value is :kdh.stax.errs/zone=tree).
</p>
</div>
</div>
<div id="outline-container-org062a834" class="outline-4">
<h4 id="org062a834">(node-tree-to-node-paths declarations node-tree) =&gt; paths a vovon where each path is a von</h4>
<div class="outline-text-4" id="text-org062a834">
<p>
For the static analysis checks, we want to analyze each path through the tree for consistency.
</p>
</div>

<div id="outline-container-orgc8f7acd" class="outline-5">
<h5 id="orgc8f7acd">(check-refs-path path)</h5>
<div class="outline-text-5" id="text-orgc8f7acd">
<p>
Variables in a path cannot be referenced before being defined (except for the declarations supplied to defstackfn).
</p>
<ul class="org-ul">
<li>:kdh.stax.errs/error=insufficient-stack</li>
</ul>
</div>
</div>
<div id="outline-container-org1648764" class="outline-5">
<h5 id="org1648764">(count-card-path path)</h5>
<div class="outline-text-5" id="text-org1648764">
<p>
Stack cardinality, if the needs of an op node are greater than the size of the stack, the node is given an error of :err-type:
</p>
<ul class="org-ul">
<li>:kdh.stax.errs/error=undefined-var</li>
</ul>



<p>
Execution steps, we want to traverse the node-tree, maintaining state as we go, deciding on the fly whether to travel through :then or :else.  The trace of such traversal is a path (possibly incomplete due to runtime errors).
</p>
<ul class="org-ul">
<li>For stack cardinality (the size of stack must be &gt;= the needs of an op node for the op to be executable).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org693e027" class="outline-4">
<h4 id="org693e027"><span class="todo TODO">TODO</span> Notes to Self (fix for 0.1.0 release)</h4>
<div class="outline-text-4" id="text-org693e027">
</div>
<div id="outline-container-org3199697" class="outline-5">
<h5 id="org3199697"><span class="todo TODO">TODO</span> print runtime errors</h5>
<div class="outline-text-5" id="text-org3199697">
<p>
Especially for static analysis failed &#x2013; throw them when <b>throw-on-error</b>
</p>
</div>
</div>
<div id="outline-container-orgbd816e5" class="outline-5">
<h5 id="orgbd816e5"><span class="todo TODO">TODO</span> Maybe rename and/or split <b>throw-on-error</b></h5>
</div>
<div id="outline-container-orgd6c04e4" class="outline-5">
<h5 id="orgd6c04e4"><span class="todo DOING">DOING</span> enforce sef args to &lt;stackfn&gt;</h5>
</div>
<div id="outline-container-org1f916eb" class="outline-5">
<h5 id="org1f916eb"><span class="todo TODO">TODO</span> handle &lt;stackfn&gt;-debug case with 0 args and 0 dcls (i.e. exec once for results of one)</h5>
</div>
<div id="outline-container-org88f5236" class="outline-5">
<h5 id="org88f5236"><span class="done DONE">DONE</span> test if&gt; in first position for cardi fail</h5>
<div class="outline-text-5" id="text-org88f5236">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-06-21 Tue 02:01]</span></span></p>
<p>
this is fixed by addition of if-pop
</p>
</div>
</div>
<div id="outline-container-org95d07b0" class="outline-5">
<h5 id="org95d07b0"><span class="done DONE">DONE</span> Fix "Cannot throw exception" - throw of nil</h5>
<div class="outline-text-5" id="text-org95d07b0">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-06-21 Tue 13:00]</span></span></p>
</div>
</div>
<div id="outline-container-orgfc187ed" class="outline-5">
<h5 id="orgfc187ed"><span class="done DONE">DONE</span> enforce sef on result of invoke</h5>
<div class="outline-text-5" id="text-orgfc187ed">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-06-21 Tue 13:01]</span></span></p>
</div>
</div>
<div id="outline-container-orgf51a7be" class="outline-5">
<h5 id="orgf51a7be"><span class="done CANCELED">CANCELED</span> handle graph vs digraph ("&#x2013;" vs "-&gt;")</h5>
<div class="outline-text-5" id="text-orgf51a7be">
<p><span class="timestamp-wrapper"><span class="timestamp-kwd">CLOSED:</span> <span class="timestamp">[2022-06-21 Tue 13:01]</span></span></p>
</div>
</div>
<div id="outline-container-org50ed065" class="outline-5">
<h5 id="org50ed065"><span class="todo TODO">TODO</span> discuss constant as</h5>
<div class="outline-text-5" id="text-org50ed065">
</div>
<div id="outline-container-orgf3bdef7" class="outline-6">
<h6 id="orgf3bdef7">self-evaluating?</h6>
</div>
<div id="outline-container-org56ed1d8" class="outline-6">
<h6 id="org56ed1d8">simple vs complex</h6>
</div>
<div id="outline-container-org3d60828" class="outline-6">
<h6 id="org3d60828">item vs collection</h6>
</div>
<div id="outline-container-orgd3c643f" class="outline-6">
<h6 id="orgd3c643f">restriction on lookup</h6>
</div>
</div>
<div id="outline-container-orgef53c39" class="outline-5">
<h5 id="orgef53c39"><span class="todo TODO">TODO</span> note that invoke cannot take a literal or anonymous function</h5>
</div>
</div>
<div id="outline-container-org1a29373" class="outline-4">
<h4 id="org1a29373">Notes to Future Self (fix for future releases)</h4>
<div class="outline-text-4" id="text-org1a29373">
</div>
<div id="outline-container-org270349b" class="outline-5">
<h5 id="org270349b"><span class="todo TODO">TODO</span> add tests</h5>
<div class="outline-text-5" id="text-org270349b">
<p>
In version 0.1.0 many of the tests are inside (comment )
</p>
<ul class="org-ul">
<li>This aids in quick testing of the code during development</li>
<li>These will be moved into test libraries for version 0.2.x</li>
</ul>
</div>
</div>
<div id="outline-container-orga284516" class="outline-5">
<h5 id="orga284516"><span class="todo TODO">TODO</span> defrecord OpNode and one or more defprotocol</h5>
<div class="outline-text-5" id="text-orga284516">
<p>
Now that the map version is understood, version 0.2.x should use a record with required keys [op op-index node-index needs delta]
and protocols to extend
</p>
</div>
</div>
<div id="outline-container-org6f82f29" class="outline-5">
<h5 id="org6f82f29"><span class="todo TODO">TODO</span> defrecord OpError and one or more defprotocol</h5>
<div class="outline-text-5" id="text-org6f82f29">
<p>
Now that the map version is understood, version 0.2.x should use a record with required keys [err-text err-type err-zone]
and protocols to define (message) and (data) for cleaner error to throw calls
</p>
<ul class="org-ul">
<li>(message #OpError) could return (:err-text self)</li>
<li>(data #OpError) could return (dissoc self :err-text)</li>
</ul>
</div>
</div>
<div id="outline-container-org0f53025" class="outline-5">
<h5 id="org0f53025"><span class="todo TODO">TODO</span> client-side stack op builder</h5>
<div class="outline-text-5" id="text-org0f53025">
<p>
The html dbg generation shows that svg can be quite useful for visualizing errors.
A re-frame app that allows for dynamic altering of ops and reactive path/results generation would be a good front-end dev project.
</p>
</div>
</div>
<div id="outline-container-org6b5a8a9" class="outline-5">
<h5 id="org6b5a8a9"><span class="todo TODO">TODO</span> harmonize :results :trace to :path</h5>
<div class="outline-text-5" id="text-org6b5a8a9">
<p>
Currently, the trace (which is generated from :node-tree) does not contain ::op=start or ::op=term nodes.
This prevents :data-stax-path "good" "bad" marking of the resulting svg, which prevents css coloring of those nodes and adjacent edges.
Fixing this is tricky and not necessary for the current html generation (which is for dev use only &#x2013; i.e. not a client-side app).
But I have some thoughts now on adding this feature:
</p>
<ul class="org-ul">
<li>A completed (i.e. no :errors) :result :trace set is (keep :node-index) equivalent to a :path
minus the path's first (i.e. ::op=start) and last (i.e ::op=term)</li>
<li>An incomplete result (i.e. has :errors) might have multiple branches after the :error
I think I don't want to mark them, instead only mark from ::op=start to node of :error</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org244a779" class="outline-2">
<h2 id="org244a779">Environment</h2>
<div class="outline-text-2" id="text-org244a779">
<p>
I wrote this as in
</p>
<ul class="org-ul">
<li>org-mode <code>release​_9.4.4</code></li>
<li>emacs <code>version 27.2</code></li>
</ul>

<p>
The code was built with
</p>
<ul class="org-ul">
<li>CIDER 1.3.0 (Ukraine)</li>
<li>Leiningen <code>2.9.8</code></li>
<li>Clojure <code>1.11.1</code></li>
<li>dot - graphviz version <code>2.43.0</code></li>
<li>Java ~17.0.3 OpenJDK 64-Bit Server VM on Ubuntu (build 17.0.3+7-Ubuntu-0ubuntu0.20.04.1)</li>
</ul>

<p>
The OS
</p>
<ul class="org-ul">
<li>Ubuntu <code>20.04.4 LTS</code></li>
<li>WSL2 on Windows-11</li>
</ul>
</div>

<div id="outline-container-org4a78a28" class="outline-3">
<h3 id="org4a78a28">Java Properties</h3>
<div class="outline-text-3" id="text-org4a78a28">
<div class="ORG" id="org4923e10">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 7:</span> Java Properties</caption>

<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">apple.awt.UIElement</td>
<td class="org-left">true</td>
</tr>

<tr>
<td class="org-left">clojure.compile.path</td>
<td class="org-left">/mnt/e/Sync/clojure/rpl/stax/target/classes</td>
</tr>

<tr>
<td class="org-left">clojure.debug</td>
<td class="org-left">false</td>
</tr>

<tr>
<td class="org-left">file.encoding</td>
<td class="org-left">UTF-8</td>
</tr>

<tr>
<td class="org-left">file.separator</td>
<td class="org-left">/</td>
</tr>

<tr>
<td class="org-left">java.home</td>
<td class="org-left">/usr/lib/jvm/java-17-openjdk-amd64</td>
</tr>

<tr>
<td class="org-left">java.io.tmpdir</td>
<td class="org-left">/tmp</td>
</tr>

<tr>
<td class="org-left">java.library.path</td>
<td class="org-left">/usr/java/packages/lib:/usr/lib/x86​_64-linux-gnu/jni:/lib/x86​_64-linux-gnu:/usr/lib/x86​_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib</td>
</tr>

<tr>
<td class="org-left">java.runtime.name</td>
<td class="org-left">OpenJDK Runtime Environment</td>
</tr>

<tr>
<td class="org-left">java.runtime.version</td>
<td class="org-left">17.0.3+7-Ubuntu-0ubuntu0.20.04.1</td>
</tr>

<tr>
<td class="org-left">java.specification.name</td>
<td class="org-left">Java Platform API Specification</td>
</tr>

<tr>
<td class="org-left">java.specification.vendor</td>
<td class="org-left">Oracle Corporation</td>
</tr>

<tr>
<td class="org-left">java.specification.version</td>
<td class="org-left">17</td>
</tr>

<tr>
<td class="org-left">java.vendor</td>
<td class="org-left">Private Build</td>
</tr>

<tr>
<td class="org-left">java.vendor.url</td>
<td class="org-left">Unknown</td>
</tr>

<tr>
<td class="org-left">java.vendor.url.bug</td>
<td class="org-left">Unknown</td>
</tr>

<tr>
<td class="org-left">java.version</td>
<td class="org-left">17.0.3</td>
</tr>

<tr>
<td class="org-left">java.version.date</td>
<td class="org-left">2022-04-19</td>
</tr>

<tr>
<td class="org-left">java.vm.compressedOopsMode</td>
<td class="org-left">32-bit</td>
</tr>

<tr>
<td class="org-left">java.vm.info</td>
<td class="org-left">mixed mode, sharing</td>
</tr>

<tr>
<td class="org-left">java.vm.name</td>
<td class="org-left">OpenJDK 64-Bit Server VM</td>
</tr>

<tr>
<td class="org-left">java.vm.specification.name</td>
<td class="org-left">Java Virtual Machine Specification</td>
</tr>

<tr>
<td class="org-left">java.vm.specification.vendor</td>
<td class="org-left">Oracle Corporation</td>
</tr>

<tr>
<td class="org-left">java.vm.specification.version</td>
<td class="org-left">17</td>
</tr>

<tr>
<td class="org-left">java.vm.vendor</td>
<td class="org-left">Private Build</td>
</tr>

<tr>
<td class="org-left">java.vm.version</td>
<td class="org-left">17.0.3+7-Ubuntu-0ubuntu0.20.04.1</td>
</tr>

<tr>
<td class="org-left">jdk.debug</td>
<td class="org-left">release</td>
</tr>

<tr>
<td class="org-left">line.separator</td>
<td class="org-left">\n</td>
</tr>

<tr>
<td class="org-left">native.encoding</td>
<td class="org-left">UTF-8</td>
</tr>

<tr>
<td class="org-left">os.arch</td>
<td class="org-left">amd64</td>
</tr>

<tr>
<td class="org-left">os.name</td>
<td class="org-left">Linux</td>
</tr>

<tr>
<td class="org-left">os.version</td>
<td class="org-left">5.10.102.1-microsoft-standard-WSL2</td>
</tr>

<tr>
<td class="org-left">path.separator</td>
<td class="org-left">:</td>
</tr>

<tr>
<td class="org-left">stax.version</td>
<td class="org-left">0.1.0-SNAPSHOT</td>
</tr>

<tr>
<td class="org-left">sun.arch.data.model</td>
<td class="org-left">64</td>
</tr>

<tr>
<td class="org-left">sun.boot.library.path</td>
<td class="org-left">/usr/lib/jvm/java-17-openjdk-amd64/lib</td>
</tr>

<tr>
<td class="org-left">sun.cpu.endian</td>
<td class="org-left">little</td>
</tr>

<tr>
<td class="org-left">sun.io.unicode.encoding</td>
<td class="org-left">UnicodeLittle</td>
</tr>

<tr>
<td class="org-left">sun.java.command</td>
<td class="org-left">clojure.main -i /tmp/form-init14542468886342858337.clj</td>
</tr>

<tr>
<td class="org-left">sun.java.launcher</td>
<td class="org-left">SUN​_STANDARD</td>
</tr>

<tr>
<td class="org-left">sun.jnu.encoding</td>
<td class="org-left">UTF-8</td>
</tr>

<tr>
<td class="org-left">sun.management.compiler</td>
<td class="org-left">HotSpot 64-Bit Tiered Compilers</td>
</tr>

<tr>
<td class="org-left">user.dir</td>
<td class="org-left">/mnt/e/Sync/clojure/rpl/stax</td>
</tr>

<tr>
<td class="org-left">user.home</td>
<td class="org-left">/home/keith</td>
</tr>

<tr>
<td class="org-left">user.language</td>
<td class="org-left">en</td>
</tr>

<tr>
<td class="org-left">user.name</td>
<td class="org-left">keith</td>
</tr>

<tr>
<td class="org-left">user.timezone</td>
<td class="org-left">America/New​_York</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>

<div id="outline-container-orgb994717" class="outline-3">
<h3 id="orgb994717">Java Class Path</h3>
<div class="outline-text-3" id="text-orgb994717">
<table><caption>Java Class Path</caption><tr><td>/mnt/e/Sync/clojure/rpl/stax/test</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev/clj</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/src/clj</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev/clj/resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/dev-resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/resources</td></tr><tr><td>/mnt/e/Sync/clojure/rpl/stax/target/classes</td></tr><tr><td>/home/keith/.m2/repository/djblue/portal/0.28.0/portal-0.28.0.jar</td></tr><tr><td>/home/keith/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.8.7/jackson-core-2.8.7.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-model-builder/3.5.3/maven-model-builder-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-builder-support/3.5.3/maven-builder-support-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/nrepl/incomplete/0.1.0/incomplete-0.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/msgpack/msgpack/0.6.12/msgpack-0.6.12.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/httpcomponents/httpclient/4.5.3/httpclient-4.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-io/commons-io/2.5/commons-io-2.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-model/3.5.3/maven-model-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-wagon/1.0.3/maven-resolver-transport-wagon-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/criterium/criterium/0.4.4/criterium-0.4.4.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-java/1.0.362/transit-java-1.0.362.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-util/1.1.1/maven-resolver-util-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/rpl/specter/1.1.4/specter-1.1.4.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/data.xml/0.0.8/data.xml-0.0.8.jar</td></tr><tr><td>/home/keith/.m2/repository/com/google/guava/guava/20.0/guava-20.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-repository-metadata/3.5.3/maven-repository-metadata-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/javax/xml/bind/jaxb-api/2.3.0/jaxb-api-2.3.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-resolver-provider/3.5.3/maven-resolver-provider-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-utils/3.1.0/plexus-utils-3.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-provider-api/3.0.0/wagon-provider-api-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/fipp/fipp/0.6.23/fipp-0.6.23.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-http/3.0.0/wagon-http-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-js/0.8.874/transit-js-0.8.874.jar</td></tr><tr><td>/home/keith/.m2/repository/mvxcvi/arrangement/1.2.0/arrangement-1.2.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-api/1.1.1/maven-resolver-api-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.7.1/plexus-component-annotations-1.7.1.jar</td></tr><tr><td>/home/keith/.m2/repository/rewrite-clj/rewrite-clj/0.6.1/rewrite-clj-0.6.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-http/1.0.3/maven-resolver-transport-http-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/zprint/zprint/1.1.1/zprint-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/math.numeric-tower/0.0.5/math.numeric-tower-0.0.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-connector-basic/1.0.3/maven-resolver-connector-basic-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/core.rrb-vector/0.1.2/core.rrb-vector-0.1.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-spi/1.1.1/maven-resolver-spi-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/mvxcvi/puget/1.3.1/puget-1.3.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/tcrawley/dynapath/1.0.0/dynapath-1.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/httpcomponents/httpcore/4.4.6/httpcore-4.4.6.jar</td></tr><tr><td>/home/keith/.m2/repository/macroz/tangle/0.2.2/tangle-0.2.2.jar</td></tr><tr><td>/home/keith/.m2/repository/rewrite-cljs/rewrite-cljs/0.4.5/rewrite-cljs-0.4.5.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/sci/0.2.1-alpha.1/sci-0.2.1-alpha.1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/jsoup/jsoup/1.7.2/jsoup-1.7.2.jar</td></tr><tr><td>/home/keith/.m2/repository/com/googlecode/json-simple/json-simple/1.1.1/json-simple-1.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/hiccup/hiccup/1.0.5/hiccup-1.0.5.jar</td></tr><tr><td>/home/keith/.m2/repository/nrepl/nrepl/0.8.3/nrepl-0.8.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/flatland/ordered/1.5.7/ordered-1.5.7.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/core.specs.alpha/0.2.62/core.specs.alpha-0.2.62.jar</td></tr><tr><td>/home/keith/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar</td></tr><tr><td>/home/keith/.m2/repository/org/flatland/useful/0.11.6/useful-0.11.6.jar</td></tr><tr><td>/home/keith/.m2/repository/hashp/hashp/0.2.1/hashp-0.2.1.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/sci.impl.reflector/0.0.1/sci.impl.reflector-0.0.1.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-cljs/0.8.269/transit-cljs-0.8.269.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/spec.alpha/0.3.218/spec.alpha-0.3.218.jar</td></tr><tr><td>/home/keith/.m2/repository/org/slf4j/jcl-over-slf4j/1.6.2/jcl-over-slf4j-1.6.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/commons/commons-lang3/3.5/commons-lang3-3.5.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/wagon/wagon-http-shared/3.0.0/wagon-http-shared-3.0.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-transport-file/1.0.3/maven-resolver-transport-file-1.0.3.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar</td></tr><tr><td>/home/keith/.m2/repository/failjure/failjure/2.2.0/failjure-2.2.0.jar</td></tr><tr><td>/home/keith/.m2/repository/riddley/riddley/0.1.12/riddley-0.1.12.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/data.json/2.4.0/data.json-2.4.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.24/plexus-interpolation-1.24.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-logging/commons-logging/1.2/commons-logging-1.2.jar</td></tr><tr><td>/home/keith/.m2/repository/commons-codec/commons-codec/1.9/commons-codec-1.9.jar</td></tr><tr><td>/home/keith/.m2/repository/cider/cider-nrepl/0.28.3/cider-nrepl-0.28.3.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cemerick/pomegranate/1.1.0/pomegranate-1.1.0.jar</td></tr><tr><td>/home/keith/.m2/repository/com/cognitect/transit-clj/1.0.329/transit-clj-1.0.329.jar</td></tr><tr><td>/home/keith/.m2/repository/org/clojure/tools.macro/0.1.1/tools.macro-0.1.1.jar</td></tr><tr><td>/home/keith/.m2/repository/borkdude/edamame/0.0.11-alpha.28/edamame-0.0.11-alpha.28.jar</td></tr><tr><td>/home/keith/.m2/repository/org/javassist/javassist/3.18.1-GA/javassist-3.18.1-GA.jar</td></tr><tr><td>/home/keith/.m2/repository/http-kit/http-kit/2.6.0/http-kit-2.6.0.jar</td></tr><tr><td>/home/keith/.m2/repository/medley/medley/1.4.0/medley-1.4.0.jar</td></tr><tr><td>/home/keith/.m2/repository/org/slf4j/slf4j-api/1.6.2/slf4j-api-1.6.2.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/maven-artifact/3.5.3/maven-artifact-3.5.3.jar</td></tr><tr><td>/home/keith/.m2/repository/clj-stacktrace/clj-stacktrace/0.2.8/clj-stacktrace-0.2.8.jar</td></tr><tr><td>/home/keith/.m2/repository/org/apache/maven/resolver/maven-resolver-impl/1.1.1/maven-resolver-impl-1.1.1.jar</td></tr></table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Keith D Houser</p>
<p class="date">Created: 2022-07-14 Thu 03:09</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
